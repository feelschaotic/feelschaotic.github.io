<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FeelsChaotic</title>
  <subtitle>程序媛、乐器狂、工匠、重度偏执者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-20T04:27:26.042Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>feelschaotic</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android-——-网易易盾验证码异常-libEGL--validate_display-99-error-3008-(EGL_BAD_DISPLAY)</title>
    <link href="http://yoursite.com/2017/07/24/Android-%E2%80%94%E2%80%94-%E7%BD%91%E6%98%93%E6%98%93%E7%9B%BE%E9%AA%8C%E8%AF%81%E7%A0%81%E5%BC%82%E5%B8%B8-libEGL--validate_display-99-error-3008-(EGL_BAD_D/"/>
    <id>http://yoursite.com/2017/07/24/Android-——-网易易盾验证码异常-libEGL--validate_display-99-error-3008-(EGL_BAD_D/</id>
    <published>2017-07-24T08:00:00.000Z</published>
    <updated>2017-08-20T04:27:26.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前提：WebView在 Android 5.1 测试机上正常显示，在 Android 7.0 上无法显示，一直 loading 。（注：url 为 htts 协议）</p>
</blockquote>
<p>考虑到验证码的 Webview 和 Listener 都是自己重写，可能漏掉了什么，果然在细细翻看官方源码的时候，发现了 WebViewClient 多复写了 onReceivedSslError 监听，初步判断是遇到证书问题。</p>
<p>解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mWebView.setWebViewClient(new WebViewClient() &#123;</div><div class="line">           @Override</div><div class="line">           public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;</div><div class="line">               handler.proceed(); // Ignore SSL certificate errors</div><div class="line">           // fix for: SSL Error. Failed to validate the certificate chain </div><div class="line">           //不要调用super.xxxx</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>原因：</p>
<p>在 Android 中，WebView 可以用来加载 http 和 https 网页到本地应用的控件。在默认情况下，通过 <code>loadUrl(String url)</code> 方法，可以顺利  <code>loadUrl(&quot;http://www.baidu.com&quot;)</code>之类的页面。但是，当 load 通过 ssl 加密的 https 页面，且这个网站的安全证书在 Android 无法得到认证时，WebView就会变成一个空白页，而并不会像自带的浏览器一样弹出提示。因此，我们必须针对这种情况进行处理。</p>
<p>拓展：</p>
<p>不过如果在 <code>onReceivedSslError</code> 方法中实现调用了 <code>handler.proceed()</code>来忽略该证书错误，则会受到中间人攻击的威胁，可能导致隐私泄露。可以采用默认的处理方法<code>handler.cancel()</code>，停止加载问题页面。<br>（鉴于项目需求，所以仍然采用<code>handler.proceed();</code>）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前提：WebView在 Android 5.1 测试机上正常显示，在 Android 7.0 上无法显示，一直 loading 。（注：url 为 htts 协议）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑到验证码的 Webview 和 Listener 都是自己重写，可能漏掉了什么，果然在细细翻看官方源码的时候，发现了 WebViewClient 多复写了 onReceivedSslError 监听，初步判断是遇到证书问题。&lt;/p&gt;
&lt;p&gt;解决：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mWebView.setWebViewClient(new WebViewClient() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           @Override&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;               handler.proceed(); // Ignore SSL certificate errors&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           // fix for: SSL Error. Failed to validate the certificate chain &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           //不要调用super.xxxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-打包INSTALL_PARSE_FAILED_NO_CERTIFICATES异常</title>
    <link href="http://yoursite.com/2017/07/20/Android-%E2%80%94%E2%80%94-%E6%89%93%E5%8C%85INSTALL_PARSE_FAILED_NO_CERTIFICATES%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/07/20/Android-——-打包INSTALL_PARSE_FAILED_NO_CERTIFICATES异常/</id>
    <published>2017-07-20T03:43:00.000Z</published>
    <updated>2017-08-20T04:28:14.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前提：明明已经签名，在安装时却提示 <code>INSTALL_PARSE_FAILED_NO_CERTIFICATES</code> 异常</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-6b4e49bade94fed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装失败情形"></p>
<p>排查：</p>
<p>安装的测试机系统为 5.0，只采用了 v2 签名</p>
<a id="more"></a>
<p>解决：</p>
<p>改为安装在 7.0 手机或者选择 v1 + v2 签名。</p>
<p>原因：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-ae621be14c406309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在 Android 7.0 以上版本的设备上，APK 可以根据Full Apk Signature（v2 方案） 或者 JAR-signed（ v1方案）进行验证； 而对于7.0以下版本的设备其会忽略 v2 版本的签名，<strong>只验证 v1 签名</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-74f969787e7d154a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证的流程.png"></p>
<p>结论：</p>
<ul>
<li>一定可行的方案： 只使用 v1 方案</li>
<li>不一定可行的方案：同时使用 v1 和 v2 方案</li>
<li>对 7.0 以下<strong>一定不行</strong>的方案：只使用 v2 方案</li>
</ul>
<p>如果要支持 Android 7.0 以下版本，那么尽量同时选择两种签名方式，但是一旦遇到签名问题，可以只使用 v1 签名方案</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前提：明明已经签名，在安装时却提示 &lt;code&gt;INSTALL_PARSE_FAILED_NO_CERTIFICATES&lt;/code&gt; 异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-6b4e49bade94fed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装失败情形&quot;&gt;&lt;/p&gt;
&lt;p&gt;排查：&lt;/p&gt;
&lt;p&gt;安装的测试机系统为 5.0，只采用了 v2 签名&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 和Java的型变</title>
    <link href="http://yoursite.com/2017/07/13/Kotlin-%E5%92%8CJava%E7%9A%84%E5%9E%8B%E5%8F%98/"/>
    <id>http://yoursite.com/2017/07/13/Kotlin-和Java的型变/</id>
    <published>2017-07-13T07:25:00.000Z</published>
    <updated>2017-09-03T09:00:10.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java-的型变"><a href="#1-Java-的型变" class="headerlink" title="1. Java 的型变"></a>1. Java 的型变</h3><p>如果 Parent 是 Child 的父类，那么 <code>List&lt;Parent&gt;</code> 和<code>List&lt;Child&gt;</code> 的关系是什么呢？对于 Java 来说，没有关系。<br><a id="more"></a><br>也就是说下面的代码是无法编译的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Number&gt; numbers = new ArrayList&lt;Integer&gt;(); //ERROR!</div></pre></td></tr></table></figure>
<p>不过 numbers 中可以添加 Number 类型的对象，所以我添加个 Integer 可以不呢？可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers.add(1);</div></pre></td></tr></table></figure></p>
<p>那么我要想添加一堆 Integer 呢？用 addAll 是吧？注意看下 addAll 的签名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean addAll(Collection&lt;? extends E&gt; c);</div></pre></td></tr></table></figure></p>
<p>这个泛型参数又是什么鬼？如果我把这个签名写成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean addAll(Collection&lt;E&gt; c);</div></pre></td></tr></table></figure></p>
<p>我想要在 numbers 当中<code>addAll</code> 一个 <code>ArrayList&lt;Integer&gt;</code>，那就不可能了，因为我们说过，<code>ArrayList&lt;Number&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code>是两个不同的类型，毛关系都没有。</p>
<p><code>? extends E</code> 其实就是使用点协变，允许传入的参数可以是泛型参数类型为<code>Number</code> 子类的任意类型。</p>
<p>当然，也有 <code>? super E</code>的用法，这表示元素类型为<code>E</code> 及其父类，这个通常也叫作逆变。</p>
<h3 id="2-Kotlin-的型变"><a href="#2-Kotlin-的型变" class="headerlink" title="2. Kotlin 的型变"></a>2. Kotlin 的型变</h3><blockquote>
<p>型变包括协变、逆变、不变三种</p>
</blockquote>
<p>下面我们看看 Kotlin 是怎么支持这个特性的。Kotlin 支持声明点型变，我们直接看 Collection 接口的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>out E</code> 就是型变的定义，表明 Collection 的元素类型是协变的，即 <code>Collection&lt;Number&gt;</code> 也是 <code>Collection&lt;Int&gt;</code> 的父类。</p>
<p>而对于 <code>MutableList</code> 来说，它的元素类型就是不变的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface MutableCollection&lt;E&gt; : Collection&lt;E&gt;, MutableIterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">   public fun addAll(elements: Collection&lt;E&gt;): Boolean </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>换言之，<code>MutableCollection&lt;Number&gt;</code> 与<code>MutableCollection&lt;Int&gt;</code> 没有什么关系。</p>
<p>那么请注意看 addAll 的声明，参数是 <code>Collection&lt;E&gt;</code>，而 Collection 是协变的，所以传入的参数可以是任意 E 或者其子类的集合。</p>
<p>逆变的写法也简单一些： <code>Collection&lt;in E&gt;</code>。</p>
<p>那么 Kotlin 是否支持使用点型变呢？当然支持。</p>
<p>我们刚才说 <code>MutableCollection</code> 是不变的，那么如果下面的参数改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public fun addAll(elements: MutableCollection&lt;E&gt;): Boolean</div></pre></td></tr></table></figure>
<p>结果就是，当 E 为 Number 时，addAll 无法接类受似<code>ArrayList&lt;Int&gt;</code>的参数。而为了接受这样的参数，我们可以修改一下签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public fun addAll(elements: MutableCollection&lt;out E&gt;): Boolean</div></pre></td></tr></table></figure>
<p>这其实就与 Java 的型变完全一致了。</p>
<h3 id="3-UnsafeVariance"><a href="#3-UnsafeVariance" class="headerlink" title="3. @UnsafeVariance"></a>3. @UnsafeVariance</h3><p>型变是一个让人费解的话题，很多人接触这东西的时候一开始都会比较晕，我们来看看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyCollection&lt;out T&gt;&#123; </div><div class="line">    fun add(t: T)&#123; // ERROR! </div><div class="line">       ... </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为什么会报错呢？因为 T 是协变的，所以外部传入的参数类型如果是 T 的话，会出问题，不信你看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myList: MyCollection&lt;Number&gt; = MyCollection&lt;Int&gt;() </div><div class="line">myList.add(3.0)</div></pre></td></tr></table></figure></p>
<p>上面的代码毫无疑问可以编译，但运行时就会比较尴尬，因为 <code>MyCollection&lt;Int&gt;</code> 希望接受的是 <code>Int</code>，没想到来了一个 <code>Double</code>。。</p>
<p>对于协变的类型，通常我们是不允许将泛型类型作为传入参数的类型的，或者说，对于协变类型，我们通常是不允许其涉及泛型参数的部分被改变的。这也很容易解释为什么 MutableCollection 是不变的，而 Collection 是协变的，因为在 Kotlin 当中，前者是可被修改的，后者是不可被修改的。</p>
<p>逆变的情形正好相反，即不可以将泛型参数作为方法的返回值。</p>
<p>但实际上有些情况下，我们不得已需要在协变的情况下使用泛型参数类型作为方法参数的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">    public operator fun contains(element: @UnsafeVariance E): Boolean </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如这种情形，为了让编译器放过一马，我们就可以用 @UnsafeVariance 来告诉编译器：“我知道我在干啥，保证不会出错，你不用担心”。</p>
<p>最后再给大家提一个点，现在你们知道为什么 in 表示逆变，out 表示协变了吗？</p>
<blockquote>
<p>节选自：<a href="https://mp.weixin.qq.com/s/WUoanF3_OAP0dRoxBQu_bQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/WUoanF3_OAP0dRoxBQu_bQ</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Java-的型变&quot;&gt;&lt;a href=&quot;#1-Java-的型变&quot; class=&quot;headerlink&quot; title=&quot;1. Java 的型变&quot;&gt;&lt;/a&gt;1. Java 的型变&lt;/h3&gt;&lt;p&gt;如果 Parent 是 Child 的父类，那么 &lt;code&gt;List&amp;lt;Parent&amp;gt;&lt;/code&gt; 和&lt;code&gt;List&amp;lt;Child&amp;gt;&lt;/code&gt; 的关系是什么呢？对于 Java 来说，没有关系。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-输入手机号时自动添加空白（全情况考虑）</title>
    <link href="http://yoursite.com/2017/05/19/Android-%E2%80%94%E2%80%94-%E8%BE%93%E5%85%A5%E6%89%8B%E6%9C%BA%E5%8F%B7%E6%97%B6%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%A9%BA%E7%99%BD%EF%BC%88%E5%85%A8%E6%83%85%E5%86%B5%E8%80%83%E8%99%91%EF%BC%89/"/>
    <id>http://yoursite.com/2017/05/19/Android-——-输入手机号时自动添加空白（全情况考虑）/</id>
    <published>2017-05-19T02:46:00.000Z</published>
    <updated>2017-08-20T04:27:32.133Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>不想重复造轮子，但是查阅后发现网上大部分的博文缺少了考虑的情况。<br>要么粘贴的手机号无法格式化，要么删除时空格也占一个字符。<br>只能自己动手写了个全情况考虑的watcher</p>
</blockquote>
<p>优化：</p>
<ul>
<li>删除时，空格自动删除</li>
<li>手机号粘贴时自动格式化  </li>
</ul>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">public class FormatPhoneNumberWatcher implements TextWatcher &#123;</div><div class="line">    private Context context;</div><div class="line">    private EditText editText;</div><div class="line"></div><div class="line">    public FormatPhoneNumberWatcher(Context context, EditText editText) &#123;</div><div class="line">        this.context = context;</div><div class="line">        this.editText = editText;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</div><div class="line">        if (s == null || s.length() == 0)</div><div class="line">            return;</div><div class="line">      /**</div><div class="line">        分两种情况考虑：编辑情况和粘贴情况</div><div class="line">      */</div><div class="line">        if (count == 1 || count == 0) &#123;</div><div class="line">            inputSituation(s);</div><div class="line">        &#125; else &#123;</div><div class="line">            pasteSituation(s, start, before);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void inputSituation(CharSequence s) &#123;</div><div class="line">        String tel = editText.getText().toString().replace(&quot; &quot;, &quot;&quot;);</div><div class="line">        if (tel.length() &lt;= 3 &amp;&amp; s.toString().length() == 4) &#123;</div><div class="line">            editText.setText(tel);</div><div class="line">        &#125;</div><div class="line">        if (tel.length() &gt; 3 &amp;&amp; tel.length() &lt; 8) &#123;</div><div class="line">            editText.setText(tel.substring(0, 3) + &quot; &quot; + tel.substring(3, tel.length()));</div><div class="line">        &#125;</div><div class="line">        if (tel.length() &gt; 7) &#123;</div><div class="line">            editText.setText(tel.substring(0, 3) + &quot; &quot; + tel.substring(3, 7) + &quot; &quot; + tel.substring(7, tel.length()));</div><div class="line">        &#125;</div><div class="line">        editText.setSelection(editText.getText().toString().length());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void pasteSituation(CharSequence s, int start, int before) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">            if (!(i != 3 &amp;&amp; i != 8 &amp;&amp; s.charAt(i) == &apos; &apos;)) &#123;</div><div class="line">                sb.append(s.charAt(i));</div><div class="line">                if ((sb.length() == 4 || sb.length() == 9) &amp;&amp; sb.charAt(sb.length() - 1) != &apos; &apos;) &#123;</div><div class="line">                    sb.insert(sb.length() - 1, &apos; &apos;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (!sb.toString().equals(s.toString())) &#123;</div><div class="line">            int index = start + 1;</div><div class="line">            if (sb.charAt(start) == &apos; &apos;) &#123;</div><div class="line">                if (before == 0) &#123;</div><div class="line">                    index++;</div><div class="line">                &#125; else &#123;</div><div class="line">                    index--;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (before == 1) &#123;</div><div class="line">                    index--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            editText.setText(sb.toString());</div><div class="line">            editText.setSelection(sb.toString().length());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void afterTextChanged(Editable s) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有BUG可及时反馈，不胜感激。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不想重复造轮子，但是查阅后发现网上大部分的博文缺少了考虑的情况。&lt;br&gt;要么粘贴的手机号无法格式化，要么删除时空格也占一个字符。&lt;br&gt;只能自己动手写了个全情况考虑的watcher&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除时，空格自动删除&lt;/li&gt;
&lt;li&gt;手机号粘贴时自动格式化  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android细节问题-——-有了Intent，为什么还要有Bundle？</title>
    <link href="http://yoursite.com/2017/03/08/Android%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98-%E2%80%94%E2%80%94-%E6%9C%89%E4%BA%86Intent%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89Bundle%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/03/08/Android细节问题-——-有了Intent，为什么还要有Bundle？/</id>
    <published>2017-03-08T09:53:00.000Z</published>
    <updated>2017-08-20T04:27:18.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Intent本身就可以传递参数（Intent.putExtra(“key”, value)）为何还要用Bundle呢？</p>
</blockquote>
<h4 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h4><ol>
<li>Bundle只是一个信息的载体，内部其实就是维护了一个Map<string,object>。 </string,object></li>
<li><p>Intent负责Activity之间的交互，内部是持有一个Bundle的。</p>
<ul>
<li><p>putExtra()方法的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public Intent putExtra(String name, boolean value) &#123;</div><div class="line">        if (mExtras == null) &#123;</div><div class="line">            mExtras = new Bundle();</div><div class="line">        &#125;</div><div class="line">        mExtras.putBoolean(name, value);</div><div class="line">        return this;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>putExtras(Bundle bundle)：会将Intent的内部Bundle替换成参数bundle。</p>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p>例1：<br>从A界面跳转到B界面或者C界面<br>这样的话 我就需要写2个Intent  如果你还要涉及的传值的话 你的Intent就要写两遍添加值的方法。那么，如果我用1个Bundle，直接先存值，然后再存到Intent中 不就更简洁吗？</p>
</li>
<li><p>例2：<br>现在要把值通过Activity A经过Activity B传给Activity C。</p>
<p>如果用Intent的话，A-B先写一遍，再在B中都取出来 然后在把值塞到Intent中，再跳到C。<br>如果在A中用了 Bundle 的话，把Bundle传给B，在B中再转传到C，C就可以直接去取了。 </p>
</li>
</ul>
<h4 id="bundle使用场景"><a href="#bundle使用场景" class="headerlink" title="bundle使用场景"></a>bundle使用场景</h4><ul>
<li>在设备旋转时保存数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> // 自定义View旋转时保存数据</div><div class="line">public class CustomView extends View &#123;</div><div class="line">    @Override</div><div class="line">    protected Parcelable onSaveInstanceState() &#123;</div><div class="line">        super.onSaveInstanceState();</div><div class="line">        Bundle bundle = new Bundle();</div><div class="line">        bundle.put...</div><div class="line">        return bundle;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  // Activity旋转时保存数据</div><div class="line">public class CustomActivity extends Activity &#123;</div><div class="line">  </div><div class="line">    @Override</div><div class="line">    protected void onSaveInstanceState(Bundle savedInstanceState) &#123;</div><div class="line">        super.onSaveInstanceState(savedInstanceState);</div><div class="line">        savedInstanceState.put...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>Fragment之间传递数据<br>比如，某个Fragment中点击按钮弹出一个DialogFragment。<br>最便捷的方式就是通过Fragment.setArguments(args)传递参数。</li>
</ul>
<p>所以，Bundle是不可替代的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Intent本身就可以传递参数（Intent.putExtra(“key”, value)）为何还要用Bundle呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;两者比较&quot;&gt;&lt;a href=&quot;#两者比较&quot; class=&quot;headerlink&quot; title=&quot;两者比较&quot;&gt;&lt;/a&gt;两者比较&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Bundle只是一个信息的载体，内部其实就是维护了一个Map&lt;string,object&gt;。 &lt;/string,object&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Intent负责Activity之间的交互，内部是持有一个Bundle的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;putExtra()方法的源码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public Intent putExtra(String name, boolean value) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (mExtras == null) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            mExtras = new Bundle();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mExtras.putBoolean(name, value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return this;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;putExtras(Bundle bundle)：会将Intent的内部Bundle替换成参数bundle。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之线程和线程池</title>
    <link href="http://yoursite.com/2017/03/06/Android%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2017/03/06/Android面试之线程和线程池/</id>
    <published>2017-03-06T09:51:00.000Z</published>
    <updated>2017-08-20T04:27:59.116Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h4><ol>
<li><p>AsyncTask<br>底层用到了线程池。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。</p>
<p>AsyncTask内的Handler是一个静态的Handler对象，为了能够将执行环境切换到主线程，这就要求Handler这个对象必须在主线程中创建。由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一个进程中的AsyncTask都无法正常工作。</p>
<blockquote>
<p>注意：从Android 3.0开始，默认情况下AsyncTask是串行执行的。但在Android 3.0之前是并行执行的。  </p>
</blockquote>
</li>
<li><p>IntentService<br>底层直接使用了线程，IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，当任务执行完毕后IntentService会自动退出。</p>
<p>特殊的Service，它继承了Service并且它是抽象类。IntentService可用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致他的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务。</p>
</li>
<li><p>HandlerThread<br>底层直接使用了线程，HandlerThread是一中消息循环的线程，在它的内部可以使用Handler。  </p>
<p>HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现很简单，就在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler。</p>
</li>
</ol>
<a id="more"></a>  
<h4 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h4><ol>
<li><p>线程池的优点：</p>
<ul>
<li>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。</li>
<li>能有效控制线程池中的最大并发数，避免大量的线程之间因为互相抢占系统资源而导致的阻塞现象。</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ul>
</li>
<li><p>Android中的线程池的概念来源于Java中的Executor，Executor是一个接口，真正的线程池的实现为ThreadPoolExecutor。</p>
<p>ThreadPoolExecutor提供一系列参数来配置线程池，通过不同的参数可以创建不同的线程池，从线程池的功能特性来说，线程池主要分为4类。</p>
<p>ThreadPoolExecutor执行任务时大致遵循以下规则：</p>
<ul>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li>
<li>如果线程中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li>
<li>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已经满了， 这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li>
<li>如果步骤3的中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ul>
</li>
<li>线程池主要有4类：<ul>
<li>FixThreadPool：这是一种线程数量固定的线程池，当线程处于空闲的时候，并不会被回收，除非线程池被关闭了。</li>
<li>CachedThreadPool：这是一种线程数量不定的线程池，它只有非核心线程，并且最大线程数为Integer.MAX_VALUE。</li>
<li>ScheduledThreadPool：它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收。</li>
<li>SingleThreadExecutor：这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android中的线程形态&quot;&gt;&lt;a href=&quot;#Android中的线程形态&quot; class=&quot;headerlink&quot; title=&quot;Android中的线程形态&quot;&gt;&lt;/a&gt;Android中的线程形态&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AsyncTask&lt;br&gt;底层用到了线程池。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。&lt;/p&gt;
&lt;p&gt;AsyncTask内的Handler是一个静态的Handler对象，为了能够将执行环境切换到主线程，这就要求Handler这个对象必须在主线程中创建。由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一个进程中的AsyncTask都无法正常工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：从Android 3.0开始，默认情况下AsyncTask是串行执行的。但在Android 3.0之前是并行执行的。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IntentService&lt;br&gt;底层直接使用了线程，IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，当任务执行完毕后IntentService会自动退出。&lt;/p&gt;
&lt;p&gt;特殊的Service，它继承了Service并且它是抽象类。IntentService可用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致他的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HandlerThread&lt;br&gt;底层直接使用了线程，HandlerThread是一中消息循环的线程，在它的内部可以使用Handler。  &lt;/p&gt;
&lt;p&gt;HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现很简单，就在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试笔试分享" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android面试总结之缓存</title>
    <link href="http://yoursite.com/2017/03/02/Android%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/03/02/Android面试总结之缓存/</id>
    <published>2017-03-02T09:14:00.000Z</published>
    <updated>2017-08-20T04:27:48.991Z</updated>
    
    <content type="html"><![CDATA[<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>程序中除了图片缓存（三级缓存），还有信息缓存。当用户无法联网时，app会默认显示缓存的数据。</p>
<h5 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h5><ul>
<li><p>SQLite<br>下载完数据文件后，把文件的相关信息如url，路经，下载时间，过期时间等存放到数据库，把url作为唯一的标识。下次下载的时候根据url先从数据库中查询，如果查询到当前时间并未过期，就根据路径读取本地文件，从而实现缓存的效果。  </p>
</li>
<li><p>文件缓存<br>使用File.lastModified()方法得到文件的最后修改时间，与当前时间判断是否过期，从而实现缓存效果。数据格式为JSON。  </p>
</li>
</ul>
<a id="more"></a>
<blockquote>
<p>缓存方式两点说明</p>
<ol>
<li>不同类型的文件的缓存时间不一样。<br>笼统的说，不变文件的缓存时间是永久，变化文件的缓存时间是最大忍受不变时间。说白点，图片文件内容是不变的，一般存在SD卡上直到被清理，我们是可以永远读取缓存的。配置文件内容是可能更新的，需要设置一个可接受的缓存时间。</li>
<li>不同环境下的缓存时间标准不一样。<br>无网络环境下，我们只能读取缓存文件，为了应用有东西显示，没有什么过期之说了。<br>WiFi网络环境下，缓存时间可以设置短一点，一是网速较快，而是流量不要钱。<br>3G流量环境下，缓存时间可以设置长一点，节省流量，而且用户体验也更好。    </li>
</ol>
</blockquote>
<h5 id="缓存时间"><a href="#缓存时间" class="headerlink" title="缓存时间"></a>缓存时间</h5><p>app中多个页面的缓存时间是不一样的，对实时性要求高的页面缓存时间较短。而http消息头中包含有缓存时间，android端无需自己记录/规定缓存时间，读取即可。</p>
<h6 id="http协议对缓存的支持"><a href="#http协议对缓存的支持" class="headerlink" title="http协议对缓存的支持"></a>http协议对缓存的支持</h6><p>Expires &amp; Cache-Control</p>
<p>Expires响应首部给出了响应失效的绝对时间,这样客户端就可以缓存一份副本,在这个时间到期之前,<br>不用去询问服务器它是否有效了。http1.0引入。 例:Expires: Thu, 03 Oct 1997 17:15:00 GMT</p>
<p>Cache-Control首部用于传输对象的缓存信息。http1.1引入。它的值是一个缓存指令，给出了与某个对象可缓存性有关的特有指令。这个首部可以出现在请求或者响应头中。例如:Cache-Control: no-cache<br>CacheControl有两个字段表达响应的过期时间：max-age和max-stale </p>
<ul>
<li>前者表示：max-age秒内，网页再有请求，你不要来我服务端，直接取你本地缓存的结果好了 </li>
<li>后者表示：max-stale秒内的请求，你可以使用本地缓存的，但还是要来我服务端问问，到底行不行，当然，这里要带上Last Modified等信息 ，如果服务端返回了304，那说明你本地缓存继续用吧，我不给你响应体200的话，自然就带上了响应体。 </li>
</ul>
<p>Expires和Cache-Control作用一致，都是指当前资源的有效期，控制是直接从缓存获取数据还是重新发送请求到服务器取数据。</p>
<h5 id="缓存算法"><a href="#缓存算法" class="headerlink" title="缓存算法"></a>缓存算法</h5><ol>
<li><p>LRU - 最近最少使用（最后访问时间）<br>替换掉最近被请求最少的文档。这一传统策略在实际中应用最广。在CPU缓存淘汰和虚拟内存系统中效果较好。  </p>
</li>
<li><p>LRU-K<br>LRU-K中的K代表最近使用的次数，也可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。<br>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。如下：<br><img src="http://upload-images.jianshu.io/upload_images/3167794-efc0f5b183b53a39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>LFU - 最不经常使用（访问次数）<br>替换掉访问次数最少的。这一策略意图保留最常用的、最流行的对象，替换掉很少使用的那些。<br>LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。<br>如下：<br><img src="http://upload-images.jianshu.io/upload_images/3167794-607be40d1b32a620?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li>SIZE（缓存大小）<br>替换size最大的对象。这一策略通过淘汰一个大对象而不是多个小对象来提高命中率。不过，可能有些进入缓存的小对象永远不会再被访问。SIZE策略没有提供淘汰这类对象的机制，会导致“缓存污染”（大量偶发性的数据访问让内存中存放大量冷数据,也即是缓存污染）。</li>
<li>以上算法结合使用….</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h5&gt;&lt;p&gt;程序中除了图片缓存（三级缓存），还有信息缓存。当用户无法联网时，app会默认显示缓存的数据。&lt;/p&gt;
&lt;h5 id=&quot;缓存方式&quot;&gt;&lt;a href=&quot;#缓存方式&quot; class=&quot;headerlink&quot; title=&quot;缓存方式&quot;&gt;&lt;/a&gt;缓存方式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SQLite&lt;br&gt;下载完数据文件后，把文件的相关信息如url，路经，下载时间，过期时间等存放到数据库，把url作为唯一的标识。下次下载的时候根据url先从数据库中查询，如果查询到当前时间并未过期，就根据路径读取本地文件，从而实现缓存的效果。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件缓存&lt;br&gt;使用File.lastModified()方法得到文件的最后修改时间，与当前时间判断是否过期，从而实现缓存效果。数据格式为JSON。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试笔试分享" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android面试总结之接口维护（版本控制）</title>
    <link href="http://yoursite.com/2017/03/02/Android%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8E%A5%E5%8F%A3%E7%BB%B4%E6%8A%A4%EF%BC%88%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/02/Android面试总结之接口维护（版本控制）/</id>
    <published>2017-03-02T08:32:00.000Z</published>
    <updated>2017-08-20T04:27:39.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一般情况下，APP中会有大量的接口，再加上版本的变化，接口的升级，可能会衍生出很多个稍有差异的接口，这个时候接口如果维护的不好，后边会乱为一锅粥，客户端不同版本使用不同的接口名（xxxv1,xxxv2,xxxv3…..）。<br>有的公司每次发布完APP，就强制用户更新。不推荐这样，用户体验太差。<br>就算是强制更新，在苹果审核期间，新的APP接口和老的接口也必须能同时使用。  </p>
</blockquote>
<a id="more"></a>
<h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><h5 id="一、-客户端做兼容，接口不用做兼容"><a href="#一、-客户端做兼容，接口不用做兼容" class="headerlink" title="一、 客户端做兼容，接口不用做兼容"></a>一、 客户端做兼容，接口不用做兼容</h5><ol>
<li><p><strong>APP强制更新（不建议）</strong><br>接口URL：api.xxx.com/v1.0/xxxx.java<br>接口的URL中加入版本号，如上：v1.0。<br>采用灰度服务器 部署正在审核中的 接口版本（如：v1.1）。等审核通过后，将老版本的APP设置强制更新，然后把线上服务器重新部署上最新的代码，再去掉灰度服务器。这样APP接口全部访问正式的线上服务器。</p>
</li>
<li><p><strong>热更新</strong><br>紧急的小需求可以用热更新，大的需求建议还是用原生的代码，因为你用热更新修改完（用JS或Lua），最后还要在原生代码里修改。<br>网游用热更新的比较多，因为网游的APP太大，不可能加个小关卡 就要求用户重新下载，并且游戏更新比企业级APP更频繁，用热更新可以不断新加关卡、场景、活动推广。  </p>
</li>
<li><strong>React Native 和Weex</strong><br>没接触过 可以自己了解</li>
</ol>
<h5 id="二、-服务端做版本兼容"><a href="#二、-服务端做版本兼容" class="headerlink" title="二、 服务端做版本兼容"></a>二、 服务端做版本兼容</h5><ol>
<li><strong>App 请求服务器接口的时候携带接口版本字段</strong><br>服务器根据接口版本调用相应的方法，每个接口逻辑里 加if 判断（不推荐）<br>接口URL：api.xxx.com/api?version=v1&amp;..<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (version == ‘1.5.0’) &#123;</div><div class="line">　　//do_something</div><div class="line">&#125; else if (version ==‘1.4.0&apos;) &#123;</div><div class="line">　　//do_something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>不同版本的逻辑都在一个方法里，在于容易造成代码混乱，不利于维护。</p>
<ol>
<li><p><strong>一个版本一个文件</strong><br>相当于每个接口版本都是一个独立的项目。放到服务器的独立文件夹里。使用什么版本接口写到客户端配置里面或者通过一个接口获取就行。<br>例：<br>1.0版本：<a href="http://x.x.x.x:xx/xxapi/v1.0/xxx" target="_blank" rel="external">http://x.x.x.x:xx/xxapi/v1.0/xxx</a><br>1.2版本：<a href="http://x.x.x.x:xx/xxapi/v1.2/xxx" target="_blank" rel="external">http://x.x.x.x:xx/xxapi/v1.2/xxx</a><br>文件夹位置：Controller/V1.0/<br>—————–/xxxx.php<br>文件夹位置：Controller/V1.2/<br>—————–/xxxx.php<br>优点：版本逻辑分开维护。看url就能知道哪个版本。删除多余版本 不用修改代码。<br>缺点：同个接口不同版本 文件是重复的。并且 如果有个接口前几版就有问题，一直遗留到现在，就需要改好几套一样的代码。</p>
</li>
<li><p><strong>token代替版本号</strong><br><img src="http://upload-images.jianshu.io/upload_images/3167794-202e7e6133579549.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/3167794-3e0112e31dc00261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>几个要点：<br>a. 客户端发送请求时token是固定不变的，使用token间接的标记请求的接口版本。<br>b. server保存了token和对应接口的版本号，请求来了之后会先根据这个寻找对应的接口版本。<br>c. 每个目录对应一个版本，根据请求的接口读取对应目录下的接口配置文件，找到最终要执行的具体接口。<br>例如：<a href="http://xxxx.xxxx.com/module/controller/list?token=6918b5e0567c7d47314c10ed413e3f95" target="_blank" rel="external">http://xxxx.xxxx.com/module/controller/list?token=6918b5e0567c7d47314c10ed413e3f95</a> 这个请求最终会打到listv2这个接口。<br>d. 这样就可以在服务端灵活的配置接口了，客户端只要每次请求的时候带上默认的token参数，就可以得到自己想要的了，完全不需要关心版本的问题。</p>
</li>
<li><p><strong>继承的方式</strong><br>ControllerV1<br>ControllerV2 extends ControllerV1<br>采用继承的方式，既可以利用之前的接口代码，又可以采用override的方式修改部分接口的实现。<br>缺点：如果上个版本（也就是父类）修改了代码，就会影响后面的所有版本。  </p>
</li>
<li><p><strong>不同版本使用不同的域名/不同服务器</strong><br>不同版本不同分支，部署在不同的服务器上。如果某个版本用不到了，直接干掉服务就好了。<br>例如我现在的API要从1.x升到不兼容的2.0版本了，那就给当前的发布分支打个Tag。等哪天1.x版的API需要fix bug，就能很简单地从这个Tag切一个1.x的分支出来fix bug后进行测试发布，而且这个分支不会合并到任何分支，所以不会影响其他版本。<br>优点：部署的过程不会影响其他版本api的使用，并且可以减轻单台服务器的负担。<br>缺点：如果2.0也有同样bug的话，也要在2.0分支上改一遍。如果版本很多的话，工作量大。所以呢，一般不会同时发布两个以上的版本。另外，如果要兼容过多的版本，服务器也需要够多才行。同时，因为老版本的人用的少，也就是有的服务器访问量很少，有的服务器访问量很多。不能真正的负载均衡，浪费了服务器资源。</p>
</li>
</ol>
<p>最后做下版本使用监控。当观察到所有用户都使用新版本的客户端的时候，并保持一段时间的时候。放弃对老版本的维护，继而下掉老版本的资源。</p>
<hr>
<h4 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h4><p>开启APP-&gt;请求初始化接口-&gt;检测是否需要更新? 否-&gt;首页Or 是-&gt;更新  </p>
<p>在初始化接口的时候，需要客户端发送几个数据：</p>
<pre><code>app_id            客户端id，比如： 1，安卓手机 2，iphone手机

version_id        大版本号id

version_mini      小版本号id

did               用户客户端信息（客户端工程师会获取这个数据）

encrypt_did       did加密后的字符串（did 加上 APP设备数据表中的key，然后md5）
</code></pre><p>数据库方面：需要两张表。一张是记录升级版本信息的表，记录着设备的id，版本号信息，下载地址等。另外一张表是记录的设备的信息，比如安卓手机的信息，版本信息表中有一个外键app_id，关联的就是设备信息表的主键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//设备信息表，记录了各种客户端的信息</div><div class="line">  CREATE TABLE IF NOT EXISTS `app_table` (</div><div class="line">    `app_id` smallint(6) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</div><div class="line">    `name` varchar(10) NOT NULL COMMENT &apos;设备名称&apos;,</div><div class="line">    `is_encryption` tinyint(1) NOT NULL COMMENT &apos;是否加密&apos;,</div><div class="line">    `key` varchar(10) NOT NULL COMMENT &apos;加密key&apos;,</div><div class="line">    `image_size` text NOT NULL COMMENT &apos;按照json来存储&apos;,</div><div class="line">    `create_time` int(11) NOT NULL COMMENT &apos;添加时间&apos;,</div><div class="line">    `update_time` int(11) NOT NULL COMMENT &apos;修改时间&apos;,</div><div class="line">    `status` tinyint(1) NOT NULL COMMENT &apos;状态 1正常0删除&apos;,</div><div class="line">    PRIMARY KEY (`app_id`)</div><div class="line">  ) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT=&apos;app设备表&apos; AUTO_INCREMENT=2 ;</div><div class="line">  </div><div class="line">  //版本升级信息表，存放了各种版本的信息</div><div class="line">  CREATE TABLE IF NOT EXISTS `version_upgrade` (</div><div class="line">    `id` smallint(4) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</div><div class="line">    `app_id` smallint(4) NOT NULL COMMENT &apos;客户端设备id&apos;,</div><div class="line">    `version_id` smallint(4) NOT NULL COMMENT &apos;大版本号id&apos;,</div><div class="line">    `version_mini` mediumint(8) NOT NULL COMMENT &apos;小版本号&apos;,</div><div class="line">    `version_code` varchar(10) NOT NULL COMMENT &apos;版本标识1.2&apos;,</div><div class="line">    `type` tinyint(4) NOT NULL COMMENT &apos;是否升级1是0否&apos;,</div><div class="line">    `apk_url` varchar(255) NOT NULL COMMENT &apos;下载链接地址&apos;,</div><div class="line">    `upgrade_point` varchar(255) NOT NULL COMMENT &apos;升级提示&apos;,</div><div class="line">    `status` tinyint(4) NOT NULL,</div><div class="line">    `create_time` int(11) NOT NULL COMMENT &apos;添加时间&apos;,</div><div class="line">    `update_time` int(11) NOT NULL COMMENT &apos;修改时间&apos;,</div><div class="line">    PRIMARY KEY (`id`)</div><div class="line">  ) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT=&apos;软件升级信息表&apos; AUTO_INCREMENT=2 ;</div></pre></td></tr></table></figure></p>
<p>通过app的版本信息与服务器信息对比，看是否要进行版本升级</p>
<blockquote>
<p>参考文章<br><a href="http://www.cnblogs.com/dahe007/p/6255401.html" target="_blank" rel="external">http://www.cnblogs.com/dahe007/p/6255401.html</a><br><a href="https://my.oschina.net/woshixiaomayi/blog/519783" target="_blank" rel="external">https://my.oschina.net/woshixiaomayi/blog/519783</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一般情况下，APP中会有大量的接口，再加上版本的变化，接口的升级，可能会衍生出很多个稍有差异的接口，这个时候接口如果维护的不好，后边会乱为一锅粥，客户端不同版本使用不同的接口名（xxxv1,xxxv2,xxxv3…..）。&lt;br&gt;有的公司每次发布完APP，就强制用户更新。不推荐这样，用户体验太差。&lt;br&gt;就算是强制更新，在苹果审核期间，新的APP接口和老的接口也必须能同时使用。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试笔试分享" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-项目坑总结</title>
    <link href="http://yoursite.com/2017/02/07/Android-%E2%80%94%E2%80%94-%E9%A1%B9%E7%9B%AE%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/02/07/Android-——-项目坑总结/</id>
    <published>2017-02-07T03:32:58.000Z</published>
    <updated>2017-08-20T04:27:08.127Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><ul>
<li>需求：定时任务 </li>
<li>处理：不能在service中循环调用 AsyncTask执行长时间任务，会造成堵塞。要改用Thread或CachedThreadPool线程池。</li>
<li>原因：<br>在官方文档中指出， <code>AsyncTasks should ideally be used for short operations</code>， 就是说AsyncTask执行的任务应该是一些短时间内可以完成的任务， 因为在Android3.0之后， 默认情况下， 同一时间只能有一个AsyncTask在运行， 也就是说所有的task都是串行运行的。所以如果某个task执行时间很长， 会导致后面的task长时间等待， 当然也可以通过调<code>executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</code>， 可以同时运行5个Task。<br>如果最大同时运行5个Task不能满足要求，就要自己使用线程池了。  </li>
</ul>
</li>
</ol>
<a id="more"></a>
<ol>
<li><ul>
<li>需求：加载大图防止内存溢出问题</li>
<li>问题：decodeStream解析图片一直为null</li>
<li>原因：Android 的一个bug，input 流不能用两次 可以把流转换成数组，然后再用<a href="http://blog.csdn.net/andypan1314/article/details/6670320" target="_blank" rel="external">该方法</a></li>
</ul>
</li>
<li><ul>
<li>需求：科大讯飞语音转文字</li>
<li>问题：<br>1.组件加载失败<br>解决：so包缺失<br>2.用户校验失败<br>解决：<code>libmsc.so</code>一定要用自己id下载的SDK，因为SDK和appid是绑定的，拷贝旧项目的so是不行的！</li>
</ul>
</li>
<li><ul>
<li>问题：<code>mImageView.getDrawingCache()</code>取值为空</li>
<li>解决：<br><code>setImageBitmap()/setImageDrawable</code>设置图片的方式才可以取到缓存<br><code>setImageResource</code>方法设置图片则缓存取值为null。<br>官方建议用<code>setImageDrawable</code>代替<code>setImageBitmap</code>，这样可以减少new的对象。实际上<code>setImageBitmap</code>方法就是把Bitmap对象封装成Drawable对象,然后调用setImageDrawable</li>
</ul>
</li>
<li><ul>
<li>需求：文件传输</li>
<li>问题：新文件发过来后在系统媒体库中找不到新文件记录，必须得重启才能更新</li>
<li>解决：自己手动把新文件信息插入媒体库</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;需求：定时任务 &lt;/li&gt;
&lt;li&gt;处理：不能在service中循环调用 AsyncTask执行长时间任务，会造成堵塞。要改用Thread或CachedThreadPool线程池。&lt;/li&gt;
&lt;li&gt;原因：&lt;br&gt;在官方文档中指出， &lt;code&gt;AsyncTasks should ideally be used for short operations&lt;/code&gt;， 就是说AsyncTask执行的任务应该是一些短时间内可以完成的任务， 因为在Android3.0之后， 默认情况下， 同一时间只能有一个AsyncTask在运行， 也就是说所有的task都是串行运行的。所以如果某个task执行时间很长， 会导致后面的task长时间等待， 当然也可以通过调&lt;code&gt;executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)&lt;/code&gt;， 可以同时运行5个Task。&lt;br&gt;如果最大同时运行5个Task不能满足要求，就要自己使用线程池了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
