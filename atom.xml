<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FeelsChaotic</title>
  <subtitle>程序媛、乐器狂、工匠、重度偏执者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-19T15:17:40.555Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>feelschaotic</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「校招季」怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？</title>
    <link href="http://yoursite.com/2017/09/17/%E3%80%8C%E6%A0%A1%E6%8B%9B%E5%AD%A3%E3%80%8D%E6%80%8E%E6%A0%B7%E5%81%9A%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%20And%20%E9%9D%A2%E8%AF%95%E5%AE%98%E5%88%B0%E5%BA%95%E5%9C%A8%E8%80%83%E5%AF%9F%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/09/17/「校招季」怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？/</id>
    <published>2017-09-17T12:25:00.000Z</published>
    <updated>2017-09-19T15:17:40.555Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3167794-8809ace0ffc907bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="为什么要重视项目介绍？"><a href="#为什么要重视项目介绍？" class="headerlink" title="为什么要重视项目介绍？"></a>为什么要重视项目介绍？</h4><p>你可以尝试着讲一遍你的项目经历。我第一次讲的时候就挺乱的，卡壳、专业词汇匮乏、逻辑混乱、用词不当、没有介绍到项目重点……<br><a id="more"></a></p>
<p>项目经验面试在面试中占很大比重，面试官通过一些专业性的技术问题来了解你的技术水平，问题从哪来？要么来源于结构化面试题库（每个面试者的问题都一样，多出现在校招一面），要么，就是从你的简历中项目经验来。所以对项目整体而深入复习的重要性不言而喻。</p>
<p>介绍项目时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？这些都是值得你好好思考的。</p>
<h4 id="项目介绍思路"><a href="#项目介绍思路" class="headerlink" title="项目介绍思路"></a>项目介绍思路</h4><p>这部分技巧对简历上的项目介绍也是通用的。</p>
<ol>
<li><p>首先用一句话介绍这个项目做了什么，打个比方，我使用XX 框架实现了一个 XX</p>
</li>
<li><p>主要功能  </p>
<p> 挑亮点和创新点讲，细碎的功能点一句带过。 </p>
</li>
<li><p>然后讲基本的实现：主要运用到的技术点有XXX。  </p>
<p> （这里面试官从你介绍的技术点切入考察，所以要好好回顾复习项目中运用到的技术点细节。）</p>
</li>
<li><p>架构</p>
<p>（面试官还会问一问为什么你选了这样的架构／方法来实现。）</p>
</li>
<li><p>我在项目中的角色</p>
<p> 主要介绍项目中的职责和作用，是多面手 or 组长 or 技术 。这点主要凸显你的工作量和贡献率。</p>
</li>
</ol>
<blockquote>
<p>注：可以在简历上附上项目github地址，上传重点功能的演示 gif ，让面试官可以很直观地评估你的项目规模和难度。</p>
</blockquote>
<h4 id="面试官会考察些什么？"><a href="#面试官会考察些什么？" class="headerlink" title="面试官会考察些什么？"></a>面试官会考察些什么？</h4><p>知己知彼，摸清面试官心理，你才能有针对性去准备。</p>
<h5 id="1-能力、技术"><a href="#1-能力、技术" class="headerlink" title="1. 能力、技术"></a>1. 能力、技术</h5><ul>
<li><p>考察深度：深入了解哪个技术？</p>
<p>整个项目中用到了哪些开源框架？他们的实现思路是什么？你看过他们的源码吗？你不仅仅是要会用开源库和第三方SDK，还需要知道实现原理和技术细节。不然一个都是第三方堆砌起来的App，问这个说不了解，用的第三方框架，问哪个说不了解，用的SDK，你还要面试官问什么？[摊手]</p>
</li>
<li><p>考察广度</p>
<p>在进行技术选型的时候，你有过什么考虑，做过多少调查。详细地了解不同的工具/框架 思想的对比。最后是什么原因，你选定了这个技术。记住一句话：技术没有优劣，只有合不合适。功能点的实现方式有很多，往往选择的是最适合的。</p>
<p>同时面试官可能会考察你是否关注产品数据，是否关注合理的工作流程，是否关注前后台交互时的相关知识和流程，是否关注测试自动化、持续集成等其他方面。</p>
</li>
</ul>
<h5 id="2-潜力"><a href="#2-潜力" class="headerlink" title="2. 潜力"></a>2. 潜力</h5><ul>
<li><p>做项目中怎么解决问题？</p>
<p>主要展示自己解决问题的思路。  </p>
</li>
<li><p>举一反三的能力</p>
<p>面试官会提出和项目技术类似的点，考察你是否能将新知识点联系到已学的技术，然后尝试解决它。</p>
</li>
<li><p>优化项目哪些部分</p>
<p>面试官意在考察你的思考力和动手能力，开源库多多少少都会有坑，你是否在应用中排查出坑并且能埋坑。</p>
</li>
<li><p>如何快速学习项目需要的技术点</p>
<p>首先，找资料顺序是：官网文档-&gt;权威书籍-&gt;google-&gt;StackOverflow-&gt;博客。其次，新技术的学习非常考验基础。打个比方，没学过RxJava，但是如果你知道设计模式的观察者模式，理解起来就很快。</p>
</li>
</ul>
<h5 id="3-细节"><a href="#3-细节" class="headerlink" title="3. 细节"></a>3. 细节</h5><ul>
<li><p>sdk的细节了解在哪里</p>
<p>自己造轮子确实费时间，但是你又是否知道SDK做了哪些优化？</p>
</li>
<li><p>自定义控件优化</p>
</li>
<li><p>作品对比</p>
<p>自己的项目有没有和市面上的竞品比较过，客观地评价下从别人的作品中学到了什么，基于此你有没有改进自己的作品？</p>
</li>
<li><p>算法</p>
<p>主要是一些坑和解决思路、解决的灵感来源等，在项目中肯定会涉及到数据结构，比如缓存最近100条点击记录，超出100条则移除最早缓存的记录，自己实现。可能你会想到用队列或堆实现，那可以去看看缓存算法Lru算法的原理，用的什么容器，为什么这么设计？</p>
</li>
</ul>
<h5 id="4-主动性"><a href="#4-主动性" class="headerlink" title="4. 主动性"></a>4. 主动性</h5><ul>
<li>是否做过知识总结、知识沉淀？（这就是平时注重博客积累的好处了）</li>
<li>是否实践过知识分享？</li>
<li>是否主动给项目提出过意见或建议？</li>
</ul>
<h5 id="5-沟通能力"><a href="#5-沟通能力" class="headerlink" title="5. 沟通能力"></a>5. 沟通能力</h5><p>在面试的过程中，<strong>悄声无息进行的还有另一项考察 —— 沟通能力</strong>。想想自己面谈时是否能让面试官感觉舒服，是否能清晰表达自己的要点，是否能清晰表达自己未来的个人发展规划。可以尝试模拟面试录下音，看是否有过多的语气词表达出的不自信。</p>
<h5 id="6-例子"><a href="#6-例子" class="headerlink" title="6. 例子"></a>6. 例子</h5><p>说了这么多，搞个直观的例子谈谈。</p>
<p><strong>问：</strong></p>
<p>项目中推送是怎么实现的？</p>
<p><strong>答：</strong></p>
<p>刚开始做推送的时候，对目前主流的推送方案大致了解了一下。发现推送实现不止一种。  </p>
<p><strong>（展示技术选型和方案，简单谈下就ok）</strong>  </p>
<p>（1）GCM服务  </p>
<p>优点：Google提供的服务、原生、简单，无需实现和部署服务端。  </p>
<p>缺点：该服务在国内不够稳定、需要用户绑定Google帐号。  </p>
<p>（2）XMPP：  </p>
<p>优点：开放性，标准性，可扩展，跨平台，且已有开源项目。  </p>
<p>缺点：数据冗余（基于XML），不支持二进制数据，协议虽然完整扩展性虽然好，它耗费网络流量很大，跑起来比MQTT慢很多；有高达70%的流量是耗费在XMPP本身的标签和编解码上面。  </p>
<p>（3）MQTT  </p>
<p>优点：协议简洁、小巧、可扩展性强、省流量、省电。  </p>
<p>缺点：不够成熟、实现较复杂、服务端组件rsmb不开源，部署硬件成本较高。  </p>
<p>（4）HTTP轮循<br>优点：实现简单、可控性强，部署硬件成本低。<br>缺点：实时性差。  </p>
<p><strong>（体现技术细节）</strong>  </p>
<p>所以后续选型，我选择了 XMPP + MINA + AndroidPN 来实现推送。  </p>
<p><strong>（体现项目优化改进之处，体现自己的思考和能力，对开源项目进行改造）</strong></p>
<p>但是 AndroidPN 开源项目也存在一些不足之处：  </p>
<ol>
<li><p>如果将消息从服务器上推送出去，就不再管理了。</p>
<p> 我的做法是：客户端收到推送后给服务端一个反馈，如果服务端在一定时间内没有收到反馈，则重发。</p>
</li>
<li><p>androidpn服务器收到消息后如何知道要发给哪个用户？</p>
<p> 所以我加了个tag维度来做用户分组</p>
</li>
<li><p>一旦服务器重启了，客户端似乎不会自动重连，需要用户自己中断后台Service再重启应用。</p>
<p> 完善的方法是加上心跳机制和断线重连</p>
</li>
<li><p>AndroidPN服务器不保存消息。就是说它一有消息就会发出去，即使客户端根本不在线，它也不会重发。  </p>
<p>解决方案是让服务端保持对客户端状态的监控</p>
</li>
</ol>
<p><strong>再问：</strong></p>
<p>怎么不用现有的极光推送？</p>
<p><strong>答：</strong></p>
<p>极光推送初始的版本文档不全，接入麻烦，<strong>同时我对推送的原理很感兴趣，所以想自己实践下。</strong></p>
<h4 id="问题示例"><a href="#问题示例" class="headerlink" title="问题示例"></a>问题示例</h4><p>最后，是面试官针对项目面试可能提出的问题汇总。</p>
<ul>
<li><p>你参与的项目是独立完成的还是团队协作完成的，在团队里是什么角色？是负责人还是参与者？</p>
</li>
<li><p>项目执行过程中的难题你是怎么处理的？</p>
</li>
<li><p>问一些专业性的技术问题来了解你的水平。</p>
</li>
<li><p>如果是没有明确结果的项目，你从项目里学到了什么，有什么经验教训？</p>
<p>  看你的项目经验，还有思维逻辑性，对项目整体的认识，包括技术的选型和架构的设计等等。</p>
</li>
<li><p>项目技术点具体的使用场景，比如多线程的控制、性能优化、数据库设计、加密混淆等等。</p>
</li>
<li><p>挑一个你最熟悉的项目讲讲吧。</p>
</li>
<li><p>讲解你是怎么从0到1对项目进行开发和改造的。</p>
<p>题目确立 -&gt; 产品需求开发 -&gt;  概要设计 -&gt; 详细设计 -&gt; 测试用例 -&gt; 编码 -&gt; 测试 -&gt; 优化 -&gt; 宣传视频海报的制作。</p>
</li>
</ul>
<h4 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h4><p>当然，存在有的面试官倾向于问一些开放性的问题。主要看重你是如何解决问题的，看你的思维方式是怎么发散的。</p>
<p>比如面试官问我，你为什么觉得你做的产品就比别人好？你为什么要对你们的产品进行性能优化，主要瓶颈在哪里？你是通过什么方式进行优化？你优化的点是怎么考虑的？你在使用第三方服务是处于什么目的，你对它的评价是什么，它们给你带来的好处是什么？让你去思考如何更好的为开发者提供服务，你觉得还有什么东西是开发者需要的？你对开发工具类产品感兴趣吗？</p>
<p>可以从这些问题看出，面试官并不仅仅看重你的技术能力，还有你对产品的认识。面试官想找的人不仅仅要在技术上有亮点，还有其他方面能吸引到他们。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>最重要的一点：<strong>不知道的技术点不要不懂装懂</strong>。很多时候我们都会遇到一个情况，就是面试官的问题我不会，这时候大多数情况下不要马上说我不会，也不要糊弄回答，要懂得牵引，转移话题往类似的你擅长的技术点方向去，不然当你抱着侥幸心理随便回答出问题后，面试官会一直沿着往下深挖，挖到挖不出来为止，这就很尴尬了。</p>
<blockquote>
<p>受限于个人水平，如有错误之处，敬请谅解。<br>筹划面试系列很久，已经草稿6、7篇了，一直拖延症没有整理。这次参加掘金的征文比赛，就相当于催更了，本文是系列一，之后会陆陆续续补全面试其他系列。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-8809ace0ffc907bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么要重视项目介绍？&quot;&gt;&lt;a href=&quot;#为什么要重视项目介绍？&quot; class=&quot;headerlink&quot; title=&quot;为什么要重视项目介绍？&quot;&gt;&lt;/a&gt;为什么要重视项目介绍？&lt;/h4&gt;&lt;p&gt;你可以尝试着讲一遍你的项目经历。我第一次讲的时候就挺乱的，卡壳、专业词汇匮乏、逻辑混乱、用词不当、没有介绍到项目重点……&lt;br&gt;
    
    </summary>
    
    
      <category term="校招" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="项目介绍" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-网易易盾验证码异常-libEGL--validate_display-99-error-3008-(EGL_BAD_DISPLAY)</title>
    <link href="http://yoursite.com/2017/07/24/Android-%E2%80%94%E2%80%94-%E7%BD%91%E6%98%93%E6%98%93%E7%9B%BE%E9%AA%8C%E8%AF%81%E7%A0%81%E5%BC%82%E5%B8%B8-libEGL--validate_display-99-error-3008-(EGL_BAD_D/"/>
    <id>http://yoursite.com/2017/07/24/Android-——-网易易盾验证码异常-libEGL--validate_display-99-error-3008-(EGL_BAD_D/</id>
    <published>2017-07-24T08:00:00.000Z</published>
    <updated>2017-08-20T04:27:26.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前提：WebView在 Android 5.1 测试机上正常显示，在 Android 7.0 上无法显示，一直 loading 。（注：url 为 htts 协议）</p>
</blockquote>
<p>考虑到验证码的 Webview 和 Listener 都是自己重写，可能漏掉了什么，果然在细细翻看官方源码的时候，发现了 WebViewClient 多复写了 onReceivedSslError 监听，初步判断是遇到证书问题。</p>
<p>解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mWebView.setWebViewClient(new WebViewClient() &#123;</div><div class="line">           @Override</div><div class="line">           public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;</div><div class="line">               handler.proceed(); // Ignore SSL certificate errors</div><div class="line">           // fix for: SSL Error. Failed to validate the certificate chain </div><div class="line">           //不要调用super.xxxx</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>原因：</p>
<p>在 Android 中，WebView 可以用来加载 http 和 https 网页到本地应用的控件。在默认情况下，通过 <code>loadUrl(String url)</code> 方法，可以顺利  <code>loadUrl(&quot;http://www.baidu.com&quot;)</code>之类的页面。但是，当 load 通过 ssl 加密的 https 页面，且这个网站的安全证书在 Android 无法得到认证时，WebView就会变成一个空白页，而并不会像自带的浏览器一样弹出提示。因此，我们必须针对这种情况进行处理。</p>
<p>拓展：</p>
<p>不过如果在 <code>onReceivedSslError</code> 方法中实现调用了 <code>handler.proceed()</code>来忽略该证书错误，则会受到中间人攻击的威胁，可能导致隐私泄露。可以采用默认的处理方法<code>handler.cancel()</code>，停止加载问题页面。<br>（鉴于项目需求，所以仍然采用<code>handler.proceed();</code>）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前提：WebView在 Android 5.1 测试机上正常显示，在 Android 7.0 上无法显示，一直 loading 。（注：url 为 htts 协议）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑到验证码的 Webview 和 Listener 都是自己重写，可能漏掉了什么，果然在细细翻看官方源码的时候，发现了 WebViewClient 多复写了 onReceivedSslError 监听，初步判断是遇到证书问题。&lt;/p&gt;
&lt;p&gt;解决：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mWebView.setWebViewClient(new WebViewClient() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           @Override&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;               handler.proceed(); // Ignore SSL certificate errors&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           // fix for: SSL Error. Failed to validate the certificate chain &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           //不要调用super.xxxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-打包INSTALL_PARSE_FAILED_NO_CERTIFICATES异常</title>
    <link href="http://yoursite.com/2017/07/20/Android-%E2%80%94%E2%80%94-%E6%89%93%E5%8C%85INSTALL_PARSE_FAILED_NO_CERTIFICATES%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/07/20/Android-——-打包INSTALL_PARSE_FAILED_NO_CERTIFICATES异常/</id>
    <published>2017-07-20T03:43:00.000Z</published>
    <updated>2017-08-20T04:28:14.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前提：明明已经签名，在安装时却提示 <code>INSTALL_PARSE_FAILED_NO_CERTIFICATES</code> 异常</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-6b4e49bade94fed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装失败情形"></p>
<p>排查：</p>
<p>安装的测试机系统为 5.0，只采用了 v2 签名</p>
<a id="more"></a>
<p>解决：</p>
<p>改为安装在 7.0 手机或者选择 v1 + v2 签名。</p>
<p>原因：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-ae621be14c406309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在 Android 7.0 以上版本的设备上，APK 可以根据Full Apk Signature（v2 方案） 或者 JAR-signed（ v1方案）进行验证； 而对于7.0以下版本的设备其会忽略 v2 版本的签名，<strong>只验证 v1 签名</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-74f969787e7d154a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证的流程.png"></p>
<p>结论：</p>
<ul>
<li>一定可行的方案： 只使用 v1 方案</li>
<li>不一定可行的方案：同时使用 v1 和 v2 方案</li>
<li>对 7.0 以下<strong>一定不行</strong>的方案：只使用 v2 方案</li>
</ul>
<p>如果要支持 Android 7.0 以下版本，那么尽量同时选择两种签名方式，但是一旦遇到签名问题，可以只使用 v1 签名方案</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前提：明明已经签名，在安装时却提示 &lt;code&gt;INSTALL_PARSE_FAILED_NO_CERTIFICATES&lt;/code&gt; 异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-6b4e49bade94fed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装失败情形&quot;&gt;&lt;/p&gt;
&lt;p&gt;排查：&lt;/p&gt;
&lt;p&gt;安装的测试机系统为 5.0，只采用了 v2 签名&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 和Java的型变</title>
    <link href="http://yoursite.com/2017/07/13/Kotlin-%E5%92%8CJava%E7%9A%84%E5%9E%8B%E5%8F%98/"/>
    <id>http://yoursite.com/2017/07/13/Kotlin-和Java的型变/</id>
    <published>2017-07-13T07:25:00.000Z</published>
    <updated>2017-09-03T09:00:10.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java-的型变"><a href="#1-Java-的型变" class="headerlink" title="1. Java 的型变"></a>1. Java 的型变</h3><p>如果 Parent 是 Child 的父类，那么 <code>List&lt;Parent&gt;</code> 和<code>List&lt;Child&gt;</code> 的关系是什么呢？对于 Java 来说，没有关系。<br><a id="more"></a><br>也就是说下面的代码是无法编译的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Number&gt; numbers = new ArrayList&lt;Integer&gt;(); //ERROR!</div></pre></td></tr></table></figure>
<p>不过 numbers 中可以添加 Number 类型的对象，所以我添加个 Integer 可以不呢？可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers.add(1);</div></pre></td></tr></table></figure></p>
<p>那么我要想添加一堆 Integer 呢？用 addAll 是吧？注意看下 addAll 的签名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean addAll(Collection&lt;? extends E&gt; c);</div></pre></td></tr></table></figure></p>
<p>这个泛型参数又是什么鬼？如果我把这个签名写成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean addAll(Collection&lt;E&gt; c);</div></pre></td></tr></table></figure></p>
<p>我想要在 numbers 当中<code>addAll</code> 一个 <code>ArrayList&lt;Integer&gt;</code>，那就不可能了，因为我们说过，<code>ArrayList&lt;Number&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code>是两个不同的类型，毛关系都没有。</p>
<p><code>? extends E</code> 其实就是使用点协变，允许传入的参数可以是泛型参数类型为<code>Number</code> 子类的任意类型。</p>
<p>当然，也有 <code>? super E</code>的用法，这表示元素类型为<code>E</code> 及其父类，这个通常也叫作逆变。</p>
<h3 id="2-Kotlin-的型变"><a href="#2-Kotlin-的型变" class="headerlink" title="2. Kotlin 的型变"></a>2. Kotlin 的型变</h3><blockquote>
<p>型变包括协变、逆变、不变三种</p>
</blockquote>
<p>下面我们看看 Kotlin 是怎么支持这个特性的。Kotlin 支持声明点型变，我们直接看 Collection 接口的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>out E</code> 就是型变的定义，表明 Collection 的元素类型是协变的，即 <code>Collection&lt;Number&gt;</code> 也是 <code>Collection&lt;Int&gt;</code> 的父类。</p>
<p>而对于 <code>MutableList</code> 来说，它的元素类型就是不变的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface MutableCollection&lt;E&gt; : Collection&lt;E&gt;, MutableIterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">   public fun addAll(elements: Collection&lt;E&gt;): Boolean </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>换言之，<code>MutableCollection&lt;Number&gt;</code> 与<code>MutableCollection&lt;Int&gt;</code> 没有什么关系。</p>
<p>那么请注意看 addAll 的声明，参数是 <code>Collection&lt;E&gt;</code>，而 Collection 是协变的，所以传入的参数可以是任意 E 或者其子类的集合。</p>
<p>逆变的写法也简单一些： <code>Collection&lt;in E&gt;</code>。</p>
<p>那么 Kotlin 是否支持使用点型变呢？当然支持。</p>
<p>我们刚才说 <code>MutableCollection</code> 是不变的，那么如果下面的参数改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public fun addAll(elements: MutableCollection&lt;E&gt;): Boolean</div></pre></td></tr></table></figure>
<p>结果就是，当 E 为 Number 时，addAll 无法接类受似<code>ArrayList&lt;Int&gt;</code>的参数。而为了接受这样的参数，我们可以修改一下签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public fun addAll(elements: MutableCollection&lt;out E&gt;): Boolean</div></pre></td></tr></table></figure>
<p>这其实就与 Java 的型变完全一致了。</p>
<h3 id="3-UnsafeVariance"><a href="#3-UnsafeVariance" class="headerlink" title="3. @UnsafeVariance"></a>3. @UnsafeVariance</h3><p>型变是一个让人费解的话题，很多人接触这东西的时候一开始都会比较晕，我们来看看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyCollection&lt;out T&gt;&#123; </div><div class="line">    fun add(t: T)&#123; // ERROR! </div><div class="line">       ... </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为什么会报错呢？因为 T 是协变的，所以外部传入的参数类型如果是 T 的话，会出问题，不信你看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myList: MyCollection&lt;Number&gt; = MyCollection&lt;Int&gt;() </div><div class="line">myList.add(3.0)</div></pre></td></tr></table></figure></p>
<p>上面的代码毫无疑问可以编译，但运行时就会比较尴尬，因为 <code>MyCollection&lt;Int&gt;</code> 希望接受的是 <code>Int</code>，没想到来了一个 <code>Double</code>。。</p>
<p>对于协变的类型，通常我们是不允许将泛型类型作为传入参数的类型的，或者说，对于协变类型，我们通常是不允许其涉及泛型参数的部分被改变的。这也很容易解释为什么 MutableCollection 是不变的，而 Collection 是协变的，因为在 Kotlin 当中，前者是可被修改的，后者是不可被修改的。</p>
<p>逆变的情形正好相反，即不可以将泛型参数作为方法的返回值。</p>
<p>但实际上有些情况下，我们不得已需要在协变的情况下使用泛型参数类型作为方法参数的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">    public operator fun contains(element: @UnsafeVariance E): Boolean </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如这种情形，为了让编译器放过一马，我们就可以用 @UnsafeVariance 来告诉编译器：“我知道我在干啥，保证不会出错，你不用担心”。</p>
<p>最后再给大家提一个点，现在你们知道为什么 in 表示逆变，out 表示协变了吗？</p>
<blockquote>
<p>节选自：<a href="https://mp.weixin.qq.com/s/WUoanF3_OAP0dRoxBQu_bQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/WUoanF3_OAP0dRoxBQu_bQ</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Java-的型变&quot;&gt;&lt;a href=&quot;#1-Java-的型变&quot; class=&quot;headerlink&quot; title=&quot;1. Java 的型变&quot;&gt;&lt;/a&gt;1. Java 的型变&lt;/h3&gt;&lt;p&gt;如果 Parent 是 Child 的父类，那么 &lt;code&gt;List&amp;lt;Parent&amp;gt;&lt;/code&gt; 和&lt;code&gt;List&amp;lt;Child&amp;gt;&lt;/code&gt; 的关系是什么呢？对于 Java 来说，没有关系。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-输入手机号时自动添加空白（全情况考虑）</title>
    <link href="http://yoursite.com/2017/05/19/Android-%E2%80%94%E2%80%94-%E8%BE%93%E5%85%A5%E6%89%8B%E6%9C%BA%E5%8F%B7%E6%97%B6%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%A9%BA%E7%99%BD%EF%BC%88%E5%85%A8%E6%83%85%E5%86%B5%E8%80%83%E8%99%91%EF%BC%89/"/>
    <id>http://yoursite.com/2017/05/19/Android-——-输入手机号时自动添加空白（全情况考虑）/</id>
    <published>2017-05-19T02:46:00.000Z</published>
    <updated>2017-08-20T04:27:32.133Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>不想重复造轮子，但是查阅后发现网上大部分的博文缺少了考虑的情况。<br>要么粘贴的手机号无法格式化，要么删除时空格也占一个字符。<br>只能自己动手写了个全情况考虑的watcher</p>
</blockquote>
<p>优化：</p>
<ul>
<li>删除时，空格自动删除</li>
<li>手机号粘贴时自动格式化  </li>
</ul>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">public class FormatPhoneNumberWatcher implements TextWatcher &#123;</div><div class="line">    private Context context;</div><div class="line">    private EditText editText;</div><div class="line"></div><div class="line">    public FormatPhoneNumberWatcher(Context context, EditText editText) &#123;</div><div class="line">        this.context = context;</div><div class="line">        this.editText = editText;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</div><div class="line">        if (s == null || s.length() == 0)</div><div class="line">            return;</div><div class="line">      /**</div><div class="line">        分两种情况考虑：编辑情况和粘贴情况</div><div class="line">      */</div><div class="line">        if (count == 1 || count == 0) &#123;</div><div class="line">            inputSituation(s);</div><div class="line">        &#125; else &#123;</div><div class="line">            pasteSituation(s, start, before);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void inputSituation(CharSequence s) &#123;</div><div class="line">        String tel = editText.getText().toString().replace(&quot; &quot;, &quot;&quot;);</div><div class="line">        if (tel.length() &lt;= 3 &amp;&amp; s.toString().length() == 4) &#123;</div><div class="line">            editText.setText(tel);</div><div class="line">        &#125;</div><div class="line">        if (tel.length() &gt; 3 &amp;&amp; tel.length() &lt; 8) &#123;</div><div class="line">            editText.setText(tel.substring(0, 3) + &quot; &quot; + tel.substring(3, tel.length()));</div><div class="line">        &#125;</div><div class="line">        if (tel.length() &gt; 7) &#123;</div><div class="line">            editText.setText(tel.substring(0, 3) + &quot; &quot; + tel.substring(3, 7) + &quot; &quot; + tel.substring(7, tel.length()));</div><div class="line">        &#125;</div><div class="line">        editText.setSelection(editText.getText().toString().length());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void pasteSituation(CharSequence s, int start, int before) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">            if (!(i != 3 &amp;&amp; i != 8 &amp;&amp; s.charAt(i) == &apos; &apos;)) &#123;</div><div class="line">                sb.append(s.charAt(i));</div><div class="line">                if ((sb.length() == 4 || sb.length() == 9) &amp;&amp; sb.charAt(sb.length() - 1) != &apos; &apos;) &#123;</div><div class="line">                    sb.insert(sb.length() - 1, &apos; &apos;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (!sb.toString().equals(s.toString())) &#123;</div><div class="line">            int index = start + 1;</div><div class="line">            if (sb.charAt(start) == &apos; &apos;) &#123;</div><div class="line">                if (before == 0) &#123;</div><div class="line">                    index++;</div><div class="line">                &#125; else &#123;</div><div class="line">                    index--;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (before == 1) &#123;</div><div class="line">                    index--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            editText.setText(sb.toString());</div><div class="line">            editText.setSelection(sb.toString().length());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void afterTextChanged(Editable s) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有BUG可及时反馈，不胜感激。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不想重复造轮子，但是查阅后发现网上大部分的博文缺少了考虑的情况。&lt;br&gt;要么粘贴的手机号无法格式化，要么删除时空格也占一个字符。&lt;br&gt;只能自己动手写了个全情况考虑的watcher&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除时，空格自动删除&lt;/li&gt;
&lt;li&gt;手机号粘贴时自动格式化  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android细节问题-——-有了Intent，为什么还要有Bundle？</title>
    <link href="http://yoursite.com/2017/03/08/Android%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98-%E2%80%94%E2%80%94-%E6%9C%89%E4%BA%86Intent%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89Bundle%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/03/08/Android细节问题-——-有了Intent，为什么还要有Bundle？/</id>
    <published>2017-03-08T09:53:00.000Z</published>
    <updated>2017-08-20T04:27:18.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Intent本身就可以传递参数（Intent.putExtra(“key”, value)）为何还要用Bundle呢？</p>
</blockquote>
<h4 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h4><ol>
<li>Bundle只是一个信息的载体，内部其实就是维护了一个Map<string,object>。 </string,object></li>
<li><p>Intent负责Activity之间的交互，内部是持有一个Bundle的。</p>
<ul>
<li><p>putExtra()方法的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public Intent putExtra(String name, boolean value) &#123;</div><div class="line">        if (mExtras == null) &#123;</div><div class="line">            mExtras = new Bundle();</div><div class="line">        &#125;</div><div class="line">        mExtras.putBoolean(name, value);</div><div class="line">        return this;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>putExtras(Bundle bundle)：会将Intent的内部Bundle替换成参数bundle。</p>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p>例1：<br>从A界面跳转到B界面或者C界面<br>这样的话 我就需要写2个Intent  如果你还要涉及的传值的话 你的Intent就要写两遍添加值的方法。那么，如果我用1个Bundle，直接先存值，然后再存到Intent中 不就更简洁吗？</p>
</li>
<li><p>例2：<br>现在要把值通过Activity A经过Activity B传给Activity C。</p>
<p>如果用Intent的话，A-B先写一遍，再在B中都取出来 然后在把值塞到Intent中，再跳到C。<br>如果在A中用了 Bundle 的话，把Bundle传给B，在B中再转传到C，C就可以直接去取了。 </p>
</li>
</ul>
<h4 id="bundle使用场景"><a href="#bundle使用场景" class="headerlink" title="bundle使用场景"></a>bundle使用场景</h4><ul>
<li>在设备旋转时保存数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> // 自定义View旋转时保存数据</div><div class="line">public class CustomView extends View &#123;</div><div class="line">    @Override</div><div class="line">    protected Parcelable onSaveInstanceState() &#123;</div><div class="line">        super.onSaveInstanceState();</div><div class="line">        Bundle bundle = new Bundle();</div><div class="line">        bundle.put...</div><div class="line">        return bundle;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  // Activity旋转时保存数据</div><div class="line">public class CustomActivity extends Activity &#123;</div><div class="line">  </div><div class="line">    @Override</div><div class="line">    protected void onSaveInstanceState(Bundle savedInstanceState) &#123;</div><div class="line">        super.onSaveInstanceState(savedInstanceState);</div><div class="line">        savedInstanceState.put...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>Fragment之间传递数据<br>比如，某个Fragment中点击按钮弹出一个DialogFragment。<br>最便捷的方式就是通过Fragment.setArguments(args)传递参数。</li>
</ul>
<p>所以，Bundle是不可替代的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Intent本身就可以传递参数（Intent.putExtra(“key”, value)）为何还要用Bundle呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;两者比较&quot;&gt;&lt;a href=&quot;#两者比较&quot; class=&quot;headerlink&quot; title=&quot;两者比较&quot;&gt;&lt;/a&gt;两者比较&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Bundle只是一个信息的载体，内部其实就是维护了一个Map&lt;string,object&gt;。 &lt;/string,object&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Intent负责Activity之间的交互，内部是持有一个Bundle的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;putExtra()方法的源码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public Intent putExtra(String name, boolean value) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (mExtras == null) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            mExtras = new Bundle();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mExtras.putBoolean(name, value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return this;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;putExtras(Bundle bundle)：会将Intent的内部Bundle替换成参数bundle。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之线程和线程池</title>
    <link href="http://yoursite.com/2017/03/06/Android%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2017/03/06/Android面试之线程和线程池/</id>
    <published>2017-03-06T09:51:00.000Z</published>
    <updated>2017-08-20T04:27:59.116Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h4><ol>
<li><p>AsyncTask<br>底层用到了线程池。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。</p>
<p>AsyncTask内的Handler是一个静态的Handler对象，为了能够将执行环境切换到主线程，这就要求Handler这个对象必须在主线程中创建。由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一个进程中的AsyncTask都无法正常工作。</p>
<blockquote>
<p>注意：从Android 3.0开始，默认情况下AsyncTask是串行执行的。但在Android 3.0之前是并行执行的。  </p>
</blockquote>
</li>
<li><p>IntentService<br>底层直接使用了线程，IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，当任务执行完毕后IntentService会自动退出。</p>
<p>特殊的Service，它继承了Service并且它是抽象类。IntentService可用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致他的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务。</p>
</li>
<li><p>HandlerThread<br>底层直接使用了线程，HandlerThread是一中消息循环的线程，在它的内部可以使用Handler。  </p>
<p>HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现很简单，就在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler。</p>
</li>
</ol>
<a id="more"></a>  
<h4 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h4><ol>
<li><p>线程池的优点：</p>
<ul>
<li>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。</li>
<li>能有效控制线程池中的最大并发数，避免大量的线程之间因为互相抢占系统资源而导致的阻塞现象。</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ul>
</li>
<li><p>Android中的线程池的概念来源于Java中的Executor，Executor是一个接口，真正的线程池的实现为ThreadPoolExecutor。</p>
<p>ThreadPoolExecutor提供一系列参数来配置线程池，通过不同的参数可以创建不同的线程池，从线程池的功能特性来说，线程池主要分为4类。</p>
<p>ThreadPoolExecutor执行任务时大致遵循以下规则：</p>
<ul>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li>
<li>如果线程中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li>
<li>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已经满了， 这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li>
<li>如果步骤3的中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ul>
</li>
<li>线程池主要有4类：<ul>
<li>FixThreadPool：这是一种线程数量固定的线程池，当线程处于空闲的时候，并不会被回收，除非线程池被关闭了。</li>
<li>CachedThreadPool：这是一种线程数量不定的线程池，它只有非核心线程，并且最大线程数为Integer.MAX_VALUE。</li>
<li>ScheduledThreadPool：它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收。</li>
<li>SingleThreadExecutor：这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android中的线程形态&quot;&gt;&lt;a href=&quot;#Android中的线程形态&quot; class=&quot;headerlink&quot; title=&quot;Android中的线程形态&quot;&gt;&lt;/a&gt;Android中的线程形态&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AsyncTask&lt;br&gt;底层用到了线程池。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。&lt;/p&gt;
&lt;p&gt;AsyncTask内的Handler是一个静态的Handler对象，为了能够将执行环境切换到主线程，这就要求Handler这个对象必须在主线程中创建。由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一个进程中的AsyncTask都无法正常工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：从Android 3.0开始，默认情况下AsyncTask是串行执行的。但在Android 3.0之前是并行执行的。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IntentService&lt;br&gt;底层直接使用了线程，IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，当任务执行完毕后IntentService会自动退出。&lt;/p&gt;
&lt;p&gt;特殊的Service，它继承了Service并且它是抽象类。IntentService可用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致他的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HandlerThread&lt;br&gt;底层直接使用了线程，HandlerThread是一中消息循环的线程，在它的内部可以使用Handler。  &lt;/p&gt;
&lt;p&gt;HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现很简单，就在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试笔试分享" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android面试总结之缓存</title>
    <link href="http://yoursite.com/2017/03/02/Android%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/03/02/Android面试总结之缓存/</id>
    <published>2017-03-02T09:14:00.000Z</published>
    <updated>2017-08-20T04:27:48.991Z</updated>
    
    <content type="html"><![CDATA[<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>程序中除了图片缓存（三级缓存），还有信息缓存。当用户无法联网时，app会默认显示缓存的数据。</p>
<h5 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h5><ul>
<li><p>SQLite<br>下载完数据文件后，把文件的相关信息如url，路经，下载时间，过期时间等存放到数据库，把url作为唯一的标识。下次下载的时候根据url先从数据库中查询，如果查询到当前时间并未过期，就根据路径读取本地文件，从而实现缓存的效果。  </p>
</li>
<li><p>文件缓存<br>使用File.lastModified()方法得到文件的最后修改时间，与当前时间判断是否过期，从而实现缓存效果。数据格式为JSON。  </p>
</li>
</ul>
<a id="more"></a>
<blockquote>
<p>缓存方式两点说明</p>
<ol>
<li>不同类型的文件的缓存时间不一样。<br>笼统的说，不变文件的缓存时间是永久，变化文件的缓存时间是最大忍受不变时间。说白点，图片文件内容是不变的，一般存在SD卡上直到被清理，我们是可以永远读取缓存的。配置文件内容是可能更新的，需要设置一个可接受的缓存时间。</li>
<li>不同环境下的缓存时间标准不一样。<br>无网络环境下，我们只能读取缓存文件，为了应用有东西显示，没有什么过期之说了。<br>WiFi网络环境下，缓存时间可以设置短一点，一是网速较快，而是流量不要钱。<br>3G流量环境下，缓存时间可以设置长一点，节省流量，而且用户体验也更好。    </li>
</ol>
</blockquote>
<h5 id="缓存时间"><a href="#缓存时间" class="headerlink" title="缓存时间"></a>缓存时间</h5><p>app中多个页面的缓存时间是不一样的，对实时性要求高的页面缓存时间较短。而http消息头中包含有缓存时间，android端无需自己记录/规定缓存时间，读取即可。</p>
<h6 id="http协议对缓存的支持"><a href="#http协议对缓存的支持" class="headerlink" title="http协议对缓存的支持"></a>http协议对缓存的支持</h6><p>Expires &amp; Cache-Control</p>
<p>Expires响应首部给出了响应失效的绝对时间,这样客户端就可以缓存一份副本,在这个时间到期之前,<br>不用去询问服务器它是否有效了。http1.0引入。 例:Expires: Thu, 03 Oct 1997 17:15:00 GMT</p>
<p>Cache-Control首部用于传输对象的缓存信息。http1.1引入。它的值是一个缓存指令，给出了与某个对象可缓存性有关的特有指令。这个首部可以出现在请求或者响应头中。例如:Cache-Control: no-cache<br>CacheControl有两个字段表达响应的过期时间：max-age和max-stale </p>
<ul>
<li>前者表示：max-age秒内，网页再有请求，你不要来我服务端，直接取你本地缓存的结果好了 </li>
<li>后者表示：max-stale秒内的请求，你可以使用本地缓存的，但还是要来我服务端问问，到底行不行，当然，这里要带上Last Modified等信息 ，如果服务端返回了304，那说明你本地缓存继续用吧，我不给你响应体200的话，自然就带上了响应体。 </li>
</ul>
<p>Expires和Cache-Control作用一致，都是指当前资源的有效期，控制是直接从缓存获取数据还是重新发送请求到服务器取数据。</p>
<h5 id="缓存算法"><a href="#缓存算法" class="headerlink" title="缓存算法"></a>缓存算法</h5><ol>
<li><p>LRU - 最近最少使用（最后访问时间）<br>替换掉最近被请求最少的文档。这一传统策略在实际中应用最广。在CPU缓存淘汰和虚拟内存系统中效果较好。  </p>
</li>
<li><p>LRU-K<br>LRU-K中的K代表最近使用的次数，也可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。<br>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。如下：<br><img src="http://upload-images.jianshu.io/upload_images/3167794-efc0f5b183b53a39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>LFU - 最不经常使用（访问次数）<br>替换掉访问次数最少的。这一策略意图保留最常用的、最流行的对象，替换掉很少使用的那些。<br>LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。<br>如下：<br><img src="http://upload-images.jianshu.io/upload_images/3167794-607be40d1b32a620?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li>SIZE（缓存大小）<br>替换size最大的对象。这一策略通过淘汰一个大对象而不是多个小对象来提高命中率。不过，可能有些进入缓存的小对象永远不会再被访问。SIZE策略没有提供淘汰这类对象的机制，会导致“缓存污染”（大量偶发性的数据访问让内存中存放大量冷数据,也即是缓存污染）。</li>
<li>以上算法结合使用….</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h5&gt;&lt;p&gt;程序中除了图片缓存（三级缓存），还有信息缓存。当用户无法联网时，app会默认显示缓存的数据。&lt;/p&gt;
&lt;h5 id=&quot;缓存方式&quot;&gt;&lt;a href=&quot;#缓存方式&quot; class=&quot;headerlink&quot; title=&quot;缓存方式&quot;&gt;&lt;/a&gt;缓存方式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SQLite&lt;br&gt;下载完数据文件后，把文件的相关信息如url，路经，下载时间，过期时间等存放到数据库，把url作为唯一的标识。下次下载的时候根据url先从数据库中查询，如果查询到当前时间并未过期，就根据路径读取本地文件，从而实现缓存的效果。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件缓存&lt;br&gt;使用File.lastModified()方法得到文件的最后修改时间，与当前时间判断是否过期，从而实现缓存效果。数据格式为JSON。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试笔试分享" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android面试总结之接口维护（版本控制）</title>
    <link href="http://yoursite.com/2017/03/02/Android%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8E%A5%E5%8F%A3%E7%BB%B4%E6%8A%A4%EF%BC%88%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/02/Android面试总结之接口维护（版本控制）/</id>
    <published>2017-03-02T08:32:00.000Z</published>
    <updated>2017-08-20T04:27:39.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一般情况下，APP中会有大量的接口，再加上版本的变化，接口的升级，可能会衍生出很多个稍有差异的接口，这个时候接口如果维护的不好，后边会乱为一锅粥，客户端不同版本使用不同的接口名（xxxv1,xxxv2,xxxv3…..）。<br>有的公司每次发布完APP，就强制用户更新。不推荐这样，用户体验太差。<br>就算是强制更新，在苹果审核期间，新的APP接口和老的接口也必须能同时使用。  </p>
</blockquote>
<a id="more"></a>
<h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><h5 id="一、-客户端做兼容，接口不用做兼容"><a href="#一、-客户端做兼容，接口不用做兼容" class="headerlink" title="一、 客户端做兼容，接口不用做兼容"></a>一、 客户端做兼容，接口不用做兼容</h5><ol>
<li><p><strong>APP强制更新（不建议）</strong><br>接口URL：api.xxx.com/v1.0/xxxx.java<br>接口的URL中加入版本号，如上：v1.0。<br>采用灰度服务器 部署正在审核中的 接口版本（如：v1.1）。等审核通过后，将老版本的APP设置强制更新，然后把线上服务器重新部署上最新的代码，再去掉灰度服务器。这样APP接口全部访问正式的线上服务器。</p>
</li>
<li><p><strong>热更新</strong><br>紧急的小需求可以用热更新，大的需求建议还是用原生的代码，因为你用热更新修改完（用JS或Lua），最后还要在原生代码里修改。<br>网游用热更新的比较多，因为网游的APP太大，不可能加个小关卡 就要求用户重新下载，并且游戏更新比企业级APP更频繁，用热更新可以不断新加关卡、场景、活动推广。  </p>
</li>
<li><strong>React Native 和Weex</strong><br>没接触过 可以自己了解</li>
</ol>
<h5 id="二、-服务端做版本兼容"><a href="#二、-服务端做版本兼容" class="headerlink" title="二、 服务端做版本兼容"></a>二、 服务端做版本兼容</h5><ol>
<li><strong>App 请求服务器接口的时候携带接口版本字段</strong><br>服务器根据接口版本调用相应的方法，每个接口逻辑里 加if 判断（不推荐）<br>接口URL：api.xxx.com/api?version=v1&amp;..<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (version == ‘1.5.0’) &#123;</div><div class="line">　　//do_something</div><div class="line">&#125; else if (version ==‘1.4.0&apos;) &#123;</div><div class="line">　　//do_something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>不同版本的逻辑都在一个方法里，在于容易造成代码混乱，不利于维护。</p>
<ol>
<li><p><strong>一个版本一个文件</strong><br>相当于每个接口版本都是一个独立的项目。放到服务器的独立文件夹里。使用什么版本接口写到客户端配置里面或者通过一个接口获取就行。<br>例：<br>1.0版本：<a href="http://x.x.x.x:xx/xxapi/v1.0/xxx" target="_blank" rel="external">http://x.x.x.x:xx/xxapi/v1.0/xxx</a><br>1.2版本：<a href="http://x.x.x.x:xx/xxapi/v1.2/xxx" target="_blank" rel="external">http://x.x.x.x:xx/xxapi/v1.2/xxx</a><br>文件夹位置：Controller/V1.0/<br>—————–/xxxx.php<br>文件夹位置：Controller/V1.2/<br>—————–/xxxx.php<br>优点：版本逻辑分开维护。看url就能知道哪个版本。删除多余版本 不用修改代码。<br>缺点：同个接口不同版本 文件是重复的。并且 如果有个接口前几版就有问题，一直遗留到现在，就需要改好几套一样的代码。</p>
</li>
<li><p><strong>token代替版本号</strong><br><img src="http://upload-images.jianshu.io/upload_images/3167794-202e7e6133579549.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/3167794-3e0112e31dc00261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>几个要点：<br>a. 客户端发送请求时token是固定不变的，使用token间接的标记请求的接口版本。<br>b. server保存了token和对应接口的版本号，请求来了之后会先根据这个寻找对应的接口版本。<br>c. 每个目录对应一个版本，根据请求的接口读取对应目录下的接口配置文件，找到最终要执行的具体接口。<br>例如：<a href="http://xxxx.xxxx.com/module/controller/list?token=6918b5e0567c7d47314c10ed413e3f95" target="_blank" rel="external">http://xxxx.xxxx.com/module/controller/list?token=6918b5e0567c7d47314c10ed413e3f95</a> 这个请求最终会打到listv2这个接口。<br>d. 这样就可以在服务端灵活的配置接口了，客户端只要每次请求的时候带上默认的token参数，就可以得到自己想要的了，完全不需要关心版本的问题。</p>
</li>
<li><p><strong>继承的方式</strong><br>ControllerV1<br>ControllerV2 extends ControllerV1<br>采用继承的方式，既可以利用之前的接口代码，又可以采用override的方式修改部分接口的实现。<br>缺点：如果上个版本（也就是父类）修改了代码，就会影响后面的所有版本。  </p>
</li>
<li><p><strong>不同版本使用不同的域名/不同服务器</strong><br>不同版本不同分支，部署在不同的服务器上。如果某个版本用不到了，直接干掉服务就好了。<br>例如我现在的API要从1.x升到不兼容的2.0版本了，那就给当前的发布分支打个Tag。等哪天1.x版的API需要fix bug，就能很简单地从这个Tag切一个1.x的分支出来fix bug后进行测试发布，而且这个分支不会合并到任何分支，所以不会影响其他版本。<br>优点：部署的过程不会影响其他版本api的使用，并且可以减轻单台服务器的负担。<br>缺点：如果2.0也有同样bug的话，也要在2.0分支上改一遍。如果版本很多的话，工作量大。所以呢，一般不会同时发布两个以上的版本。另外，如果要兼容过多的版本，服务器也需要够多才行。同时，因为老版本的人用的少，也就是有的服务器访问量很少，有的服务器访问量很多。不能真正的负载均衡，浪费了服务器资源。</p>
</li>
</ol>
<p>最后做下版本使用监控。当观察到所有用户都使用新版本的客户端的时候，并保持一段时间的时候。放弃对老版本的维护，继而下掉老版本的资源。</p>
<hr>
<h4 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h4><p>开启APP-&gt;请求初始化接口-&gt;检测是否需要更新? 否-&gt;首页Or 是-&gt;更新  </p>
<p>在初始化接口的时候，需要客户端发送几个数据：</p>
<pre><code>app_id            客户端id，比如： 1，安卓手机 2，iphone手机

version_id        大版本号id

version_mini      小版本号id

did               用户客户端信息（客户端工程师会获取这个数据）

encrypt_did       did加密后的字符串（did 加上 APP设备数据表中的key，然后md5）
</code></pre><p>数据库方面：需要两张表。一张是记录升级版本信息的表，记录着设备的id，版本号信息，下载地址等。另外一张表是记录的设备的信息，比如安卓手机的信息，版本信息表中有一个外键app_id，关联的就是设备信息表的主键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//设备信息表，记录了各种客户端的信息</div><div class="line">  CREATE TABLE IF NOT EXISTS `app_table` (</div><div class="line">    `app_id` smallint(6) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</div><div class="line">    `name` varchar(10) NOT NULL COMMENT &apos;设备名称&apos;,</div><div class="line">    `is_encryption` tinyint(1) NOT NULL COMMENT &apos;是否加密&apos;,</div><div class="line">    `key` varchar(10) NOT NULL COMMENT &apos;加密key&apos;,</div><div class="line">    `image_size` text NOT NULL COMMENT &apos;按照json来存储&apos;,</div><div class="line">    `create_time` int(11) NOT NULL COMMENT &apos;添加时间&apos;,</div><div class="line">    `update_time` int(11) NOT NULL COMMENT &apos;修改时间&apos;,</div><div class="line">    `status` tinyint(1) NOT NULL COMMENT &apos;状态 1正常0删除&apos;,</div><div class="line">    PRIMARY KEY (`app_id`)</div><div class="line">  ) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT=&apos;app设备表&apos; AUTO_INCREMENT=2 ;</div><div class="line">  </div><div class="line">  //版本升级信息表，存放了各种版本的信息</div><div class="line">  CREATE TABLE IF NOT EXISTS `version_upgrade` (</div><div class="line">    `id` smallint(4) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</div><div class="line">    `app_id` smallint(4) NOT NULL COMMENT &apos;客户端设备id&apos;,</div><div class="line">    `version_id` smallint(4) NOT NULL COMMENT &apos;大版本号id&apos;,</div><div class="line">    `version_mini` mediumint(8) NOT NULL COMMENT &apos;小版本号&apos;,</div><div class="line">    `version_code` varchar(10) NOT NULL COMMENT &apos;版本标识1.2&apos;,</div><div class="line">    `type` tinyint(4) NOT NULL COMMENT &apos;是否升级1是0否&apos;,</div><div class="line">    `apk_url` varchar(255) NOT NULL COMMENT &apos;下载链接地址&apos;,</div><div class="line">    `upgrade_point` varchar(255) NOT NULL COMMENT &apos;升级提示&apos;,</div><div class="line">    `status` tinyint(4) NOT NULL,</div><div class="line">    `create_time` int(11) NOT NULL COMMENT &apos;添加时间&apos;,</div><div class="line">    `update_time` int(11) NOT NULL COMMENT &apos;修改时间&apos;,</div><div class="line">    PRIMARY KEY (`id`)</div><div class="line">  ) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT=&apos;软件升级信息表&apos; AUTO_INCREMENT=2 ;</div></pre></td></tr></table></figure></p>
<p>通过app的版本信息与服务器信息对比，看是否要进行版本升级</p>
<blockquote>
<p>参考文章<br><a href="http://www.cnblogs.com/dahe007/p/6255401.html" target="_blank" rel="external">http://www.cnblogs.com/dahe007/p/6255401.html</a><br><a href="https://my.oschina.net/woshixiaomayi/blog/519783" target="_blank" rel="external">https://my.oschina.net/woshixiaomayi/blog/519783</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一般情况下，APP中会有大量的接口，再加上版本的变化，接口的升级，可能会衍生出很多个稍有差异的接口，这个时候接口如果维护的不好，后边会乱为一锅粥，客户端不同版本使用不同的接口名（xxxv1,xxxv2,xxxv3…..）。&lt;br&gt;有的公司每次发布完APP，就强制用户更新。不推荐这样，用户体验太差。&lt;br&gt;就算是强制更新，在苹果审核期间，新的APP接口和老的接口也必须能同时使用。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试笔试分享" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-项目坑总结</title>
    <link href="http://yoursite.com/2017/02/07/Android-%E2%80%94%E2%80%94-%E9%A1%B9%E7%9B%AE%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/02/07/Android-——-项目坑总结/</id>
    <published>2017-02-07T03:32:58.000Z</published>
    <updated>2017-08-20T04:27:08.127Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><ul>
<li>需求：定时任务 </li>
<li>处理：不能在service中循环调用 AsyncTask执行长时间任务，会造成堵塞。要改用Thread或CachedThreadPool线程池。</li>
<li>原因：<br>在官方文档中指出， <code>AsyncTasks should ideally be used for short operations</code>， 就是说AsyncTask执行的任务应该是一些短时间内可以完成的任务， 因为在Android3.0之后， 默认情况下， 同一时间只能有一个AsyncTask在运行， 也就是说所有的task都是串行运行的。所以如果某个task执行时间很长， 会导致后面的task长时间等待， 当然也可以通过调<code>executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</code>， 可以同时运行5个Task。<br>如果最大同时运行5个Task不能满足要求，就要自己使用线程池了。  </li>
</ul>
</li>
</ol>
<a id="more"></a>
<ol>
<li><ul>
<li>需求：加载大图防止内存溢出问题</li>
<li>问题：decodeStream解析图片一直为null</li>
<li>原因：Android 的一个bug，input 流不能用两次 可以把流转换成数组，然后再用<a href="http://blog.csdn.net/andypan1314/article/details/6670320" target="_blank" rel="external">该方法</a></li>
</ul>
</li>
<li><ul>
<li>需求：科大讯飞语音转文字</li>
<li>问题：<br>1.组件加载失败<br>解决：so包缺失<br>2.用户校验失败<br>解决：<code>libmsc.so</code>一定要用自己id下载的SDK，因为SDK和appid是绑定的，拷贝旧项目的so是不行的！</li>
</ul>
</li>
<li><ul>
<li>问题：<code>mImageView.getDrawingCache()</code>取值为空</li>
<li>解决：<br><code>setImageBitmap()/setImageDrawable</code>设置图片的方式才可以取到缓存<br><code>setImageResource</code>方法设置图片则缓存取值为null。<br>官方建议用<code>setImageDrawable</code>代替<code>setImageBitmap</code>，这样可以减少new的对象。实际上<code>setImageBitmap</code>方法就是把Bitmap对象封装成Drawable对象,然后调用setImageDrawable</li>
</ul>
</li>
<li><ul>
<li>需求：文件传输</li>
<li>问题：新文件发过来后在系统媒体库中找不到新文件记录，必须得重启才能更新</li>
<li>解决：自己手动把新文件信息插入媒体库</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;需求：定时任务 &lt;/li&gt;
&lt;li&gt;处理：不能在service中循环调用 AsyncTask执行长时间任务，会造成堵塞。要改用Thread或CachedThreadPool线程池。&lt;/li&gt;
&lt;li&gt;原因：&lt;br&gt;在官方文档中指出， &lt;code&gt;AsyncTasks should ideally be used for short operations&lt;/code&gt;， 就是说AsyncTask执行的任务应该是一些短时间内可以完成的任务， 因为在Android3.0之后， 默认情况下， 同一时间只能有一个AsyncTask在运行， 也就是说所有的task都是串行运行的。所以如果某个task执行时间很长， 会导致后面的task长时间等待， 当然也可以通过调&lt;code&gt;executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)&lt;/code&gt;， 可以同时运行5个Task。&lt;br&gt;如果最大同时运行5个Task不能满足要求，就要自己使用线程池了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
