<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FeelsChaotic</title>
  <subtitle>程序媛、乐器狂、工匠、重度偏执者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-18T12:30:22.523Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>feelschaotic</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文应用-AOP---最全选型考量-+-边剖析经典开源库边实践，美滋滋</title>
    <link href="http://yoursite.com/2018/12/17/new/%E4%B8%80%E6%96%87%E5%BA%94%E7%94%A8-AOP---%E6%9C%80%E5%85%A8%E9%80%89%E5%9E%8B%E8%80%83%E9%87%8F-+-%E8%BE%B9%E5%89%96%E6%9E%90%E7%BB%8F%E5%85%B8%E5%BC%80%E6%BA%90%E5%BA%93%E8%BE%B9%E5%AE%9E%E8%B7%B5%EF%BC%8C%E7%BE%8E%E6%BB%8B%E6%BB%8B/"/>
    <id>http://yoursite.com/2018/12/17/new/一文应用-AOP---最全选型考量-+-边剖析经典开源库边实践，美滋滋/</id>
    <published>2018-12-17T12:59:00.000Z</published>
    <updated>2018-12-18T12:30:22.523Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3167794-d74bbee5d2e42039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AOP系列思维导图"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-01a9ab339f39ed7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>繁多的 AOP 方法该如何选择？应用的步骤过于繁琐，语法概念看得头晕脑胀？</p>
<p>本文将详细展示选型种种考量维度，更是砍掉 2 个经典开源库的枝节，取其主干细细体会 AOP 的应用思想和关键流程。一边实践 AOP 一边还能掌握开源库，岂不快哉！</p>
<a id="more"></a>
<h2 id="一、6-个要点帮你选择合适的-AOP-方法"><a href="#一、6-个要点帮你选择合适的-AOP-方法" class="headerlink" title="一、6 个要点帮你选择合适的 AOP 方法"></a>一、6 个要点帮你选择合适的 AOP 方法</h2><hr>
<p>在上文 <a href="https://www.jianshu.com/p/0799aa19ada1" target="_blank" rel="external">最全面 AOP 方法探讨</a> 中，我们分析对比了最热门的几种 AOP 方法。那么，在实际情况和业务需求中，我们该怎么考量选择呢？</p>
<h3 id="1-明确你应用-AOP-在什么项目"><a href="#1-明确你应用-AOP-在什么项目" class="headerlink" title="1. 明确你应用 AOP 在什么项目"></a>1. 明确你应用 AOP 在什么项目</h3><p>如果你正在维护一个现有的项目，你要么小范围试用，要么就需要选择一个侵入性小的 AOP 方法（如：APT 代理类生效时机需要手动调用，灵活，但在插入点繁多情况下侵入性过高）。</p>
<h3 id="2-明确切入点的相似性"><a href="#2-明确切入点的相似性" class="headerlink" title="2. 明确切入点的相似性"></a>2. 明确切入点的相似性</h3><p>第一步，考虑一下切入点的数量和相似性，你是否愿意一个个在切点上面加注解，还是用相似性统一切。</p>
<p>第二步，考虑下这些应用切面的类有没有被 final 修饰，同时相似的方法有没有被 static 或 final 修饰时。 final 修饰的类就不能通过 cglib 生成代理，cglib 会继承被代理类，需要重写被代理方法，所以被代理类和方法不能是 final。</p>
<h3 id="3-明确织入的粒度和织入时机"><a href="#3-明确织入的粒度和织入时机" class="headerlink" title="3. 明确织入的粒度和织入时机"></a>3. 明确织入的粒度和织入时机</h3><p>我怎么选择织入（Weave）的时机？编译期间织入，还是编译后？载入时？或是运行时？通过比较各大 AOP 方法在织入时机方面的不同和优缺点，来获得对于如何选择 Weave 时机进行判定的准则。</p>
<p>对于普通的情况而言，在编译时进行 Weave 是最为直观的做法。因为源程序中包含了应用的所有信息，这种方式通常支持最多种类的联结点。利用编译时 Weave，我们能够使用 AOP 系统进行细粒度的 Weave 操作，例如读取或写入字段。源代码编译之后形成的模块将丧失大量的信息，因此通常采用粗粒度的 AOP 方法。</p>
<p>同时，对于传统的编译为本地代码的语言如 C++ 来说，编译完成后的模块往往跟操作系统平台相关，这就给建立统一的载入时、运行时 Weave 机制造成了困难。对于编译为本地代码的语言而言，只有在编译时进行 Weave 最为可行。尽管编译时 Weave 具有功能强大、适应面广泛等优点，但他的缺点也很明显。首先，它需要程序员提供所有的源代码，因此对于模块化的项目就力不从心了。</p>
<p>为了解决这个问题，我们可以选择支持编译后 Weave 的 AOP 方法。</p>
<p>新的问题又来了，如果程序的主逻辑部分和 Aspect 作为不同的组件开发，那么最为合理的 Weave 时机就是在框架载入 Aspect 代码之时。</p>
<p>运行时 Weave 可能是所有 AOP 方法中最为灵活的，程序在运行过程中可以为单个的对象指定是否需要 Weave 特定的方面。</p>
<p>选择合适的 Weave 时机对于 AOP 应用来说是非常关键的。针对具体的应用场合，我们需要作出不同的抉择。我们也可以结合多种 AOP 方法，从而获得更为灵活的 Weave 策略。</p>
<h3 id="4-明确对性能的要求，明确对方法数的要求"><a href="#4-明确对性能的要求，明确对方法数的要求" class="headerlink" title="4. 明确对性能的要求，明确对方法数的要求"></a>4. 明确对性能的要求，明确对方法数的要求</h3><p>除了动态 Hook 方法，其他的 AOP 方法对性能影响几乎可以忽略不计。动态 AOP 本质使用了动态代理，不可避免要用到反射。而 APT 不可避免地要生成大量的代理类和方法。如何权衡，就看你对项目的要求。</p>
<h3 id="5-明确是否需要修改原有类"><a href="#5-明确是否需要修改原有类" class="headerlink" title="5. 明确是否需要修改原有类"></a>5. 明确是否需要修改原有类</h3><p>如果只是想特定地增强能力，可以使用 APT，在编译期间读取 Java 代码，解析注解，然后动态生成 Java 代码。</p>
<p>下图是Java编译代码的流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-c685b5a10882d3c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，APT 工作在 Annotation Processing 阶段，最终通过注解处理器生成的代码会和源代码一起被编译成 Java 字节码。不过比较遗憾的是你不能修改已经存在的 Java 文件，比如在已经存在的类中添加新的方法或删除旧方法，所以通过 APT 只能通过辅助类的方式来实现注入，这样会略微增加项目的方法数和类数，不过只要控制好，不会对项目有太大的影响。</p>
<h3 id="6-明确调用的时机"><a href="#6-明确调用的时机" class="headerlink" title="6. 明确调用的时机"></a>6. 明确调用的时机</h3><p>APT 的时机需要主动调用，而其他 AOP 方法注入代码的调用时机和切入点的调用时机一致。</p>
<h2 id="二、从开源库剖析-AOP"><a href="#二、从开源库剖析-AOP" class="headerlink" title="二、从开源库剖析 AOP"></a>二、从开源库剖析 AOP</h2><hr>
<p>AOP 的实践都写烂了，市面上有太多讲怎么实践 AOP 的博文了。那这篇和其他的博文有什么不同呢？有什么可以让大家受益的呢？</p>
<p>其实 AOP 实践很简单，关键是理解并应用，我们先参考开源库的实践，在这基础上去抽象关键步骤，一边实战一边达成阅读开源库任务，美滋滋！</p>
<h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><h4 id="1-经典-APT-框架-ButterKnife-工作流程"><a href="#1-经典-APT-框架-ButterKnife-工作流程" class="headerlink" title="1. 经典 APT 框架 ButterKnife 工作流程"></a>1. 经典 APT 框架 ButterKnife 工作流程</h4><p>直接上图说明。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-efdf601479ae98df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="APT之ButterKnife工作流程"></p>
<blockquote>
<p>在上面的过程中，你可以看到，为什么用 @Bind 、 @OnClick 等注解标注的属性、方法必须是 public 或 protected？<br>因为ButterKnife 是通过 被代理类引用.this.editText 来注入View的。为什么要这样呢？<br>答案就是：性能 。如果你把 View 和方法设置成 private，那么框架必须通过反射来注入。</p>
<p>想深入到源码细节了解 ButterKnife 更多？</p>
<ul>
<li><a href="https://medium.com/@lgvalle/how-butterknife-actually-works-85be0afbc5ab" target="_blank" rel="external">how-butterknife-actually-works</a></li>
<li><a href="https://www.jianshu.com/p/1c449c1b0fa2" target="_blank" rel="external">ButterKnife源码分析</a></li>
<li><a href="https://juejin.im/post/58f388d1da2f60005d369a09" target="_blank" rel="external">拆 JakeWharton 系列之 ButterKnife</a></li>
</ul>
</blockquote>
<h4 id="2-仿造-ButterKnife，上手-APT"><a href="#2-仿造-ButterKnife，上手-APT" class="headerlink" title="2. 仿造 ButterKnife，上手 APT"></a>2. 仿造 ButterKnife，上手 APT</h4><p>我们去掉细节，抽出关键流程，看看 ButterKnife 是怎么应用 APT 的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-eed4f0ed1d3953f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="APT工作流程"></p>
<p>可以看到关键步骤就几项：</p>
<ol>
<li>定义注解</li>
<li>编写注解处理器</li>
<li>扫描注解</li>
<li>编写代理类内容</li>
<li>生成代理类</li>
<li>调用代理类</li>
</ol>
<p>我们标出重点，也就是我们需要实现的步骤。如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-cdb8bbbceab90bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="APT工作流程重点"></p>
<p>咦，你可能发现了，最后一个步骤是在合适的时机去调用代理类或门面对象。这就是 APT 的缺点之一，在任意包位置自动生成代码但是运行时却需要主动调用。</p>
<blockquote>
<p>APT 手把手实现可参考 <a href="https://blog.csdn.net/xuguobiao/article/details/72775730" target="_blank" rel="external">JavaPoet - 优雅地生成代码——3.2 一个简单示例</a></p>
</blockquote>
<h4 id="3-工具详解"><a href="#3-工具详解" class="headerlink" title="3. 工具详解"></a>3. 工具详解</h4><p>APT 中我们用到了以下 3 个工具：</p>
<h5 id="（1）Java-Annotation-Tool"><a href="#（1）Java-Annotation-Tool" class="headerlink" title="（1）Java Annotation Tool"></a>（1）Java Annotation Tool</h5><p> Java Annotation Tool 给了我们一系列 API 支持。</p>
<ol>
<li>通过 Java Annotation Tool 的 Filer 可以帮助我们以文件的形式输出JAVA源码。</li>
<li>通过 Java Annotation Tool 的 Elements 可以帮助我们处理扫描过程中扫描到的所有的元素节点，比如包（PackageElement）、类(TypeElement)、方法(ExecuteableElement)等。</li>
<li>通过 Java Annotation Tool 的 TypeMirror 可以帮助我们判断某个元素是否是我们想要的类型。</li>
</ol>
<h5 id="（2）JavaPoet"><a href="#（2）JavaPoet" class="headerlink" title="（2）JavaPoet"></a>（2）<a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a></h5><p>你当然可以直接通过字符串拼接的方式去生成 java 源码，怎么简单怎么来，一张图 show JavaPoet 的厉害之处。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-ab133176ec258953.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成同样的类，使用JavaPoet前，字符串拼接"><br><img src="https://upload-images.jianshu.io/upload_images/3167794-3632e60935638e72.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成同样的类，使用JavaPoet后，以面向对象的方式来生成源码"></p>
<h5 id="（3）APT-插件"><a href="#（3）APT-插件" class="headerlink" title="（3）APT 插件"></a>（3）APT 插件</h5><p>注解处理器已经有了，那么怎么执行它？这个时候就需要用到 android-apt 这个插件了，使用它有两个目的：</p>
<ol>
<li>允许配置只在编译时作为注解处理器的依赖，而不添加到最后的APK或library</li>
<li>设置源路径，使注解处理器生成的代码能被Android Studio正确的引用</li>
</ol>
<blockquote>
<p>项目引入了 butterknife 之后就无需引入 apt 了，如果继续引入会报 <code>Using incompatible plugins for the annotation processing</code></p>
</blockquote>
<h5 id="（4）AutoService"><a href="#（4）AutoService" class="headerlink" title="（4）AutoService"></a>（4）AutoService</h5><p>想要运行注解处理器，需要繁琐的步骤：</p>
<ol>
<li>在 processors 库的 main 目录下新建 resources 资源文件夹；</li>
<li>在 resources文件夹下建立 META-INF/services 目录文件夹；</li>
<li>在 META-INF/services 目录文件夹下创建 javax.annotation.processing.Processor 文件；</li>
<li>在 javax.annotation.processing.Processor 文件写入注解处理器的全称，包括包路径；</li>
</ol>
<p>Google 开发的 AutoService 可以减少我们的工作量，只需要在你定义的注解处理器上添加 @AutoService(Processor.class) ，就能自动完成上面的步骤，简直不能再方便了。</p>
<h4 id="4-代理执行"><a href="#4-代理执行" class="headerlink" title="4. 代理执行"></a>4. 代理执行</h4><p>虽然前面有说过 APT 并不能像 Aspectj 一样实现代码插入，但是可以使用变种方式实现。用注解修饰一系列方法，由 APT 来代理执行。此部分可参考<a href="https://github.com/lizhaoxuan/CakeRun" target="_blank" rel="external">CakeRun</a></p>
<p>APT 生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生 Crash 的类。</p>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><h4 id="1-经典-Aspectj-框架-hugo-工作流程"><a href="#1-经典-Aspectj-框架-hugo-工作流程" class="headerlink" title="1. 经典 Aspectj 框架 hugo 工作流程"></a>1. 经典 Aspectj 框架 hugo 工作流程</h4><p>J 神的框架一如既往小而美，想啃开源库源码，可以先从 J 神的开源库先读起。</p>
<p>回到正题，hugo是 J 神开发的 Debug 日志库，包含了优秀的思想以及流行的技术，例如注解、AOP、AspectJ、Gradle 插件、android-maven-gradle-plugin 等。在进行 hugo 源码解读之前，你需要首先对这些知识点有一定的了解。</p>
<p>先上工作流程图，我们再讲细节：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-82883c1680541fef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Aspect之hugo工作流程"></p>
<h4 id="2-解惑之一个打印日志逻辑怎么织入的？"><a href="#2-解惑之一个打印日志逻辑怎么织入的？" class="headerlink" title="2. 解惑之一个打印日志逻辑怎么织入的？"></a>2. 解惑之一个打印日志逻辑怎么织入的？</h4><p> 只需要一个 <code>@DebugLog</code>注解，hugo就能帮我们打印入参出参、统计方法耗时。自定义注解很好理解，我们重点看看切面 Hugo 是怎么处理的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-831a567a48fdc2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>有没有发现什么？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-22ad06f44ae350ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-d13a3b475f04ceaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>没错，切点表达式帮助我们描述具体要切入哪里。</p>
<p>AspectJ 的切点表达式由关键字和操作参数组成，以切点表达式 <code>execution(* helloWorld(..))</code>为例，其中 <code>execution</code> 是关键字，为了便于理解，通常也称为函数，而<code>* helloWorld(..)</code>是操作参数，通常也称为函数的入参。切点表达式函数的类型很多，如方法切点函数，方法入参切点函数，目标类切点函数等，hugo 用到的有两种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">入参</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">execution()</td>
<td style="text-align:left">方法切点函数</td>
<td style="text-align:left">方法匹配模式字符串</td>
<td style="text-align:left">表示所有目标类中满足某个匹配模式的方法连接点，例如 execution(* helloWorld(..)) 表示所有目标类中的 helloWorld 方法，返回值和参数任意</td>
</tr>
<tr>
<td style="text-align:left">within()</td>
<td style="text-align:left">目标类切点函数</td>
<td style="text-align:left">类名匹配模式字符串</td>
<td style="text-align:left">表示满足某个匹配模式的特定域中的类的所有连接点，例如 within(com.feelschaotic.demo.*) 表示 com.feelschaotic.demo 中的所有类的所有方法</td>
</tr>
</tbody>
</table>
<blockquote>
<p>想详细入门 AspectJ 语法？</p>
<ul>
<li><a href="https://blog.csdn.net/eclipsexys/article/details/54425414" target="_blank" rel="external">看AspectJ在Android中的强势插入</a></li>
<li><a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="external">深入理解Android之AOP</a><br>语法讲得非常详细</li>
</ul>
</blockquote>
<h4 id="3-解惑之-AspectJ-in-Android-为何如此丝滑？"><a href="#3-解惑之-AspectJ-in-Android-为何如此丝滑？" class="headerlink" title="3. 解惑之 AspectJ in Android 为何如此丝滑？"></a>3. 解惑之 AspectJ in Android 为何如此丝滑？</h4><p>我们引入 hugo 只需要 3 步。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-ef5773efa82abc73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>不是说 AspectJ 在 Android 中很不友好？！说好的需要使用 andorid-library gradle 插件在编译时做一些 hook，使用 AspectJ 的编译器（ajc，一个java编译器的扩展）对所有受 aspect 影响的类进行织入，在 gradle 的编译 task 中增加一些额外配置，使之能正确编译运行等等等呢？</p>
<p>这些 hugo 已经帮我们做好了（所以步骤 2 中，我们引入 hugo 的同时要使用 hugo 的 Gradle 插件，就是为了 hook 编译）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-e420312647f17e82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-e1d3520a2591548a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-26dbeb0fb6554db5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="4-抽丝剥茧-Aspect-的重点流程"><a href="#4-抽丝剥茧-Aspect-的重点流程" class="headerlink" title="4. 抽丝剥茧 Aspect 的重点流程"></a>4. 抽丝剥茧 Aspect 的重点流程</h4><p>抽象一下 hugo 的工作流程，我们得到了 2 种Aspect工作流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-d4f7e01bd3889e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Aspect侵入式工作流程"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-a3c395fe7c038271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Aspect非侵入式工作流程"></p>
<p>前面选择合适的 AOP 方法第 2 点我们提到，以 Pointcut 切入点作为区分，AspectJ 有两种用法：</p>
<ol>
<li><p>用自定义注解修饰切入点，<strong>精确</strong>控制切入点，属于<strong>侵入式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//方法一：一个个在切入点上面加注解</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">	//...</div><div class="line">	followTextView.setOnClickListener(view -&gt; &#123;</div><div class="line">		onClickFollow();</div><div class="line">	&#125;);</div><div class="line">	unFollowTextView.setOnClickListener(view -&gt; &#123;</div><div class="line">		onClickUnFollow();</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@SingleClick(clickIntervalTime = 1000)</div><div class="line">private void onClickUnFollow() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@SingleClick(clickIntervalTime = 1000)</div><div class="line">private void onClickFollow() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Aspect</div><div class="line">public class AspectTest &#123;</div><div class="line">	@Around(&quot;execution(@com.feelschaotic.aspectj.annotations.SingleClick * *(..))&quot;)</div><div class="line">	public void onClickLitener(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</div><div class="line">		//...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>不需要在切入点代码中做任何修改，统一按相似性来切（比如类名，包名），属于<strong>非侵入式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//方法二：根据相似性统一切，不需要再使用注解标记了</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">	//...</div><div class="line">	followTextView.setOnClickListener(view -&gt; &#123;</div><div class="line">		//...</div><div class="line">	&#125;);</div><div class="line">	unFollowTextView.setOnClickListener(view -&gt; &#123;</div><div class="line">		//...</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Aspect</div><div class="line">public class AspectTest &#123;</div><div class="line">	@Around(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</div><div class="line">	public void onClickLitener(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</div><div class="line">		//...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="5-AspectJ-和-APT-最大的不同"><a href="#5-AspectJ-和-APT-最大的不同" class="headerlink" title="5. AspectJ 和 APT 最大的不同"></a>5. AspectJ 和 APT 最大的不同</h4><p>APT 决定是否使用切面的权利仍然在业务代码中，而 AspectJ 将决定是否使用切面的权利还给了切面。在写切面的时候就可以决定哪些类的哪些方法会被代理，从逻辑上不需要侵入业务代码。</p>
<p>但是AspectJ 的使用需要匹配一些明确的 Join Points，如果 Join Points 的函数命名、所在包位置等因素改变了，对应的匹配规则没有跟着改变，就有可能导致匹配不到指定的内容而无法在该地方插入自己想要的功能。</p>
<p>那 AspectJ 的执行原理是什么？注入的代码和目标代码是怎么连接的？下一篇我将会详细讲讲，先挖个坑，跑路。</p>
<h2 id="三、应用篇"><a href="#三、应用篇" class="headerlink" title="三、应用篇"></a>三、应用篇</h2><hr>
<h3 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h3><p>为什么用 Javassist 来实践？因为实践过程中我们可以顺带掌握字节码插桩的技术基础，就算是后续学习热修复、应用 ASM，基础都是通用的。虽然 Javassist 性能比 ASM 低，但对新手很友好，操纵字节码却不需要直接接触字节码技术和了解虚拟机指令。</p>
<p>在上手之前，我们先了解几个概念：</p>
<h4 id="1-入门概念"><a href="#1-入门概念" class="headerlink" title="1. 入门概念"></a>1. 入门概念</h4><h5 id="（1）Gradle"><a href="#（1）Gradle" class="headerlink" title="（1）Gradle"></a>（1）Gradle</h5><p>Javassist 修改对象是编译后的 class 字节码。那<strong>首先我们得知道什么时候编译完成</strong>，才能在 .class 文件被转为 .dex 文件之前去做修改。</p>
<p>大多 Android 项目使用 Gradle 构建，我们需要先理解 Gradle 的工作流程。<strong>Gradle 是通过一个一个 Task 执行完成整个流程的</strong>，依次执行完 Task 后，项目就打包完成了。 其实 Gradle 就是一个装载 Task 的脚本容器。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-a5038496c2c37f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Task执行流程"></p>
<h5 id="（2）-Plugin"><a href="#（2）-Plugin" class="headerlink" title="（2） Plugin"></a>（2） Plugin</h5><p>那 Gralde 里面那么多 Task 是怎么来的呢，谁定义的呢？是Plugin！</p>
<p>我们回忆下，在 app module 的 build.gradle 文件中的第一行，往往会有 <code>apply plugin : &#39;com.android.application&#39;</code>，lib 的 build.gradle 则会有 <code>apply plugin : &#39;com.android.library&#39;</code>，就是 Plugin 为项目构建提供了 Task，不同的 plugin 里注册的 Task 不一样，使用不同 plugin，module 的功能也就不一样。</p>
<p>可以简单地理解为， Gradle 只是一个框架，真正起作用的是 plugin，是<strong>plugin 往 Gradle 脚本中添加 Task</strong>。 </p>
<h5 id="（3）Task"><a href="#（3）Task" class="headerlink" title="（3）Task"></a>（3）Task</h5><p>思考一下，如果一个 Task 的职责是将 .java 编译成 .class，这个 Task 是不是要先拿到 java 文件的目录？处理完成后还要告诉下一个 Task class 的目录？</p>
<p>没错，从 Task 执行流程图可以看出，Task 有一个重要的概念：inputs 和 outputs。<br>Task 通过 inputs 拿到一些需要的参数，处理完毕之后就输出 outputs，而下一个 Task 的 inputs 则是上一个 Task 的outputs。</p>
<p>这些 Task 其中肯定也有将所有 class 打包成 dex 的 Task，那我们要怎么找到这个 Task ？在之前插入我们自己的 Task 做代码注入呢？用 Transfrom！</p>
<h5 id="（4）Transform"><a href="#（4）Transform" class="headerlink" title="（4）Transform"></a>（4）Transform</h5><p>Transfrom 是 Gradle 1.5以上新出的一个 API，其实它也是 Task。 </p>
<ul>
<li><p>gradle plugin 1.5 以下，preDex 这个 Task 会将依赖的 module 编译后的 class 打包成 jar，然后 dex 这个 Task 则会将所有 class 打包成dex；</p>
<p>想要监听项目被打包成 .dex 的时机，就必须自定义一个 Gradle Task，插入到 predex 或者 dex 之前，在这个自定义的 Task 中使用 Javassist ca class 。  </p>
</li>
<li><p>gradle plugin 1.5 以上，preDex 和 Dex 这两个 Task 已经被 TransfromClassesWithDexForDebug 取代</p>
<p>Transform 更为方便，我们不再需要插入到某个 Task 前面。Tranfrom 有<strong>自己的执行时机</strong>，<strong>一经注册便会自动添加</strong>到 Task 执行序列中，且正好是 class 被打包成dex之前，所以我们自定义一个 Transform 即可。</p>
</li>
</ul>
<h5 id="（5）Groovy"><a href="#（5）Groovy" class="headerlink" title="（5）Groovy"></a>（5）Groovy</h5><ol>
<li>Gradle 使用 Groovy  语言实现，想要自定义 Gradle 插件就需要使用 Groovy  语言。</li>
<li>Groovy 语言 = Java语言的扩展 + 众多脚本语言的语法，运行在 JVM 虚拟机上，可以与 Java 无缝对接。Java 开发者学习 Groovy 的成本并不高。</li>
</ol>
<h4 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h4><p>所以我们需要怎么做？流程总结如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-3cdc258ea6d0876f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Javassist应用流程"></p>
<h4 id="3-实战-——-自动TryCatch"><a href="#3-实战-——-自动TryCatch" class="headerlink" title="3. 实战 —— 自动TryCatch"></a>3. 实战 —— 自动TryCatch</h4><p><img src="https://upload-images.jianshu.io/upload_images/3167794-071016dbac374c23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码里到处都是防范性catch"></p>
<p>既然说了这么多，是时候实战了，每次看到项目代码里充斥着防范性 try-catch，我就</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-a382b43c785a6513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们照着流程图，一步步来实现这个自动 try-Catch 功能：</p>
<h5 id="（1）自定义-Plugin"><a href="#（1）自定义-Plugin" class="headerlink" title="（1）自定义 Plugin"></a>（1）自定义 Plugin</h5><ol>
<li>新建一个 module，选择 library module，<strong>module 名字必须为 buildSrc</strong> </li>
<li>删除 module 下所有文件，build.gradle 配置替换如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;groovy&apos;</div><div class="line"></div><div class="line">repositories &#123;</div><div class="line">    jcenter()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.android.tools.build:gradle:2.3.3&apos;</div><div class="line">    compile &apos;org.javassist:javassist:3.20.0-GA&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>新建 groovy 目录<br><img src="https://upload-images.jianshu.io/upload_images/3167794-e875b3adfb55e534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>新建 Plugin 类</p>
</li>
</ol>
<p>需要注意： groovy 目录下新建类，需要选择 file且以<code>.groovy</code>作为文件格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import org.gradle.api.Plugin</div><div class="line">import org.gradle.api.Project</div><div class="line">import com.android.build.gradle.AppExtension</div><div class="line"></div><div class="line">class PathPlugin implements Plugin&lt;Project&gt; &#123;</div><div class="line">    @Override</div><div class="line">    void apply(Project project) &#123;</div><div class="line">        project.logger.debug &quot;================自定义插件成功！==========&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了马上看到效果，我们提前走流程图中的步骤 4，在 app module下的 buiil.gradle 中添加 apply 插件。<br><img src="https://upload-images.jianshu.io/upload_images/3167794-5f2b1a6af8d6e14c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>跑一下：<br><img src="https://upload-images.jianshu.io/upload_images/3167794-b3ec8c6d0849f19d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="（2）自定义-Transfrom"><a href="#（2）自定义-Transfrom" class="headerlink" title="（2）自定义 Transfrom"></a>（2）自定义 Transfrom</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">import com.android.build.api.transform.*</div><div class="line">import com.android.build.gradle.internal.pipeline.TransformManager</div><div class="line">import org.apache.commons.codec.digest.DigestUtils</div><div class="line">import org.apache.commons.io.FileUtils</div><div class="line">import org.gradle.api.Project</div><div class="line"></div><div class="line">class PathTransform extends Transform &#123;</div><div class="line"></div><div class="line">    Project project</div><div class="line">    TransformOutputProvider outputProvider</div><div class="line"></div><div class="line">    // 构造函数中我们将Project对象保存一下备用</div><div class="line">    public PathTransform(Project project) &#123;</div><div class="line">        this.project = project</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 设置我们自定义的Transform对应的Task名称，TransfromClassesWithPreDexForXXXX</div><div class="line">    @Override</div><div class="line">    String getName() &#123;</div><div class="line">        return &quot;PathTransform&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //通过指定输入的类型指定我们要处理的文件类型</div><div class="line">    @Override</div><div class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</div><div class="line">        //指定处理所有class和jar的字节码</div><div class="line">        return TransformManager.CONTENT_CLASS</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 指定Transform的作用范围</div><div class="line">    @Override</div><div class="line">    Set&lt;QualifiedContent.Scope&gt; getScopes() &#123;</div><div class="line">        return TransformManager.SCOPE_FULL_PROJECT</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    boolean isIncremental() &#123;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</div><div class="line">        super.transform(transformInvocation)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void transform(Context context, Collection&lt;TransformInput&gt; inputs,</div><div class="line">                   Collection&lt;TransformInput&gt; referencedInputs,</div><div class="line">                   TransformOutputProvider outputProvider, boolean isIncremental)</div><div class="line">            throws IOException, TransformException, InterruptedException &#123;</div><div class="line">        this.outputProvider = outputProvider</div><div class="line">        traversalInputs(inputs)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Transform的inputs有两种类型:</div><div class="line">     *  一种是目录， DirectoryInput</div><div class="line">     *  一种是jar包，JarInput</div><div class="line">     *  要分开遍历</div><div class="line">     */</div><div class="line">    private ArrayList&lt;TransformInput&gt; traversalInputs(Collection&lt;TransformInput&gt; inputs) &#123;</div><div class="line">        inputs.each &#123;</div><div class="line">            TransformInput input -&gt;</div><div class="line">                traversalDirInputs(input)</div><div class="line">                traversalJarInputs(input)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 对类型为文件夹的input进行遍历</div><div class="line">     */</div><div class="line">    private ArrayList&lt;DirectoryInput&gt; traversalDirInputs(TransformInput input) &#123;</div><div class="line">        input.directoryInputs.each &#123;</div><div class="line">            /**</div><div class="line">             * 文件夹里面包含的是</div><div class="line">             *  我们手写的类</div><div class="line">             *  R.class、</div><div class="line">             *  BuildConfig.class</div><div class="line">             *  R$XXX.class</div><div class="line">             *  等</div><div class="line">             *  根据自己的需要对应处理</div><div class="line">             */</div><div class="line">            println(&quot;it == $&#123;it&#125;&quot;)</div><div class="line"></div><div class="line">            //TODO:这里可以注入代码！！</div><div class="line"></div><div class="line">            // 获取output目录</div><div class="line">            def dest = outputProvider.getContentLocation(it.name</div><div class="line">                    , it.contentTypes, it.scopes, Format.DIRECTORY)</div><div class="line"></div><div class="line">            // 将input的目录复制到output指定目录</div><div class="line">            FileUtils.copyDirectory(it.file, dest)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 对类型为jar文件的input进行遍历</div><div class="line">     */</div><div class="line">    private ArrayList&lt;JarInput&gt; traversalJarInputs(TransformInput input) &#123;</div><div class="line">		//没有对jar注入的需求，暂不扩展</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="（3）向自定义的-Plugin-注册-Transfrom"><a href="#（3）向自定义的-Plugin-注册-Transfrom" class="headerlink" title="（3）向自定义的 Plugin 注册 Transfrom"></a>（3）向自定义的 Plugin 注册 Transfrom</h5><p>回到我们刚刚定义的 PathPlugin，在 apply 方法中注册 PathTransfrom：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def android = project.extensions.findByType(AppExtension)</div><div class="line">android.registerTransform(new PathTransform(project))</div></pre></td></tr></table></figure></p>
<p>clean 项目，再跑一次，确保没有报错。</p>
<h5 id="（4）代码注入"><a href="#（4）代码注入" class="headerlink" title="（4）代码注入"></a>（4）代码注入</h5><p>接着就是重头戏了，我们新建一个 TryCatchInject 类，<strong>先把扫描到的方法和类名打印出来</strong>：</p>
<blockquote>
<p>这个类不同于前面定义的类，无需继承指定父类，无需实现指定方法，所以我以短方法+有表达力的命名代替了注释，如果有疑问请一定要反馈给我，我好反思是否写得不够清晰。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">import javassist.ClassPool</div><div class="line">import javassist.CtClass</div><div class="line">import javassist.CtConstructor</div><div class="line">import javassist.CtMethod</div><div class="line">import javassist.bytecode.AnnotationsAttribute</div><div class="line">import javassist.bytecode.MethodInfo</div><div class="line">import java.lang.annotation.Annotation</div><div class="line"></div><div class="line">class TryCatchInject &#123;</div><div class="line">    private static String path</div><div class="line">    private static ClassPool pool = ClassPool.getDefault()</div><div class="line">    private static final String CLASS_SUFFIX = &quot;.class&quot;</div><div class="line">	</div><div class="line">	//注入的入口</div><div class="line">    static void injectDir(String path, String packageName) &#123;</div><div class="line">        this.path = path</div><div class="line">        pool.appendClassPath(path)</div><div class="line">        traverseFile(packageName)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static traverseFile(String packageName) &#123;</div><div class="line">        File dir = new File(path)</div><div class="line">        if (!dir.isDirectory()) &#123;</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        beginTraverseFile(dir, packageName)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static beginTraverseFile(File dir, packageName) &#123;</div><div class="line">        dir.eachFileRecurse &#123; File file -&gt;</div><div class="line"></div><div class="line">            String filePath = file.absolutePath</div><div class="line">            if (isClassFile(filePath)) &#123;</div><div class="line">                int index = filePath.indexOf(packageName.replace(&quot;.&quot;, File.separator))</div><div class="line">                boolean isClassFilePath = index != -1</div><div class="line">                if (isClassFilePath) &#123;</div><div class="line">                    transformPathAndInjectCode(filePath, index)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static boolean isClassFile(String filePath) &#123;</div><div class="line">        return filePath.endsWith(&quot;.class&quot;) &amp;&amp; !filePath.contains(&apos;R&apos;) &amp;&amp; !filePath.contains(&apos;R.class&apos;) &amp;&amp; !filePath.contains(&quot;BuildConfig.class&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void transformPathAndInjectCode(String filePath, int index) &#123;</div><div class="line">        String className = getClassNameFromFilePath(filePath, index)</div><div class="line">        injectCode(className)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static String getClassNameFromFilePath(String filePath, int index) &#123;</div><div class="line">        int end = filePath.length() - CLASS_SUFFIX.length()</div><div class="line">        String className = filePath.substring(index, end).replace(&apos;\\&apos;, &apos;.&apos;).replace(&apos;/&apos;, &apos;.&apos;)</div><div class="line">        className</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void injectCode(String className) &#123;</div><div class="line">        CtClass c = pool.getCtClass(className)</div><div class="line">        println(&quot;CtClass:&quot; + c)</div><div class="line">        defrostClassIfFrozen(c)</div><div class="line">        traverseMethod(c)</div><div class="line"></div><div class="line">        c.writeFile(path)</div><div class="line">        c.detach()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void traverseMethod(CtClass c) &#123;</div><div class="line">        CtMethod[] methods = c.getDeclaredMethods()</div><div class="line">        for (ctMethod in methods) &#123;</div><div class="line">            println(&quot;ctMethod:&quot; + ctMethod)</div><div class="line">            //TODO: 这里可以对方法进行操作</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void defrostClassIfFrozen(CtClass c) &#123;</div><div class="line">        if (c.isFrozen()) &#123;</div><div class="line">            c.defrost()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在 PathTransfrom 里的 TODO 标记处调用注入类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//请注意把 com\\feelschaotic\\javassist 替换为自己想扫描的路径</div><div class="line"> TryCatchInject.injectDir(it.file.absolutePath, &quot;com\\feelschaotic\\javassist&quot;)</div></pre></td></tr></table></figure>
<p>我们再次 clean 后跑一下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-c030f6314d6c30ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印了扫描到的类和方法"></p>
<p>我们可以直接按方法的包名切，也可以按方法的标记切（比如：特殊的入参、方法签名、方法名、方法上的注解……），考虑到我们只需要对特定的方法捕获异常，我打算用自定义注解来标记方法。</p>
<p>在 app module 中<strong>定义一个注解</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//仅支持在方法上使用</div><div class="line">@Target(ElementType.METHOD)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface AutoTryCatch &#123;</div><div class="line">	//支持业务方catch指定异常</div><div class="line">    Class[] value() default Exception.class;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着我们要在 <code>TryCatchInject</code> 的 <code>traverseMethod</code>方法 TODO 中，使用 Javassist <strong>获取方法上的注解</strong>，<strong>再获取注解的 value</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">  private static void traverseMethod(CtClass c) &#123;</div><div class="line">       CtMethod[] methods = c.getDeclaredMethods()</div><div class="line">       for (ctMethod in methods) &#123;</div><div class="line">           println(&quot;ctMethod:&quot; + ctMethod)</div><div class="line">           traverseAnnotation(ctMethod)</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">private static void traverseAnnotation(CtMethod ctMethod) &#123;</div><div class="line">       Annotation[] annotations = ctMethod.getAnnotations()</div><div class="line"></div><div class="line">       for (annotation in annotations) &#123;</div><div class="line">           def canonicalName = annotation.annotationType().canonicalName</div><div class="line">           if (isSpecifiedAnnotation(canonicalName)) &#123;</div><div class="line">               onIsSpecifiedAnnotation(ctMethod, canonicalName)</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static boolean isSpecifiedAnnotation(String canonicalName) &#123;</div><div class="line">       PROCESSED_ANNOTATION_NAME.equals(canonicalName)</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static void onIsSpecifiedAnnotation(CtMethod ctMethod, String canonicalName) &#123;</div><div class="line">       MethodInfo methodInfo = ctMethod.getMethodInfo()</div><div class="line">       AnnotationsAttribute attribute = methodInfo.getAttribute(AnnotationsAttribute.visibleTag)</div><div class="line"></div><div class="line">       javassist.bytecode.annotation.Annotation javassistAnnotation = attribute.getAnnotation(canonicalName)</div><div class="line">       def names = javassistAnnotation.getMemberNames()</div><div class="line">       if (names == null || names.isEmpty()) &#123;</div><div class="line">           catchAllExceptions(ctMethod)</div><div class="line">           return</div><div class="line">       &#125;</div><div class="line">       catchSpecifiedExceptions(ctMethod, names, javassistAnnotation)</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static catchAllExceptions(CtMethod ctMethod) &#123;</div><div class="line">       CtClass etype = pool.get(&quot;java.lang.Exception&quot;)</div><div class="line">       ctMethod.addCatch(&apos;&#123;com.feelschaotic.javassist.Logger.print($e);return;&#125;&apos;, etype)</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static void catchSpecifiedExceptions(CtMethod ctMethod, Set names, javassist.bytecode.annotation.Annotation javassistAnnotation) &#123;</div><div class="line">       names.each &#123; def name -&gt;</div><div class="line"></div><div class="line">           ArrayMemberValue arrayMemberValues = (ArrayMemberValue) javassistAnnotation.getMemberValue(name)</div><div class="line">           if (arrayMemberValues == null) &#123;</div><div class="line">               return</div><div class="line">           &#125;</div><div class="line">           addMultiCatch(ctMethod, (ClassMemberValue[]) arrayMemberValues.getValue())</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static void addMultiCatch(CtMethod ctMethod, ClassMemberValue[] classMemberValues) &#123;</div><div class="line">       classMemberValues.each &#123; ClassMemberValue classMemberValue -&gt;</div><div class="line">           CtClass etype = pool.get(classMemberValue.value)</div><div class="line">           ctMethod.addCatch(&apos;&#123; com.feelschaotic.javassist.Logger.print($e);return;&#125;&apos;, etype)</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>完成！写个 demo 遛一遛：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-d65b79b3550b9622.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到应用没有崩溃，logcat 打印出异常了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-5c4f521259ef3f3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><a href="https://github.com/feelschaotic/AopAutoTryCatch" target="_blank" rel="external">完整demo请戳</a></p>
<blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr>
<p>完成本篇过程曲折，最终成稿已经完全偏离当初拟定的大纲，本来想详细记录下 AOP 的应用，把每种方法都一步步实践一遍，但在写作的过程中，我不断地质疑自己，这种步骤文全网都是，于自己于大家又有什么意义？ 想着把写作方向改为 AOP 开源库源码分析，但又难以避免陷入大段源码分析的泥潭中。</p>
<p>本文的初衷在于 AOP 的实践，既然是实践，何不抛弃语法细节，抽象流程，图示步骤，毕竟学习完能真正吸收的一是魔鬼的细节，二是精妙的思想。</p>
<p>写作本身就是一种思考，谨以警示自己。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3167794-d74bbee5d2e42039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AOP系列思维导图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3167794-01a9ab339f39ed7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;繁多的 AOP 方法该如何选择？应用的步骤过于繁琐，语法概念看得头晕脑胀？&lt;/p&gt;
&lt;p&gt;本文将详细展示选型种种考量维度，更是砍掉 2 个经典开源库的枝节，取其主干细细体会 AOP 的应用思想和关键流程。一边实践 AOP 一边还能掌握开源库，岂不快哉！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂-AOP---你想要的最全面-AOP-方法探讨</title>
    <link href="http://yoursite.com/2018/11/30/new/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-AOP---%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E6%9C%80%E5%85%A8%E9%9D%A2-AOP-%E6%96%B9%E6%B3%95%E6%8E%A2%E8%AE%A8/"/>
    <id>http://yoursite.com/2018/11/30/new/一文读懂-AOP---你想要的最全面-AOP-方法探讨/</id>
    <published>2018-11-30T14:59:00.000Z</published>
    <updated>2018-12-18T12:30:16.490Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3167794-597f0435e8aad920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AOP系列思维导图"></p>
<h2 id="前前言"><a href="#前前言" class="headerlink" title="前前言"></a>前前言</h2><p>相信大家在入门 AOP 时，常常被繁多的术语、方法和框架绕晕。AOP 好像有点耳熟？Javaseopt 是个什么？Javassist 又是啥？Dexposed、APT 也是 AOP？本篇将辅助你快速理清概念，掌握 AOP 思想，找到最适合自己业务场景的 AOP 方法。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上文 <a href="https://www.jianshu.com/p/0e31122c38f7" target="_blank" rel="external">也谈代码 —— 重构两年前的代码</a> 中，我们提到最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯 Java 对象实现。不同的领域之间用最不具有侵害性的「方面」或「类方面」工具整合起来。</p>
<p>反思自己的项目，有很多模块没有做到恰当地切分关注面，往往在业务逻辑中耦合了业务埋点、权限申请、登陆状态的判断、对不可预知异常 try-catch 和一些持久化操作。</p>
<p>虽说保证代码最简单化和可运行化很有必要，但我们还是可以尝试小范围的重构。就如「代码整洁之道」中所说：通过方面式的手段切分关注面的威力不可低估，假如你能用 POJO 编写应用程序的领域逻辑，在代码层面与架构关注面分离开，就有可能真正地用测试来驱动架构。</p>
<p>这里的切分关注面的思想就是 AOP。</p>
<hr>
<h2 id="一、AOP即面向切向编程"><a href="#一、AOP即面向切向编程" class="headerlink" title="一、AOP即面向切向编程"></a>一、AOP即面向切向编程</h2><p>AOP 是 Aspect Oriented Programming 的缩写，译为面向切向编程。用我们最常用的 OOP 来对比理解：</p>
<h3 id="纵向关系-OOP，横向角度-AOP"><a href="#纵向关系-OOP，横向角度-AOP" class="headerlink" title="纵向关系 OOP，横向角度 AOP"></a>纵向关系 OOP，横向角度 AOP</h3><p>举个小例子：</p>
<p>设计一个日志打印模块。按 OOP 思想，我们会设计一个打印日志 LogUtils 类，然后在需要打印的地方引用即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ClassA &#123;</div><div class="line">    private void initView() &#123;</div><div class="line">        LogUtils.d(TAG, &quot;onInitView&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ClassB &#123;</div><div class="line">    private void onDataComplete(Bean bean) &#123;</div><div class="line">        LogUtils.d(TAG, bean.attribute);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ClassC &#123;</div><div class="line">    private void onError() &#123;</div><div class="line">        LogUtils.e(TAG, &quot;onError&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起来没有任何问题是吧？</p>
<p>但是这个类是横跨并嵌入众多模块里的，在各个模块里分散得很厉害，到处都能见到。从对象组织角度来讲，我们一般采用的分类方法都是使用类似生物学分类的方法，以「继承」关系为主线，我们称之为<strong>纵向</strong>，也就是 OOP。设计时只使用 OOP思想可能会带来两个问题：</p>
<ol>
<li><p>对象设计的时候一般都是纵向思维，如果这个时候考虑这些不同类对象的共性，不仅会增加设计的难度和复杂性，还会造成类的接口过多而难以维护（共性越多，意味着接口契约越多）。</p>
</li>
<li><p>需要对现有的对象 <strong>动态增加</strong> 某种行为或责任时非常困难。</p>
</li>
</ol>
<p>而AOP就可以很好地解决以上的问题，怎么做到的？除了这种纵向分类之外，我们从横向的角度去观察这些对象，无需再去到处调用 LogUtils 了，声明哪些地方需要打印日志，这个地方就是一个切面，AOP 会在适当的时机为你把打印语句插进切面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 只需要声明哪些方法需要打印 log，打印什么内容</div><div class="line">public class ClassA &#123;</div><div class="line">    @Log(msg = &quot;onInitView&quot;)</div><div class="line">    private void initView() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ClassB &#123;</div><div class="line">    @Log(msg = &quot;bean.attribute&quot;)</div><div class="line">    private void onDataComplete(Bean bean) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ClassC &#123;</div><div class="line">    @Log(msg = &quot;onError&quot;)</div><div class="line">    private void onError() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果说 OOP 是把问题划分到单个模块的话，那么 AOP 就是把涉及到众多模块的某一类问题进行统一管理。AOP的目标是把这些功能集中起来，放到一个统一的地方来控制和管理。利用 AOP 思想，这样对业务逻辑的各个部分进行了隔离，从而降低业务逻辑各部分之间的耦合，提高程序的可重用性，提高开发效率。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-1f38ddc163132a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="OOP-与-AOP-的区别"><a href="#OOP-与-AOP-的区别" class="headerlink" title="OOP 与 AOP 的区别"></a>OOP 与 AOP 的区别</h3><ol>
<li><p>面向目标不同：简单来说 OOP 是面向名词领域，AOP 面向动词领域。</p>
</li>
<li><p>思想结构不同：OOP 是纵向结构，AOP 是横向结构。</p>
</li>
<li><p>注重方面不同：OOP 注重业务逻辑单元的划分，AOP 偏重业务处理过程中的某个步骤或阶段。</p>
</li>
</ol>
<h3 id="OOP-与-AOP-的联系"><a href="#OOP-与-AOP-的联系" class="headerlink" title="OOP 与 AOP 的联系"></a>OOP 与 AOP 的联系</h3><p>两者之间是一个相互补充和完善的关系。</p>
<hr>
<h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><p>那AOP既然这么有用，除了上面提到的打印日志场景，还有没有其他用处呢？</p>
<p>当然有！</p>
<p>只要系统的业务模块都需要引用通用模块，就可以使用AOP。以下是一些常用的业务场景：</p>
<h4 id="1-参数校验和判空"><a href="#1-参数校验和判空" class="headerlink" title="1. 参数校验和判空"></a>1. 参数校验和判空</h4><p>系统之间在进行接口调用时，往往是有入参传递的，入参是接口业务逻辑实现的先决条件，有时入参的缺失或错误会导致业务逻辑的异常，大量的异常捕获无疑增加了接口实现的复杂度，也让代码显得雍肿冗长，因此提前对入参进行验证是有必要的，可以提前处理入参数据的异常，并封装好异常转化成结果对象返回给调用方，也让业务逻辑解耦变得独立。</p>
<h4 id="2-Android-API23-的权限控制"><a href="#2-Android-API23-的权限控制" class="headerlink" title="2. Android API23+的权限控制"></a>2. Android API23+的权限控制</h4><p>避免到处都是申请权限和处理权限的代码</p>
<h4 id="3-无痕埋点"><a href="#3-无痕埋点" class="headerlink" title="3. 无痕埋点"></a>3. 无痕埋点</h4><h4 id="4-安全控制"><a href="#4-安全控制" class="headerlink" title="4. 安全控制"></a>4. 安全控制</h4><p>比如全局的登录状态流程控制。</p>
<h4 id="5-日志记录"><a href="#5-日志记录" class="headerlink" title="5. 日志记录"></a>5. 日志记录</h4><h4 id="6-事件防抖"><a href="#6-事件防抖" class="headerlink" title="6. 事件防抖"></a>6. 事件防抖</h4><p>防止View被连续点击触发多次事件</p>
<h4 id="7-性能统计"><a href="#7-性能统计" class="headerlink" title="7. 性能统计"></a>7. 性能统计</h4><p>检测方法耗时其实已经有一些现成的工具，比如 trace view。痛点是这些工具使用起来都比较麻烦，效率低下，而且无法针对某一个块代码或者某个指定的sdk进行查看方法耗时。可以采用 AOP 思想对每个方法做一个切点，在执行之后打印方法耗时。</p>
<h4 id="8-事务处理"><a href="#8-事务处理" class="headerlink" title="8. 事务处理"></a>8. 事务处理</h4><p>声明方法，为特定方法加上事务，指定情况下（比如抛出异常）回滚事务</p>
<h4 id="9-异常处理"><a href="#9-异常处理" class="headerlink" title="9. 异常处理"></a>9. 异常处理</h4><p>替代防御性的 try-Catch。</p>
<h4 id="10-缓存"><a href="#10-缓存" class="headerlink" title="10. 缓存"></a>10. 缓存</h4><p>缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。</p>
<h4 id="11-软件破解"><a href="#11-软件破解" class="headerlink" title="11. 软件破解"></a>11. 软件破解</h4><p>使用 Hook 修改软件的验证类的判断逻辑。</p>
<h4 id="12-热修复"><a href="#12-热修复" class="headerlink" title="12. 热修复"></a>12. 热修复</h4><p>AOP 可以让我们在执行一个方法的前插入另一个方法，运用这个思路，我们可以把有 bug 的方法替换成我们下发的新方法。</p>
<hr>
<h2 id="三、AOP-方法"><a href="#三、AOP-方法" class="headerlink" title="三、AOP 方法"></a>三、AOP 方法</h2><blockquote>
<p>本篇为入门篇，重在理解 AOP 思想和应用，辅助你快速进行 AOP 方法选型，所以 AOP 方法这块暂不会深入原理和术语。</p>
</blockquote>
<p>Android AOP 常用的方法有 JNI HOOK 和 静态织入。</p>
<h3 id="动态织入-Hook-方式"><a href="#动态织入-Hook-方式" class="headerlink" title="动态织入 Hook 方式"></a>动态织入 Hook 方式</h3><p>在运行期，目标类加载后，为接口动态生成代理类，将切面植入到代理类中。相对于静态AOP更加灵活。但切入的关注点需要实现接口。对系统有一点性能影响。</p>
<ol>
<li><p>Dexposed</p>
</li>
<li><p>Xposed</p>
</li>
<li><p>epic<br>在 native 层修改 java method 对应的 native 指针</p>
</li>
</ol>
<h3 id="动态字节码生成"><a href="#动态字节码生成" class="headerlink" title="动态字节码生成"></a>动态字节码生成</h3><ol>
<li>Cglib + Dexmaker</li>
</ol>
<p>Cglib 是一个强大的,高性能的 Code 生成类库， 原理是在运行期间目标字节码加载后，通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。由于是通过子类来代理父类，因此不能代理被 final 字段修饰的方法。</p>
<p>但是 Cglib 有一个很致命的缺点：底层是采用著名的 ASM 字节码生成框架，使用字节码技术生成代理类，也就是通过操作字节码来生成的新的 .class 文件，而我们在 Android 中加载的是优化后的 .dex 文件，也就是说我们需要可以动态生成 .dex 文件代理类，因此 Cglib 不能在 Android 中直接使用。有大神根据 Dexmaker 框架（dex代码生成工具）来仿照 Cglib 库动态生成 .dex 文件，实现了类似于 Cglib 的 AOP 的功能。详细的用法可参考：<a href="http://blog.csdn.net/zhangke3016/article/details/71437287" target="_blank" rel="external">将cglib动态代理思想带入Android开发</a></p>
<h3 id="静态织入方式"><a href="#静态织入方式" class="headerlink" title="静态织入方式"></a>静态织入方式</h3><p>在编译期，切面直接以字节码的形式编译到目标字节码文件中。对系统无性能影响。但灵活性不够。</p>
<ol>
<li><p>APT</p>
</li>
<li><p>AspectJ</p>
</li>
<li><p>ASM</p>
</li>
<li><p>Javassist </p>
</li>
<li><p>DexMaker</p>
</li>
<li><p>ASMDEX </p>
</li>
</ol>
<p>这么多方法？有什么区别？</p>
<h3 id="方法作用期比对"><a href="#方法作用期比对" class="headerlink" title="方法作用期比对"></a>方法作用期比对</h3><p>一图胜千言</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-b8fb9cf1cd351540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AOP 方法作用时期比对.png"></p>
<p>AOP 是思想，上面的方法其实都是工具，只不过是插入时机和方式不同。</p>
<p>同：都可以织入逻辑，都体现了 AOP 思想<br>异：作用的时机不一样，且适用的注解的类型不一样。</p>
<h3 id="方法优缺点、难点比对"><a href="#方法优缺点、难点比对" class="headerlink" title="方法优缺点、难点比对"></a>方法优缺点、难点比对</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用时机</th>
<th>操作对象</th>
<th>优点</th>
<th>缺点</th>
<th>为了上手，我需要掌握什么？</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>APT</strong></td>
<td>编译期：还未编译为 class 时</td>
<td>.java 文件</td>
<td>1. 可以织入所有类；2. 编译期代理，减少运行时消耗</td>
<td>1. 需要使用 apt 编译器编译；2. 需要手动拼接代理的代码（可以使用 Javapoet 弥补）；3. 生成大量代理类</td>
<td>设计模式和解耦思想的灵活应用</td>
</tr>
<tr>
<td><strong>AspectJ</strong></td>
<td>编译期、加载时</td>
<td>.java 文件</td>
<td>功能强大，除了 hook 之外，还可以为目标类添加变量，接口。也有抽象，继承等各种更高级的玩法。</td>
<td>不够轻量级</td>
<td>复杂的语法，但掌握几个简单的，就能实现绝大多数场景</td>
<td></td>
</tr>
<tr>
<td><strong>Javassist</strong></td>
<td>编译期：class 还未编译为 dex 时或运行时</td>
<td>class 字节码</td>
<td>1. 减少了生成子类的开销；2. 直接操作修改编译后的字节码，直接绕过了java编译器，所以可以做很多突破限制的事情，例如，跨 dex 引用，解决热修复中 CLASS_ISPREVERIFIED 问题。</td>
<td>运行时加入切面逻辑，产生性能开销。</td>
<td>1. 自定义 Gradle 插件；2. 掌握groovy 语言</td>
<td></td>
</tr>
<tr>
<td><strong>ASM</strong></td>
<td>编译期或运行期字节码注入</td>
<td>class 字节码</td>
<td>小巧轻便、性能好，效率比Javassist高</td>
<td>学习成本高</td>
<td>需要熟悉字节码语法，ASM 通过树这种数据结构来表示复杂的字节码结构，并利用 Push 模型来对树进行遍历，在遍历过程中对字节码进行修改。</td>
</tr>
<tr>
<td><strong>ASMDEX</strong></td>
<td>编译期和加载时：转化为 .dex 后</td>
<td>Dex 字节码，创建 class 文件</td>
<td>可以织入所有类</td>
<td>学习成本高</td>
<td>需要对 class 文件比较熟悉，编写过程复杂。</td>
</tr>
<tr>
<td><strong>DexMaker</strong></td>
<td>同ASMDEX</td>
<td>Dex 字节码，创建 dex 文件</td>
<td>同ASMDEX</td>
<td>同ASMDEX</td>
<td>同ASMDEX</td>
</tr>
<tr>
<td><strong>Cglib</strong></td>
<td>运行期生成子类拦截方法</td>
<td>字节码</td>
<td>没有接口也可以织入</td>
<td>1. 不能代理被final字段修饰的方法；2. 需要和 dexmaker 结合使用</td>
<td>–</td>
</tr>
<tr>
<td><strong>xposed</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>能hook自己应用进程的方法，能hook其他应用的方法，能hook系统的方法</td>
<td>依赖三方包的支持，兼容性差，手机需要root</td>
<td>–</td>
</tr>
<tr>
<td><strong>dexposed</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>只能hook自己应用进程的方法，但无需root</td>
<td>1. 依赖三方包的支持，兼容性差；2. 只能支持 Dalvik 虚拟机</td>
<td>–</td>
</tr>
<tr>
<td><strong>epic</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>支持 Dalvik 和 Art 虚拟机</td>
<td>只适合在开发调试中使用，碎片化严重有兼容性问题</td>
<td>–</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四、常用的-AOP-方法介绍"><a href="#四、常用的-AOP-方法介绍" class="headerlink" title="四、常用的 AOP 方法介绍"></a>四、常用的 AOP 方法介绍</h2><p>业务中常用的 AOP 方式为静态织入，接下来详细介绍静态织入中最常用的三种方式：APT、AspectJ、Javassist。</p>
<h3 id="1-APT"><a href="#1-APT" class="headerlink" title="1. APT"></a>1. APT</h3><p>APT （Annotation Processing Tool ）即注解处理器，是一种处理注解的工具，确切的说它是 javac 的一个工具，它用来在编译时扫描和处理注解。注解处理器以 Java 代码（ 或者编译过的字节码）作为输入，生成 .java 文件作为输出。简单来说就是在编译期，通过注解生成 .java 文件。使用的 Annotation 类型是 SOURCE。 </p>
<p>代表框架：DataBinding、Dagger2、ButterKnife、EventBus3、DBFlow、AndroidAnnotation</p>
<h5 id="为什么这些框架注解实现-AOP-要使用-APT？"><a href="#为什么这些框架注解实现-AOP-要使用-APT？" class="headerlink" title="为什么这些框架注解实现 AOP 要使用 APT？"></a>为什么这些框架注解实现 AOP 要使用 APT？</h5><p>目前 Android 注解解析框架主要有两种实现方法，一种是运行期通过反射去解析当前类，注入相应要运行的方法。另一种是在编译期生成类的代理类，在运行期直接调用代理类的代理方法，APT 指的是后者。</p>
<p>如果不使用APT基于注解动态生成 java 代码，那么就需要在运行时使用反射或者动态代理，比如大名鼎鼎的 butterknife 之前就是在运行时反射处理注解，为我们实例化控件并添加事件，然而这种方法很大的一个缺点就是用了反射，导致 app 性能下降。所以后面 butterknife 改为 apt 的方式，可以留意到，butterknife 会在编译期间生成一个 <code>XXX_ViewBinding.java</code>。虽然 APT 增加了代码量，但是不再需要用反射，也就无损性能。</p>
<h5 id="APT-的缺点改进"><a href="#APT-的缺点改进" class="headerlink" title="APT 的缺点改进"></a>APT 的缺点改进</h5><p>性能问题解决了，又带来新的问题了。我们在处理注解或元数据文件的时候，往往有自动生成源代码的需要。难道我们要手动拼接源代码吗？不不不，这不符合代码的优雅，JavaPoet 这个神器就是来解决这个问题的。</p>
<h5 id="JavaPoet"><a href="#JavaPoet" class="headerlink" title="JavaPoet"></a><a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a></h5><p>JavaPoet 是 square 推出的开源 java 代码生成框架，提供 Java Api 生成 .java 源文件。这个框架功能非常有用，我们可以很方便的使用它根据注解、数据库模式、协议格式等来对应生成代码。通过这种自动化生成代码的方式，可以让我们用更加简洁优雅的方式要替代繁琐冗杂的重复工作。本质上就是用建造者模式来替代手工拼写源文件。</p>
<p>JavaPoet详细用法可参考：<a href="https://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="external">javapoet——让你从重复无聊的代码中解放出来</a></p>
<h3 id="2-AspectJ"><a href="#2-AspectJ" class="headerlink" title="2. AspectJ"></a>2. AspectJ</h3><p>目前最好、最方便、最火的 AOP 实现方式当属 AspectJ，它是一种几乎和 Java 完全一样的语言，而且完全兼容 Java。</p>
<p>但是在 Android 上集成 AspectJ 是比较复杂的。</p>
<p>我们需要使用 andorid-library gradle 插件在编译时做一些 hook。使用 AspectJ 的编译器（ajc，一个java编译器的扩展）对所有受 aspect 影响的类进行织入。在 gradle 的编译 task 中增加一些额外配置，使之能正确编译运行。等等等等……</p>
<p>有很多库帮助我们完成这些工作，可以方便快捷接入 AspectJ。</p>
<h4 id="AspectJ-框架选型"><a href="#AspectJ-框架选型" class="headerlink" title="AspectJ 框架选型"></a>AspectJ 框架选型</h4><table>
<thead>
<tr>
<th style="text-align:left">库</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">兼容性</th>
<th style="text-align:left">缺点</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><a href="https://github.com/JakeWharton/hugo" target="_blank" rel="external">Hugo</a></strong></td>
<td style="text-align:left">131kb</td>
<td style="text-align:left">–</td>
<td style="text-align:left">不支持AAR或JAR切入</td>
<td style="text-align:left">–</td>
</tr>
<tr>
<td style="text-align:left"><strong>gradle-android-aspectj-plugin</strong></td>
<td style="text-align:left">–</td>
<td style="text-align:left">–</td>
<td style="text-align:left">无法兼容databinding，不支持AAR或JAR切入</td>
<td style="text-align:left">该库已经弃用</td>
</tr>
<tr>
<td style="text-align:left"><strong><a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="external">AspectJx</a></strong>（推荐）</td>
<td style="text-align:left">44kb</td>
<td style="text-align:left">会和有transform功能的插件冲突，如：retroLambda</td>
<td style="text-align:left">在前两者基础上扩展支持AAR, JAR及Kotlin的应用</td>
<td style="text-align:left">仅支持annotation的方式，不支持 *.aj 文件的编译</td>
</tr>
</tbody>
</table>
<h3 id="3-Javassist"><a href="#3-Javassist" class="headerlink" title="3. Javassist"></a>3. Javassist</h3><p>代表框架：热修复框架HotFix 、Savior（InstantRun）</p>
<p>Javassist 是一个编辑字节码的框架，作用是修改编译后的 class 字节码，ASM也有这个功能，不过 Javassist 的 Java 风格 API 要比 ASM 更容易上手。</p>
<p>既然是修改编译后的 class 字节码，首先我们得知道什么时候编译完成，并且我们要在 .class文件被转为 .dex 文件之前去做修改。在 Gradle Transfrom 这个 api 出来之前，想要监听项目被打包成 .dex 的时机，就必须自定义一个 Gradle Task，插入到 predex 或者 dex 之前，在这个自定义的 Task 中使用 Javassist 或者 ASM 对 class 字节码进行操作。而 Transform 更为方便，我们不再需要插入到某个Task前面。Tranfrom 有自己的执行时机，一经注册便会自动添加到 Task 执行序列中，且正好是 class 被打包成dex之前。</p>
<hr>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>AOP 重在理解这种思想：</p>
<ol>
<li>先考虑要在什么期间插入代码，选用合适的 AOP 方法；</li>
<li>找准切入点也就是代码可注入的点，比如一个方法的调用处或者方法内部；</li>
<li>接着考虑怎么过滤方法，找到注入点的描述，比如注入到所有onClick方法：call(* view.onClick(..))；</li>
<li>接着要考虑以怎样的方式处理代码，是在代码执行前？执行后？还是包裹代码？还是替换目标代码？</li>
</ol>
<p>任何的技术都需要有业务依托和落地，后续将会推出AOP实践篇，一步步实现 AOP 应用落地，敬请期待。</p>
<hr>
<h2 id="六、还想了解更多？"><a href="#六、还想了解更多？" class="headerlink" title="六、还想了解更多？"></a>六、还想了解更多？</h2><h3 id="博文推荐"><a href="#博文推荐" class="headerlink" title="博文推荐"></a>博文推荐</h3><blockquote>
<ul>
<li><a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="external">深入理解Android之AOP</a></li>
<li><a href="https://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/" target="_blank" rel="external">Aspect Oriented Programming in Android</a></li>
<li><a href="https://www.jianshu.com/p/0fa8073fd144" target="_blank" rel="external">Aspect Oriented Programming in Android 翻译版</a></li>
<li><a href="https://www.jianshu.com/p/dca3e2c8608a" target="_blank" rel="external">安卓AOP三剑客:APT,AspectJ,Javassist</a></li>
</ul>
</blockquote>
<h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><blockquote>
<ul>
<li><a href="">Manning.AspectJ.in.Action第二版</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3167794-597f0435e8aad920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AOP系列思维导图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前前言&quot;&gt;&lt;a href=&quot;#前前言&quot; class=&quot;headerlink&quot; title=&quot;前前言&quot;&gt;&lt;/a&gt;前前言&lt;/h2&gt;&lt;p&gt;相信大家在入门 AOP 时，常常被繁多的术语、方法和框架绕晕。AOP 好像有点耳熟？Javaseopt 是个什么？Javassist 又是啥？Dexposed、APT 也是 AOP？本篇将辅助你快速理清概念，掌握 AOP 思想，找到最适合自己业务场景的 AOP 方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>也谈代码-——-重构两年前的代码</title>
    <link href="http://yoursite.com/2018/10/30/new/%E4%B9%9F%E8%B0%88%E4%BB%A3%E7%A0%81-%E2%80%94%E2%80%94-%E9%87%8D%E6%9E%84%E4%B8%A4%E5%B9%B4%E5%89%8D%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2018/10/30/new/也谈代码-——-重构两年前的代码/</id>
    <published>2018-10-30T02:51:00.000Z</published>
    <updated>2018-12-18T12:30:12.026Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3167794-dd426ac06c0a166d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="为什么我们谈论代码？"><a href="#为什么我们谈论代码？" class="headerlink" title="为什么我们谈论代码？"></a>为什么我们谈论代码？</h2><p>也许有人会认为，谈论代码已经有点落后了——代码不再是问题，我们应当关注模型、需求、功能设计上。运用 Google 的自动编程框架 AutoML 和UIzard 的 pix2code就可以自动生成代码，看起来我们正在临近代码的终结点。 </p>
<p>但是，注意但是！我们永远无法抛弃代码， 就算语言继续抽象，领域特定语言数量继续增加，也终结不了代码。因为代码呈现了需求的细节，这些细节无法被忽略或抽象，必须明确之。将需求明确到机器可以执行的细节程度，就是编程要做的事。 </p>
<p>我们可以创造各种与需求接近的语言，我们可以创造帮助把需求解析和汇整为框架结构的各种工具。<strong>然而，我们永远无法抛弃需求中的精确性和细节 —— 所以代码永存。</strong></p>
<a id="more"></a>
<h2 id="为什么我们总是在写烂代码？"><a href="#为什么我们总是在写烂代码？" class="headerlink" title="为什么我们总是在写烂代码？"></a>为什么我们总是在写烂代码？</h2><p>有的人是因为大量的业务工作导致失去思考，有的人则是把提高代码质量寄希望于重构，但是往往在写烂代码的人不知道自己写的就是烂代码，他们没有掌握好代码的技巧，或者根本没有见过好代码，从而不知道什么是好的实践。</p>
<p>针对这种情况，下面会介绍好代码的特性和重构的技巧。从一个小的命名规范开始、逐步讲到函数、再到类、再到模块单元、乃至整个设计。</p>
<h2 id="培养你的代码感"><a href="#培养你的代码感" class="headerlink" title="培养你的代码感"></a>培养你的代码感</h2><p>就好像好的读者不一定是好的作者，能分辨整洁代码和肮脏代码，也不意味着会写整洁代码。</p>
<p>写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的「代码感」。这种「代码感」就是关键所在。有些人生而有之，有些人费点劲才能得到。缺乏「代码感」的程序员，看混乱是混乱，无处着手。有「代码感」的程序员才能从混乱中看出其他的可能与变化，选出最好的方案。</p>
<p><strong>想要得到「代码感」，最根本的途径是反复练习</strong>，接下来我将介绍大量的重构技巧和 demo ，强烈建议你在阅读时带上思考，对照自己的代码。</p>
<h2 id="好代码需要遵循什么？重构有哪些技巧？"><a href="#好代码需要遵循什么？重构有哪些技巧？" class="headerlink" title="好代码需要遵循什么？重构有哪些技巧？"></a>好代码需要遵循什么？重构有哪些技巧？</h2><h3 id="技巧一：起一个清晰、合理、有意义的命名"><a href="#技巧一：起一个清晰、合理、有意义的命名" class="headerlink" title="技巧一：起一个清晰、合理、有意义的命名"></a>技巧一：起一个清晰、合理、有意义的命名</h3><p>有意义的命名是体现表达力的一种方式。</p>
<ul>
<li><p>方法名应当是<strong>动词</strong>或动词短语，表达你的意图。如 deletePage 或 savePage。</p>
</li>
<li><p>类名和对象名应该是<strong>名词</strong>或名词短语。如 Customer、WikiPage、Account和AddressParser。</p>
</li>
<li><p>不要以数字来命名，除非是 <code>changeJson2Map()</code> 这种情况。</p>
</li>
<li><p>单字母名称仅用于短方法中的本地变量。比如循环体内的 i，但是你不应该在类变量里使用 i ，<strong>名称长短应与其作用域大小相对应</strong>。</p>
</li>
<li><p>别给名称添加不必要的语境。 对于 Address 类的实体来说，AccountAddress 和 CustomerAddress 都是不错的名称，不过用在类名上就不太好了。</p>
</li>
<li><p>遵循专业的术语。如果名词无法用英文表达，一定要用中文拼音，则<strong>不能用拼音缩写</strong>。</p>
</li>
</ul>
<p>命名我往往会修改好几次才会定下名字来，借助 IDE 重命名的代价极低，所以当你遇到不合理的命名时，不要畏惧麻烦，直接修改吧！</p>
<h3 id="技巧二：保持函数短小、少的入参、同一抽象层级"><a href="#技巧二：保持函数短小、少的入参、同一抽象层级" class="headerlink" title="技巧二：保持函数短小、少的入参、同一抽象层级"></a>技巧二：保持函数短小、少的入参、同一抽象层级</h3><p>我们都知道函数要尽量短小，职责要单一。但是你有没有忽视过其他的问题？</p>
<p>来看下这段糟糕的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private String url;</div><div class="line">private void startDownload(boolean isFormat, String userChannel, String userLevel, String regSource) &#123;</div><div class="line">	if (isFormat) &#123;</div><div class="line">		url = String.format(URL, userChannel, userLevel, regSource);</div><div class="line">		if (url.length() != 0) &#123;</div><div class="line">			service.getData(url)</div><div class="line">			.onSuccess(new Action() &#123;</div><div class="line">				Toast.showToast(context, &quot;success&quot;).show();</div><div class="line">			&#125;).onError(new Action() &#123;</div><div class="line">				Toast.showToast(context, &quot;error&quot;).show();</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		// ...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码至少犯了 4 个错误：</p>
<ol>
<li><p>用了标识参数 <code>isFormat</code>，这样方法签名立刻变得复杂起来，也表示了函数不止做一件事情，这应该把函数一分为二。</p>
</li>
<li><p>使用了多元参数。如果函数需要两个、三个或三个以上的参数，就说明其中一些参数应该封装成类了。</p>
</li>
<li><p>使用了输出参数 <code>url</code>，输出参数比复杂的输入参数还要难以理解。读函数时，我们惯于认为信息通过参数输入函数，通过返回值从函数中输出。我们不期望信息通过参数输出，输出参数往往包含着陷阱。如果函数要对输入参数进行转换操作，转换结果就该体现为返回值上。</p>
<p> 例： <code>appendFooter(s);</code>这个函数是把 <code>s</code>添加到什么东西后面吗？或者它把什么东西添加到了 <code>s</code>后面？<code>s</code>是输入参数还是输出参数？如果是要给<code>s</code>添加个<code>Footer</code>，最好是这样设计：<code>s.appendFooter();</code> 。  </p>
</li>
<li><p>没有保持同一抽象层级。函数中混杂不同抽象层级，去拼接代码的同时又发起了网络请求，还处理了请求结果，这往往让人迷惑。</p>
</li>
</ol>
<p>思考下，你会怎么重构这段代码？</p>
<p>我们展示重构后的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">	private void startDownloadWhenNotFormat() &#123;</div><div class="line">		// ...</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void startDownloadWhenFormat() &#123;</div><div class="line">		UserProperty property = createUserProperty();</div><div class="line">		String url = jointUrl(property);</div><div class="line">		startDownload(url);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private UserProperty createUserProperty()&#123;</div><div class="line">		//...</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private String jointUrl(UserProperty property) &#123;</div><div class="line">		return String.format(URL</div><div class="line">                    , property.getUserChannel()</div><div class="line">                    , property.getUserLevel()</div><div class="line">                    , property.getRegSource());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void startDownload(String url) &#123;</div><div class="line">		if (url.isEmpty()) &#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		service.getData(url)</div><div class="line">		.onSuccess(new Action() &#123;</div><div class="line">			onGetDataSuccess();</div><div class="line">		&#125;).onError(new Action() &#123;</div><div class="line">			onGetDataError();</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">public class UserProperty &#123;</div><div class="line">	private String userChannel;</div><div class="line">	private String userLevel;</div><div class="line">	private String regSource;</div><div class="line">	//...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>阅读这样的代码你会觉得很舒服，代码拥有<strong>自顶向下的阅读顺序</strong>，主程序就像是一系列 TO 起头的段落，每一段都描述当前抽象层级，并引用位于下一抽象层级的后续 TO 起头段落，呈现出总-分的结构。</p>
<h3 id="技巧三：短小、单一权责、内聚的类，暴露操作，隐藏数据细节"><a href="#技巧三：短小、单一权责、内聚的类，暴露操作，隐藏数据细节" class="headerlink" title="技巧三：短小、单一权责、内聚的类，暴露操作，隐藏数据细节"></a>技巧三：短小、单一权责、内聚的类，暴露操作，隐藏数据细节</h3><p>类的名称其实就表现了权责，如果无法为某个类命以精确的名称，说明这个类太长了，就应该拆分为几个高内聚的小类。</p>
<p>那么怎么评估类的内聚性？类中的方法和变量互相依赖、互相结合成一个逻辑整体，如果类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</p>
<p>保持内聚性就会得到许多短小的类，仅仅是将较大的函数切分为小函数，就将导致更多的类出现。想想看一个有许多变量的大函数。你想把该函数中某一小部分拆解成单独的函数。不过，你想要拆出来的代码使用了该函数中声明的 4 个变量。是否必须将这 4 个变量都作为参数传递到新函数中去呢？ </p>
<p>完全没必要！只要将 4 个变量提升为类的实体变量，完全无需传递任何变量就能拆解代码了。将函数拆分为小块后，你会发现类也丧失了内聚性，因为堆积了越来越多被少量函数共享的实体变量。</p>
<p>等一下！如果有些函数想要共享某些变量，为什么不让它们拥有自己的类呢？当类的变量越来越多，且变量的无关性越来越大，就拆分它！ 所以，将大函数拆为许多小函数，往往也是将类拆分为多个小类的时机。</p>
<p>你以为这就结束了？停止你乱加取值器和赋值器的行为！<strong>我们不能暴露变量的数据细节和数据形态，应该以抽象形态表述数据。</strong></p>
<p>著名的得墨忒耳律认为：模块不应了解它所操作对象的内部情形，即每个单元（对象或方法）应当对其他单元只拥有有限的了解，不应该有链式调用。</p>
<p>哈？我们觉得方便的链式调用风格，实际上暴露了其他单元的内部细节？？</p>
<p>我认为是要区别情况来对待，链式调用风格比较整洁和有表现力，但是不能随意滥用，举个简单例子：</p>
<p><code>a.getB().getC().doSomething()</code>  这种链式调用就违反了得墨忒耳定律，如果把<code>a.getB().getC().doSomething()</code> 改成 <code>a.doSomething()</code>，仍然违反了得墨忒耳定律。因为<code>a</code>里面会有<code>b.getC().doSomething()</code>，所以 b 类中还应该有一个<code>doSomething()</code>方法去调用 c 的 <code>doSomething()</code>，<code>a.doSomething()</code>再来调用<code>b.doSomethine()</code>，<code>a</code>对<code>b</code>的具体实现不可知。</p>
<p>链式风格用在 <code>a.method1().method2().method3();</code>这种情况会比较合理。所以能不能用链式，需要看链的是一个类的内部还是不同类的连接。</p>
<h3 id="技巧四：分离不同的模块"><a href="#技巧四：分离不同的模块" class="headerlink" title="技巧四：分离不同的模块"></a>技巧四：分离不同的模块</h3><p>系统应将初始化过程和初始化之后的运行时逻辑分离开，但我们经常看到初始化的代码被混杂到运行时代码逻辑中。下面就是个典型的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public Service getService() &#123; </div><div class="line">	if (service == null) &#123;</div><div class="line">		service = new MyServiceImpl(...); </div><div class="line">	&#125;</div><div class="line">	return service; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会自以为很优雅，因为延迟了初始化，在真正用到对象之前，无需操心这种对象的构造，而且也保证永远不会返回 null 值。 </p>
<p>然而，就算我们不调用到<code>getService()</code>方法，MyServiceImpl 的依赖也需要导入，以保证顺利编译。 如果MyServiceImpl 是个重型对象，单元测试也会是个问题。我们必须给这些延迟初始化的对象指派恰当的测试替身（TEST DOUBLE） 或仿制对象（MOCK OBJECT）。</p>
<p>我们应当将这个初始化过程从正常的运行时逻辑中分离出来，方法有很多：</p>
<h4 id="1-交给-init-模块"><a href="#1-交给-init-模块" class="headerlink" title="1. 交给 init 模块"></a>1. 交给 init 模块</h4><p>将全部构造过程移到 init 模块中，设计其他模块时，无需关心对象是否已经构造，默认所有对象都已正确构造。</p>
<h4 id="2-抽象工厂方法"><a href="#2-抽象工厂方法" class="headerlink" title="2.  抽象工厂方法"></a>2.  抽象工厂方法</h4><p>系统其他模块与如何构建对象的细节是分离开的，它只拥有抽象工厂方法的接口，具体细节是由 init 这边的接口实现类实现的。但其他模块能完全控制实体何时创建，甚至能给构造器传递参数。</p>
<h4 id="3-依赖注入中的控制反转"><a href="#3-依赖注入中的控制反转" class="headerlink" title="3. 依赖注入中的控制反转"></a>3. 依赖注入中的控制反转</h4><p>  对象不负责实例化对自身的依赖，而是把工作移交给容器，实现控制的反转。比如 Android Dagger2 和 JavaEE Spring 都是这方面的实践。</p>
<h4 id="4-Builder-模式"><a href="#4-Builder-模式" class="headerlink" title="4. Builder 模式"></a>4. Builder 模式</h4><p>可以简单地把构造和构造的细节分离。</p>
<p>我们拆分了初始化和正常运行时逻辑，还有什么可以继续拆分的呢？</p>
<p>正常运行时逻辑除了业务逻辑，往往还混合了持久化、事务、打印日志、埋点等模块，如果说 OOP 是把问题划分到单个模块的话，那么 AOP 就是把涉及到众多模块的某一类问题进行统一管理。比如按 OOP 思想，设计一个打印日志 LogUtils 类，但是这个类是横跨并嵌入众多模块里的，在各个模块里分散得很厉害，到处都能见到。而利用 AOP 思想，我们无需再去到处调用 LogUtils 了，声明哪些方法需要打印日志，AOP 会在编译时把打印语句插进方法切面。AOP 思想有很多实践：</p>
<h4 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h4><p>代理适用于简单的情况，例如在单独的对象或类中包装方法调用。然而，JDK提供的动态代理仅能与接口协同工作。对于代理类，你得使用字节码操作库，比如CGLIB、ASM或Javassist 。</p>
<h4 id="2-AOP-框架"><a href="#2-AOP-框架" class="headerlink" title="2. AOP 框架"></a>2. AOP 框架</h4><p>把持久化工作用 AOP 交给容器，使用描述性配置文件或 API 或注解来声明你的意图，驱动依赖注入（DI）容器，DI容器再实体化主要对象，并按需将对象连接起来。</p>
<p>后续我将会单独谈谈Android中的 AOP 思想、框架选型和具体应用场景，敬请期待。</p>
<p>概言之， 最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯 Java 对象实现。不同的领域之间用最不具有侵害性的「方面」或「类方面」工具整合起来。</p>
<h3 id="技巧五：用异常代替错误码，但不传递异常，不传递-null"><a href="#技巧五：用异常代替错误码，但不传递异常，不传递-null" class="headerlink" title="技巧五：用异常代替错误码，但不传递异常，不传递 null"></a>技巧五：用异常代替错误码，但不传递异常，不传递 null</h3><p><code>if (deletePage(page) == SUCCESS)</code>，咋看之下好像没什么问题，但是返回错误码，就是在要求调用者立刻处理错误。你马上就会看到这样的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (deletePage(page) == SUCCESS) &#123;</div><div class="line">	mView.onSuccess();</div><div class="line">&#125; else &#123;</div><div class="line">	mView.onError();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>熟悉不？更恶心的是这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int code = deletePage(page);</div><div class="line">if (code == CODE_404) &#123;</div><div class="line">	mView.onError1();</div><div class="line">&#125; else if(code == CODE_403)&#123;</div><div class="line">	mView.onError2();</div><div class="line">&#125; else if(code == CODE_505)&#123;</div><div class="line">	mView.onError3();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你开始编写错误码时，请注意！这意味着你可能在代码中到处存在 <code>if(code == CODE)</code>，其他许多类都得导入和使用这个错误类。当错误类修改时，所有这些其他的类都需要重新编译。 而且，错误码和状态码一样，会引入大量的 if-else 和 switch，随着状态扩展，if 就像面条一样拉长。回忆一下，你是不是用了不同的 code 来区分不同的错误？不同的用户状态？不同的表现场景？</p>
<p>所以忠告有 2 点：</p>
<ol>
<li><p>使用异常替代返回错误码，将错误处理代码从主路径中分离</p>
</li>
<li><p>不仅仅分离错误处理代码，还要把 try-catch 代码块的主体部分抽离出来，另外形成函数，函数应该只做一件事。错误处理就是一件事。因此，处理错误的函数不该做其他事。</p>
</li>
</ol>
<p>重构后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void delete(Page page) &#123;</div><div class="line">	try &#123;</div><div class="line">		deletePageAndAllReferences(page);</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		logError(e);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void deletePageAndAllReferences(Page page) throws Exception &#123;</div><div class="line">	deletePage(page);</div><div class="line">	registry.deleteReference(page.name);</div><div class="line">	configKeys.deleteKey(page.name.makeKey());</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void logError(Exception e) &#123;</div><div class="line">	logger.log(e.getMessage());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在上例中，异常使我们把正常代码和错误代码隔离开来，但是我不建议你滥用异常，思考一下，如果你在低层的某个方法中抛出异常，而把 catch 放在高级层级，你就得在 catch 语句和抛出异常处之间的每个方法签名中声明该异常。每个调用这个函数的函数都要修改，捕获新异常，或在其签名中添加合适的throw子句。以此类推，最终得到的就是一个从最底端贯穿到最高端的修改链。封装完全被打破了，在抛出路径中的每个函数都要去了解下一层级的异常细节。</p>
<p>所以<strong>不要传递异常，在合适的地方，及时解决它</strong>！</p>
<p>还有另一种情况你经常看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">UserData userData = service.getUserData(url)；</div><div class="line">        if (userData != null) &#123;</div><div class="line">            if (userData.getUserName != null &amp;&amp; userData.getUserName.length &gt; 0) &#123;</div><div class="line">                userNameTextView.setText(userData.getUserName);</div><div class="line">            &#125; else &#123;</div><div class="line">                userNameTextView.setText(&quot;--&quot;);</div><div class="line">            &#125;</div><div class="line">            if (userData.getRegChannel != null &amp;&amp; userData.getRegChannel.length &gt; 0) &#123;</div><div class="line">                regChannelTextView.setText(userData.getRegChannel);</div><div class="line">            &#125; else &#123;</div><div class="line">                regChannelTextView.setText(&quot;WHAN&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>真是可怕！到处都是判空和特殊操作！<strong>如果你打算在方法中返回 null 值，不如抛出异常，或是返回空对象或特例对象。</strong>你可以学习<code>Collections.emptyList( )</code>的实现，创建一个类，把异常行为封装到特例对象中。</p>
<p>对付返回 null 的第三方 API 也是如此，我们可以用新方法包装这个 API，从而干掉判空。</p>
<h3 id="技巧六：保持边界整洁，掌控第三方代码"><a href="#技巧六：保持边界整洁，掌控第三方代码" class="headerlink" title="技巧六：保持边界整洁，掌控第三方代码"></a>技巧六：保持边界整洁，掌控第三方代码</h3><p>我们经常会使用第三方开源库，怎么将外来代码干净利落地整合进自己的代码中。是每个工程师需要掌握的技巧，我们希望每次替换库变得简单容易，所以首先要缩小库的引用范围！怎么缩小？</p>
<ol>
<li><p>封装：不直接调用第三方api，而是包装多一层，从而控制第三方代码的边界，业务代码只知道包装层，不关心工具类的具体实现细节。在你测试自己的代码时，打包也有助于模拟第三方调用。 打包的好处还在于你不必绑死在某个特定厂商的API 设计上。你可以定义自己感觉舒服的API。</p>
</li>
<li><p>使用 ADAPTER 模式</p>
</li>
</ol>
<p>代码整洁之道还提出个有意思的做法，为第三方代码编写学习性测试。</p>
<p>我们可以编写测试来遍览和理解第三方代码。在编写学习性测试中，我们通过核对试验来检测自己对 API 的理解程度。测试帮助我们聚焦于我们想从 API 得到的东西。</p>
<p>当第三方开源库发布了新版本，我们可以运行学习性测试，马上看到：程序包的行为有没有改变？是否与我们的需要兼容？是否影响了旧功能？</p>
<h3 id="技巧七：保持良好的垂直格式和水平格式"><a href="#技巧七：保持良好的垂直格式和水平格式" class="headerlink" title="技巧七：保持良好的垂直格式和水平格式"></a>技巧七：保持良好的垂直格式和水平格式</h3><p>垂直格式上</p>
<ol>
<li>最顶部展示高层次的概念和算法，细节往下渐次展开，越是细节和底层，就应该放在源文件的越底部。</li>
<li>紧密相关或相似的代码应该互相靠近，调用者应该尽可能放在被调用者的上面，实体变量要靠近调用处，相关性弱的代码用空行隔开。</li>
</ol>
<p>水平格式上</p>
<ol>
<li>代码不宜太宽，避免左右拖动滚动条的差劲体验。</li>
<li>用空格字符把相关性较弱的事物分隔开。</li>
<li>遵守缩进规则。</li>
</ol>
<h3 id="技巧八：为代码添加必要的注释，维护注释"><a href="#技巧八：为代码添加必要的注释，维护注释" class="headerlink" title="技巧八：为代码添加必要的注释，维护注释"></a>技巧八：为代码添加必要的注释，维护注释</h3><p>请注意，我说的是<strong>必要的</strong>注释，只有当代码无法自解释时，才需要注释。</p>
<p>好的代码可以实现自文档，自注释，只有差的代码才需要到处都注释。</p>
<p>如果你开始写注释了，就要思考下：是否代码有模糊不清的地方？命名是否有表达力？是否准确合理？函数是否职责过重，做了太多事情，所以你必须为这个函数写长长的注释？如果是这样，你应该重构代码，而不是写自认为对维护有帮助的注释。很多情况下只需要改下命名、拆分函数，就可以免去注释。</p>
<p>不要以为写完注释就完了，<strong>注释和代码一样，需要维护。</strong></p>
<h2 id="如何规避重构的风险？"><a href="#如何规避重构的风险？" class="headerlink" title="如何规避重构的风险？"></a>如何规避重构的风险？</h2><p>在写代码之前，<strong>强烈建议你先完成单元测试</strong>，然后一边实现功能一边调整单测覆盖场景。 </p>
<p>实现功能时，代码一开始都冗长而复杂，完成功能后，通过单元测试和验收测试，我们可以放心地重构代码，每改动一小块，就及时运行测试，看功能是否被破坏，不断分解函数、选用更好的名称、消除重复、切分关注面，模块化系统性关注面，缩小函数和类的尺寸，同时保持测试通过。</p>
<h2 id="如何保持代码的优雅？"><a href="#如何保持代码的优雅？" class="headerlink" title="如何保持代码的优雅？"></a>如何保持代码的优雅？</h2><p>只要遵循以下规则，代码就能变得优雅： </p>
<ol>
<li><p>编写更多的测试，用测试驱动设计和架构。<br>测试编写得越多，就越能持续走向编写较易测试的代码，持续走向简单的设计，系统就会越贴近 OOP 低耦合高内聚的目标。没有了测试，你就会失去保证生产代码可扩展的一切要素。正是单元测试让你的代码可扩展、可维护、可复用。原因很简单：有了测试，你就不担心对代码的修改！没有测试，每次修改都可能带来缺陷。无论架构多有扩展性，无论设计划分得有多好，没有了测试，你就很难做改动，因为你担忧改动会引入不可预知的缺陷。</p>
</li>
<li><p>保持重构，当加入新功能的时候，要思考是否合理，是否需要重构这个打开修改的模块。</p>
</li>
<li><p>不要重复，重复代码代表遗漏了抽象，重复代码可能成为函数或干脆抽成另一个类。</p>
</li>
<li><p>保持意图清晰，选用好的命名，短的函数和类，良好的单元测试提高代码的表达力。</p>
</li>
<li><p>尽可能减少类和方法的数量，避免一味死板地遵循以上 4 条原则，从而导致类和方法的膨胀。</p>
</li>
</ol>
<h2 id="开始重构，逐步改进"><a href="#开始重构，逐步改进" class="headerlink" title="开始重构，逐步改进"></a>开始重构，逐步改进</h2><p>衡量成长比较简便的方法，就是看三个月前，一年前，自己写的代码是不是傻逼，越觉得傻逼就成长越快；或者反过来，看三个月前，一年前的自己，是不是能胜任当下的工作，如果完全没问题那就是没有成长。</p>
<p>既然聊到代码规范和重构技巧，Talk is cheap. Show me the code. 就以自己两年前的代码为例，但当我拿起两年前的项目时……</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-8d5900460803d7ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>简单粗暴放上 gif，重构过程更直观。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-c107e49d3c39ec73.gif?imageMogr2/auto-orient/strip" alt="更换命名、干掉switch、拆分成子函数"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-67067c60d2b8ca1b.gif?imageMogr2/auto-orient/strip" alt="选用更准确的命名"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-0f39cd2600f50d3c.gif?imageMogr2/auto-orient/strip" alt="选用有表达力的命名"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-bcbe22f6c849dd71.gif?imageMogr2/auto-orient/strip" alt="按最少知道原则修改方法"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>技巧是可以学习掌握的，重点是有意识培养自己的代码感，培养解耦的思想。不要生搬硬套技巧，不要过度设计，选择当下最适合最简单的方案。</p>
<p>同时我们需要不断回顾自己写过的代码，如果觉得无需改动，要么是设计足够优秀，要么就是没有输入，没有成长。</p>
<p>如果你对自己有更高的要求，希望以下的资料可以帮助你。</p>
<h3 id="帮助你管理代码质量的工具"><a href="#帮助你管理代码质量的工具" class="headerlink" title="帮助你管理代码质量的工具"></a>帮助你管理代码质量的工具</h3><ul>
<li>SonarLint</li>
<li>阿里编码规范插件</li>
</ul>
<h3 id="更多方法论书籍"><a href="#更多方法论书籍" class="headerlink" title="更多方法论书籍"></a>更多方法论书籍</h3><ul>
<li>「重构-改善既有代码的设计」</li>
<li>「代码整洁之道」</li>
<li>「设计模式-可复用面向对象软件的基础」</li>
<li>「驯服烂代码」</li>
<li>「修改代码的艺术」</li>
<li>「编写可读代码的艺术」</li>
</ul>
<h3 id="有意思的网站"><a href="#有意思的网站" class="headerlink" title="有意思的网站"></a>有意思的网站</h3><ul>
<li><a href="https://refactoring.guru/" target="_blank" rel="external">https://refactoring.guru/</a></li>
</ul>
<h3 id="非常棒的博文"><a href="#非常棒的博文" class="headerlink" title="非常棒的博文"></a>非常棒的博文</h3><ul>
<li><a href="http://blog.2baxb.me/archives/1499" target="_blank" rel="external">关于烂代码的那些事</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3167794-dd426ac06c0a166d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么我们谈论代码？&quot;&gt;&lt;a href=&quot;#为什么我们谈论代码？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们谈论代码？&quot;&gt;&lt;/a&gt;为什么我们谈论代码？&lt;/h2&gt;&lt;p&gt;也许有人会认为，谈论代码已经有点落后了——代码不再是问题，我们应当关注模型、需求、功能设计上。运用 Google 的自动编程框架 AutoML 和UIzard 的 pix2code就可以自动生成代码，看起来我们正在临近代码的终结点。 &lt;/p&gt;
&lt;p&gt;但是，注意但是！我们永远无法抛弃代码， 就算语言继续抽象，领域特定语言数量继续增加，也终结不了代码。因为代码呈现了需求的细节，这些细节无法被忽略或抽象，必须明确之。将需求明确到机器可以执行的细节程度，就是编程要做的事。 &lt;/p&gt;
&lt;p&gt;我们可以创造各种与需求接近的语言，我们可以创造帮助把需求解析和汇整为框架结构的各种工具。&lt;strong&gt;然而，我们永远无法抛弃需求中的精确性和细节 —— 所以代码永存。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="代码质量" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>「听书」《疯传》---程序员也要懂点营销学</title>
    <link href="http://yoursite.com/2018/09/24/new/%E3%80%8C%E5%90%AC%E4%B9%A6%E3%80%8D%E3%80%8A%E7%96%AF%E4%BC%A0%E3%80%8B---%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%9F%E8%A6%81%E6%87%82%E7%82%B9%E8%90%A5%E9%94%80%E5%AD%A6/"/>
    <id>http://yoursite.com/2018/09/24/new/「听书」《疯传》---程序员也要懂点营销学/</id>
    <published>2018-09-24T09:02:00.000Z</published>
    <updated>2018-12-18T12:29:13.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3167794-f2ffc70cd1329b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="思维导图"></p>
<p>我们身处于这个信息大爆炸的自媒体时代，媒体和受众这两大信息传播要素之间的界限已然消失不见，我们既是信息的消费者，也是信息的生产者。</p>
<p>已经有案例表明，不少企业依旧想当然地用过去的经验来制定营销策略，其结果是花了大价钱、大力气却也只能换来大众的漠不关心。与之相反的是，有的人就能通过50美元的视频制作费，达到百万美元广告投入的效果；有的人用3.5万美元拍摄的DV电影，能实现2.87亿美元的票房收入……</p>
<p>营销人员不禁会问：“到底怎么了？”</p>
<p>这正是这本《疯传》所要回答的问题。不为别的，只因为我们的社会进入了后互联网时代，通过移动终端设备，信息已经从传统的自上而下层级结构的模型，转变为点对点网状结构模型。</p>
<a id="more"></a>
<p>从网络拓扑学里可以知道，当出现了网状结构后的信息系统，其信息不对称性得到了高度屏蔽，也就是说，信息在层级结构中是以线性传递的方式在进行，传播的数据量少、速度慢、范围窄、流向单一。在这个模型中，显然只要砸出大手笔广告费，制造出铺天盖地的广告「高压」，信息就会一骨碌地传递至公众处。</p>
<p>网状结构则不同，每一个人作为社交网络上的一个节点，除非信息对于其是有意义的，否则将会被人为地掐断；但一旦传播开来，就会爆发出链式反应的力量，数据量、速度和范围都是几何式地增长。</p>
<p>以前，各种官方性质的组织、媒体所散播的消息，尤其是那种冠冕堂皇的口号、自卖自夸的广告，不但让受众产生了审美疲劳，甚至产生了抵触心理。而基于网状结构的社交网络则不同，营销的信息是由个人亲身经历后的有感而发，好坏的评价就有了现身说法的味道，较之官方口号和广告，其真实度、可信度、客观度自然更高一筹，也就更能引起大家的疯传。</p>
<p>不仅仅我们需要了解网络疯传的原理，更重要的是思考如何也能策划、实施出疯传事件。作者在分析了数以万计的信息、思考和产品之后，给出了他的「六步杀」：6个共同原则，社交货币、诱导、情绪、公共性、实用性和故事性。</p>
<h5 id="社交货币"><a href="#社交货币" class="headerlink" title="社交货币"></a>社交货币</h5><p>人们乐于传递让自己有优越感的事件。这些事件就像货币，传播出去会获得和购物类似的畅快感，这是社交货币作用的因素。例如微信小游戏分享排名、菜谱类应用鼓励用户分享成果、健身类应用的用户分享减肥前后对比照等。</p>
<p>所以我们设计事件成为社交货币途径有三点：</p>
<p>1、增加事情的内在吸引力，使之成为卓越非常规之事。反常规，反常理，就能引起人们的讨论。</p>
<p>2、设计一个高质量的「游戏」，让人们去炫耀。</p>
<p>3、运用产品和服务的稀缺性、专用性的特点，聚拢一批客户成为会员，让他们更有归属感，进一步激发传播，像常见的会员邀请制度，只有老会员才能邀请新会员注册。也可以通过一些规则来撬动人们心理上的落差，最典型的当属 QQ 推出会员制度以及蓝钻红钻黄钻体系。用贵族二字体现了身份上的差距。</p>
<h5 id="诱导"><a href="#诱导" class="headerlink" title="诱导"></a>诱导</h5><p>思考目标用户所处场景能发诱惑选择连续稳定的诱因。可以用情景，地点，时间等刺激，设定好刺激物，提高激发频率，使人们不断谈论、选择和使用相关产品，并保持谈论行为。</p>
<h5 id="情绪"><a href="#情绪" class="headerlink" title="情绪"></a>情绪</h5><p>挑起用户情绪,激发人们对某个场景的想法和触动产生共鸣。</p>
<p>兴奋、有趣、生气、担忧能够刺激传播，而抑制传播的情绪有悲伤和满足。</p>
<h5 id="公共性"><a href="#公共性" class="headerlink" title="公共性"></a>公共性</h5><p>人类有模仿的天性，大多数人关注什么我们就留意什么，大多数人选择什么我们就跟从什么，倾向于挑选排长队的餐馆就是社会证明的例子。</p>
<p>可视性对产品和思想是否流行有着至关重要的作用，可观察到的事物更容易被大家公开讨论，可视性也刺激了人们的购买决策，并加速了相应的口碑传播，因为大多数人潜意识认为：参照别人的信息依据别人的决定去做决定是一个省时省力的好办法。</p>
<p>所以想要推广你的产品，就需要利用可视化、可观察的公共属性来加速口碑传播速度，刺激购买欲望。</p>
<h5 id="故事性"><a href="#故事性" class="headerlink" title="故事性"></a>故事性</h5><p>毫无疑问，人们都喜欢挺有趣的故事，我们可以利用大脑对跌宕起伏故事的喜爱，把自己想要传播的内容融入故事中，从而更深地传播。</p>
<h5 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h5><p>人们喜欢传播有价值的信息，信息可以帮助别人，节省时间或金钱，就好像朋友圈里的促销活动、技术干货、生活贴士一样。</p>
<p>作为信息生产者，如何让信息更有价值？这就需要利用比较原则，找好参照点，人们并非绝对理性地按照经济原则来评价事物，当你选择了参照物时，往往能引出人们不理性的一面。超市里大规格比小规格更划算，也就是这个道理了。</p>
<p>一个产品的疯传必定具备了以上几种法则，如何运用并组合出来，很大程度上决定了你的产品推广力度与曝光度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3167794-f2ffc70cd1329b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;思维导图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们身处于这个信息大爆炸的自媒体时代，媒体和受众这两大信息传播要素之间的界限已然消失不见，我们既是信息的消费者，也是信息的生产者。&lt;/p&gt;
&lt;p&gt;已经有案例表明，不少企业依旧想当然地用过去的经验来制定营销策略，其结果是花了大价钱、大力气却也只能换来大众的漠不关心。与之相反的是，有的人就能通过50美元的视频制作费，达到百万美元广告投入的效果；有的人用3.5万美元拍摄的DV电影，能实现2.87亿美元的票房收入……&lt;/p&gt;
&lt;p&gt;营销人员不禁会问：“到底怎么了？”&lt;/p&gt;
&lt;p&gt;这正是这本《疯传》所要回答的问题。不为别的，只因为我们的社会进入了后互联网时代，通过移动终端设备，信息已经从传统的自上而下层级结构的模型，转变为点对点网状结构模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="T型发展" scheme="http://yoursite.com/tags/T%E5%9E%8B%E5%8F%91%E5%B1%95/"/>
    
      <category term="营销" scheme="http://yoursite.com/tags/%E8%90%A5%E9%94%80/"/>
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>「辩思」App研发录：架构设计、Crash分析和竞品技术分析</title>
    <link href="http://yoursite.com/2018/07/28/new/%E3%80%8C%E8%BE%A9%E6%80%9D%E3%80%8DApp%E7%A0%94%E5%8F%91%E5%BD%95%EF%BC%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E3%80%81Crash%E5%88%86%E6%9E%90%E5%92%8C%E7%AB%9E%E5%93%81%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/28/new/「辩思」App研发录：架构设计、Crash分析和竞品技术分析/</id>
    <published>2018-07-28T09:22:00.000Z</published>
    <updated>2018-12-18T12:28:46.683Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>技术会过时，但是思想永远不会过时。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-0c47b356f5dddc99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>本书面广却不深，适合快读。书中基本都是作者自己工作中遇到的问题和坑，从实践而来，避免了空谈。</p>
<p>但是有些地方比如：Carsh异常分析这章，仅仅提供解决方案，缺少问题解决背后的思维过程：遇到什么问题？怎样分析，推理？最后如何发现解决方案？我觉得异常分析的思路和步骤远比罗列大篇幅的异常要更为重要。</p>
<a id="more"></a>
<h4 id="如何打造一个高质量的-APP？"><a href="#如何打造一个高质量的-APP？" class="headerlink" title="如何打造一个高质量的 APP？"></a>如何打造一个高质量的 APP？</h4><p>技术会过时，但是思想不会过时。打造一个高质量的 APP，是个永恒的主题，大致手段都是从以下几方面展开：</p>
<ol>
<li><p>项目结构规划合理，按模块拆分；</p>
</li>
<li><p>模板方法模式拆分庞大的方法。比如 BaseActivity 定义操作的顺序和骨架，子类负责具体实现。实际上 Android 的生命周期函数，也是模板方法的重要体现， ActivityThread 的 main 函数被调用之后，依次执行 Activity 的 onCreate、onStart、onResume 函数，用户可以在 Activity 子类中复写这些生命周期方法做自定义操作；</p>
</li>
<li><p>页面跳转携带的数据一定要做好判空处理；</p>
</li>
<li><p>说到底就是一句话，服务端永远都不要信任客户端传递的数据，一定要做好校验。客户端永远都不要信任服务端给的数据，一定要做好容错处理；</p>
</li>
<li><p>网络请求这块，需要做好错误和 Token 过期的统一拦截处理，且需要预留重试机制；</p>
</li>
<li><p>支持线程集中管理，当页面退出，未完成的线程包括网络请求可以统一取消。这点可以参考 Glide 的巧妙实现原理，通过添加不可见的 Fragment 监听Activity的生命周期，从而实现当退出页面时未完成的图片请求统一取消。</p>
<p>实际上不可见的Fragment这个特性可以做很多有趣的事情，比如你可以让不可见的 Fragment 为 Activity 提供后台服务。或者可以使用这个特性让它包含改变其它 Fragment 的逻辑，而不是把这个逻辑放在 Activity 中。甚至 ActionBar 都可以交给这个没有 UI 界面的 Fragment 来专门管理；</p>
</li>
<li><p>用户登陆状态判断需要做统一拦截，对于需要登陆后自动执行未登陆前的操作，可以参考这篇 <a href="https://www.jianshu.com/p/7114d5e82e8c" target="_blank" rel="external">目标方法前置检验模型设计与实现</a>。</p>
</li>
</ol>
<h4 id="更好的实现和补充"><a href="#更好的实现和补充" class="headerlink" title="更好的实现和补充"></a>更好的实现和补充</h4><h5 id="NativeCrash"><a href="#NativeCrash" class="headerlink" title="NativeCrash"></a>NativeCrash</h5><p>本书中只介绍了 Java Crash 收集，bugly 平台还有 Native Crash 收集，异常发生时，CPU 通过异常中断的方式，触发异常处理流程。Linux 把这些中断处理，统一为信号量，可以注册信号量向量进行处理。具体做法是：注册监听信号处理，并开辟一块单独的栈控件单独处理崩溃信号，避免捕获不到栈溢出异常。</p>
<h5 id="页面分发器"><a href="#页面分发器" class="headerlink" title="页面分发器"></a>页面分发器</h5><p>我不赞同采用文中这种方式实现页面分发器 —— iOS 和 Android 的对应映射直接写在 HTML 代码里。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-f3cd5c8fd696c3c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其实H5并不需要关心原生层的系统，单单关注需要跳转的页面 pageCode 即可。更好的方式是通过服务端来实现集中配置管理映射关系，统一下发给客户端配置表。每个页面对应一个pageCode 作为key。</p>
<p>而且设计Hybrid交互模型时，最好是以接口为单位进行设计的，方式约定为API式交互更为简洁统一。我们来改造一下文中的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//跳转h5页</div><div class="line">&lt;a onclick=&quot;https://XXXX.com/movieDetail.html?movieId=123&quot;&gt;&lt;/a&gt;</div><div class="line">//和Native交互</div><div class="line">&lt;a onclick=&quot;native://movieDetail?movieId=123&quot;&gt;</div></pre></td></tr></table></figure>
<p>Native HTML 互换技术也是可以通过更新路由配置文件来做到。</p>
<p>所以说源码是最好的老师，本书里面很多经典场景设计和架构，在现在公司的项目里已经完全体现而且还设计得更优雅。</p>
<h4 id="借鉴的思路"><a href="#借鉴的思路" class="headerlink" title="借鉴的思路"></a>借鉴的思路</h4><p>书中很多思路，是值得借鉴的，</p>
<ol>
<li>比如资讯类 App，有数据缓存的需求，缓存数据需要考虑下是否有敏感数据？是否需要加密？既然缓存了，就需要预留强制更新的触发点。</li>
<li>流量优化方面，可以使用更好的数据传递协议。例如 ProtoBuffer。</li>
<li>减少包体积大小可以采用增量更新、ttf 图片、webp、Proguard 移除无用类和方法。</li>
<li>完整的广告引导链可以参考社区类和视频类 App，用户体验和活动运营我们可以参考电商类 App，高并发的架构设计可以调研社交类 App，推送服务的及时性和到达率我们可以向新闻类 App 学习。</li>
</ol>
<p>最后我想谈谈项目管理和团队建设。</p>
<p>项管最重要的作用，就是同步。每天不厌其烦地和测试、开发、产品了解进度，把控风险点，同步到整个项目组。项管一定要对人员松管理，项目强管理。</p>
<p>团队建设方面，Code Review 和技术分享都是提高团队战斗力的手段。</p>
<p>Code Review 的好处我觉得不用多说了，但实际推行起来，有下面几个情况会让 Code Review 失去效果。</p>
<p>首当其冲的是 —— 团队成员能力不足，我经历过这样的情况，Code Review的过程中，大家大眼瞪小眼，没有什么好的想法，不知道什么是好的代码，什么是不好的代码。导致Code Review大多数都在代码风格上。对此，是时候让团队的人花时候阅读一下《代码大全》、《重构与模式》、《代码整洁之道》这些基础书籍了。</p>
<p>其次的原因是 —— 成员的态度问题，一方面就是懒，不想精益求精，只要干完活交差了事。对此，你更要大力开展Code Review了，让这种人写出来的代码曝光在更多人面前，让他为质量不好的代码蒙羞。另一方面，有人会觉得那是别人的模块，我不懂，也没时间去懂，不懂他的业务怎么做 Code Review ? 我只想说，如果你的团队里这样的自扫门前雪的事越多，那么这个团队也就越没主动性，没有主动性也就越不可能是个好团队，做的东西也不可能好。而对于个人来说，也就越不可能有成长。 Code Review实际上是一种沟通方式，你可以了解成员的代码水平、代码风格和思维方式，能让团队成员不光关注自己，也了解别人做了哪些代码改动。</p>
<p>技术分享同样容易面临成员态度问题的挑战，部分成员觉得分享已然成为一种负担，根本原因还是没有输入，无法输出，习惯用惯性思维不加思考地去做业务。</p>
<p>建议先培养出团队持续交流，持续输入的氛围，再端正成员的态度。教是最好的学，技术分享是在彼此表达的过程中去强化自己的记忆和理解，双赢的事情。为了让不明白的听众做到明白自己的分享内容，分享者必须要知道从明白到不明白究竟需要掌握哪些概念，这就迫使分享者对整个知识体系来个寻根究底，把自己知道的潜在概念或假设，自己不知道的潜意识，统统都挖出来。正是成员没有意识到做一场分享对自己 “串” 起知识关联的作用，才如此抗拒甚至逃避分享。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;技术会过时，但是思想永远不会过时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3167794-0c47b356f5dddc99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本书面广却不深，适合快读。书中基本都是作者自己工作中遇到的问题和坑，从实践而来，避免了空谈。&lt;/p&gt;
&lt;p&gt;但是有些地方比如：Carsh异常分析这章，仅仅提供解决方案，缺少问题解决背后的思维过程：遇到什么问题？怎样分析，推理？最后如何发现解决方案？我觉得异常分析的思路和步骤远比罗列大篇幅的异常要更为重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="竞品分析" scheme="http://yoursite.com/tags/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/"/>
    
      <category term="团队管理" scheme="http://yoursite.com/tags/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/"/>
    
      <category term="代码质量" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>「读」架构真经---互联网技术架构的设计原则</title>
    <link href="http://yoursite.com/2018/07/21/new/%E3%80%8C%E8%AF%BB%E3%80%8D%E6%9E%B6%E6%9E%84%E7%9C%9F%E7%BB%8F---%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2018/07/21/new/「读」架构真经---互联网技术架构的设计原则/</id>
    <published>2018-07-21T05:57:00.000Z</published>
    <updated>2018-12-18T12:29:06.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>架构的思想是非常宝贵的，设计的基本原理不会因为新技术的层出不穷而过时。怎样以最低成本最大化系统的扩展性？怎样达到风险利益的平衡点？答案尽在本书中。</p>
</blockquote>
 <a id="more"></a>
<h3 id="第一章-大道至简"><a href="#第一章-大道至简" class="headerlink" title="第一章 大道至简"></a>第一章 大道至简</h3><p>本章围绕着简化这个主题，从需求到设计、实施、部署再到网络设备。</p>
<p>需求方面的过度设计比较容易避免，控制好项目范围和需求范围就可以了。</p>
<p>想要避免设计方面的过度设计，最简单的方法是把设计的解决方案展示给其他技术团队，要求其他团队能够快速轻松地理解，如果任何一个团队不理解这个解决方案，就应该思考下，是否设计得过于复杂。所以归根结底，我们在设计解决方案时，首要考虑的是目前业务的增长速度和需求，只做当下最好的设计。</p>
<p>我想起自己一个实例，一个小需求——登录注册页底部加广告位。遗憾的是在兼容性测试中发现，Android 4.4 以下设备，底部广告位不能和底部的软键盘友好兼容，出现了广告位变形的情况。（且实践后发现，需要针对 Android 4.2 和 4.3 做不同的兼容），采取了一系列解决方案后，我意识到不应该为低版本用户做这种可能会影响性能的特殊监听，方案的复杂度也已经超出控制了。立马和产品协商，最简单干脆的方案是低版本用户不显示该广告位，问题至此解决。</p>
<p>那是不是简单的设计，就意味着不需要考虑系统未来的扩展性？当然不是！我们可以选择一开始就设计好扩展方案，等待需求规模的增长，再来实施这个扩展方案。虽然一开始就设计付出的智力成本比较大，但我们没有付出更大的技术和资产成本，智力成本处于可接受的成本范围。并且在现有的方案下，我们可以随时快速参考，随时快速实施扩展。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-843376e26fcb58b8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DID 成本"></p>
<p>在实施过程中，推荐使用被广泛采用的开源或第三方解决方案，最简单的实施几乎总是那些有过实践经历并通过实践证明了的可扩展方案。想想如果采用开源库，成千上万的开发者一起使用，同时找bug，且有专人维护和更新。这些都是自己创建方案所不能做到的。当然，如果有商业库，最好还是采用商业方案，任何一个人都不可能是各方面的专家，商业供应商拥有该方案领域的专家（如<br> OCR 或者推送），我们通常能得到一个高质量的方案，这个方案不单单是高质量的编程，而且是该领域的高性能。</p>
<h3 id="第二章-分而治之"><a href="#第二章-分而治之" class="headerlink" title="第二章 分而治之"></a>第二章 分而治之</h3><p>本章围绕着扩展这个主题，提出了三个简单规则：x 轴扩展、y 轴拆分、z 轴拆分。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-cae31f43dc468d6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>你可以注意到，x 轴是扩展，y 轴和 z 轴都属于拆分，进而达到扩展的目的。</p>
<p>成本最低的就是 x 轴扩展，主要手段是复制数据库和服务，来分散高频事务处理带来的负载，CDN 负载均衡就是这种规则的体现。</p>
<p>随着数据规模逐渐扩大，数据复制可能会出现瓶颈，这个时候，我们可以着手于扩展 y 轴，也就是把数据或服务按名词（以资源为导向，如：用户信息、产品信息）或动词（以服务为导向，如：注册、登陆、搜索）标识拆分。随着拆分，我们庞大的系统拆分成为子系统，团队也可以随之拆分，类似于目前公司的垂直化分组，每个小团队专门负责不同的子系统，更加专业的同时也提高了生产力。</p>
<p>当数据集的用户基数（此处以用户举例，实际上什么都可以进行拆分，思路一致，找到共同点与不同点即可）越来越大，且用户属性有明显不同时（如：地区、行业等），可以考虑 z 轴拆分。书中介绍到：可以根据用户属性分块，在应用发布时，可以通过先发布到含有少量客户的一小块来控制风险，没有问题后，再发布给其他大块或者全量。这就有点类似于 Android 灰度包的做法，只不过灰度包中，是用注册渠道（小米渠道、华为渠道）来标识用户块。我们可以把几个非常小的渠道合并为一个分块，减少数据块的碎片化。说到底，z 轴可以把数据分割成容易命中的多块数据，避免数据集过大，需要长时间遍历的弊端。</p>
<h3 id="第三章-水平拆分"><a href="#第三章-水平拆分" class="headerlink" title="第三章 水平拆分"></a>第三章 水平拆分</h3><p>向外扩展（复制或拆分数据，分散负载），而不是向上扩展（购买更大的硬件来支撑）。</p>
<p>通俗讲，就是小、简单、多优于大、复杂、少。硬件再怎么大，都有个上限，采购成本也随之指数上升。如果是向外扩展，设备可以随时被替换或丢弃，扩展可以无限。</p>
<p>当我们做容灾时，通常会考虑双机备份。本文提出一个非常棒的设计方案——三活数据中心。如果想快速扩展现有的双数据中心，可以加个云数据中心来作为第三个数据中心，最小化了硬件支出。但是这个方案也不是全是优点，考虑下数据的同步频率，额外的连接(N中心就有(N*(N-1))/条双向连接)，当数据中心不断扩展时，这个复杂度还是很可怕的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-eedf54460321a170.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三活数据中心"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-aeb397c10aab5687.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三活数据中心 + 三个热数据中心"></p>
<p>最后，利用云技术来处理意外、临时、突发或偶发的需求。可以有效降低硬件成本，提高我们的响应速度，也减少了我们改变产品需求的风险成本。</p>
<h3 id="第四章-先利其器"><a href="#第四章-先利其器" class="headerlink" title="第四章 先利其器"></a>第四章 先利其器</h3><p>本章主要讲的是开发中工具使用的思考，包括：怎样选择数据库？哪种数据库更适合？数据存储是不是非数据库不可？防火墙的意义是什么？是否实施防火墙的决定因素有哪些？日志文件怎么有效发挥作用？</p>
<p>在了解这些开始前，我们需要避免陷入工具法则，技术解决方案可以尝试多方案，平时和不同技术栈的同事多交流，花时间做技术调研，学习新事物，主动分析、实验、采用新工具同时不断革新工具，使用最适合的工具，避免被自己只熟悉的东西困住。</p>
<p>日志文件这块，我想以客户端的角度详细讲讲。</p>
<p>使用日志的第一步，是要解决收集日志的问题。收集可以用 AOP 来插入日志调用语句，也可以结合业务逻辑手动来调用。那么什么时候上报？我们可以间隔一段时间，就上报，如果考虑到服务器的负载，也可以下次启动时统一上报。这种情况下，考虑下如果日志文件太大，上传过程中进程被杀，我们需要支持断点续传。上报的具体时机，按实时性的需求选择。</p>
<p>第二步上报之后，服务器需要把日志聚合到日志服务器上统一存储。服务端需要提供完整的日志分类、即时报表统计工具、监控支持和支持全文检索日志。</p>
<p>下一步是日志分类，是按用户维度？还是按日志等级维度？日志中的错误，可以按机型或者人数来统计，报错多的类似日志，我们优先排查解决。</p>
<p>每天产生这么多日志，维护和存储成本逐渐上升，最新的数据价值最高，我们考虑对旧数据进行归档或删除。</p>
<p>最后书中写道：引进每项新技术都需要另外一种技能来支持。尽管工作中使用合适的工具很重要，但是不要过度强调专业化，以至于没有足够深度的技能来支持。</p>
<p>共勉。</p>
<h3 id="第五章-画龙点睛"><a href="#第五章-画龙点睛" class="headerlink" title="第五章 画龙点睛"></a>第五章 画龙点睛</h3><p>本章围绕着系统扩展性主题，罗列出限制了系统扩展能力的错误设计。</p>
<p>首先是不要复查刚插入的数据——这种成本翻倍又难以维护的操作。</p>
<p>其次是滥用重定向，这会降低用户体验，影响页面搜索引擎排行。</p>
<p>最后，因为大多数关系型数据库不擅长保持节点之间数据的一致性，所以没有必要为了场景的一致性，影响了数据库的分布式扩展。合理地放宽时间约束，找到一个系统方便扩展，用户又容易接受的时间点。</p>
<p>不管做什么，首要考虑都是最小成本产生最大效益。我们允许某些不同步的小错误换取扩展性的最大化。</p>
<h3 id="第六章-缓存为王"><a href="#第六章-缓存为王" class="headerlink" title="第六章 缓存为王"></a>第六章 缓存为王</h3><p>想提高扩展性，缓存是个很好的手段。从浏览器到网络、知道应用和数据库每个层次，缓存有无数选项可以考虑：</p>
<ol>
<li>通过 CDN 缓存来平缓请求高峰和增长，提高服务器负载。</li>
<li>Ajax 提供了丰富的异步动态交互，但需要注意频繁的废请求。</li>
<li>在网络服务器前面实施页面缓存。</li>
<li>根据数据读取的边界或者相关性，进行 y 轴 z 轴拆分，从而提高缓存的命中率。</li>
<li>推荐对 Sql 数据集建立对象缓存层，既不影响服务器性能，又方便独立地扩展缓存池。</li>
<li>推荐通过 HTTP 头来控制缓存，如果数据结果没有包含用户的隐私数据的话，指定 Cache-Control 头为 public有利于数据结果可以缓存在从客户端到服务器之间的任何代理及缓存。（如：浏览器、CDN、页面缓存、应用缓存） </li>
</ol>
<h3 id="第七章-前车之鉴"><a href="#第七章-前车之鉴" class="headerlink" title="第七章 前车之鉴"></a>第七章 前车之鉴</h3><p>本章提出了一个有趣的观点：构建高可用性和高可扩展性的系统，目的就是防止频繁失败，因此可以学习的机会也比较少。经常失败的组织往往有更好的学习和成长机会，如果他们能抓住机会并从中学习。</p>
<p>引申开来，在敏捷软件开发实践中，每个 Sprint 结束后有回顾总结会，主要议题就是：在这个 Sprint 里，我们哪些做的比较好的，哪些是需要提高的，下个 Sprint 要采取哪些措施。这个回顾总结的本质就是复盘，目的是让团队从过去学习，来提升团队的整体交付能力。</p>
<p>最后本章还指出，需要确保所有版本的代码都有回滚能力，回滚的成本远远低于发布引起的线上故障，也能把风险降低到可控范围。客户端的话，效果类似于热修复，都是适用于线上紧急情况下实时高效把损失降到最低。</p>
<h3 id="第八章-重中之重"><a href="#第八章-重中之重" class="headerlink" title="第八章 重中之重"></a>第八章 重中之重</h3><p>本章深有体会的一点：实体间的关系影响了我们如何存储、检索、更新数据和扩展拆分数据。数据的完整性和规范程度越高，关系越紧密，就越难以扩展和拆分，我们需要折中考虑。</p>
<h3 id="第九章-有备无患"><a href="#第九章-有备无患" class="headerlink" title="第九章 有备无患"></a>第九章 有备无患</h3><p>本章重点在于提高系统的高可用性，系统的合理故障处理与隔离。</p>
<p>可用性和可扩展性具有同等重要性，可用性不高的系统不需要扩展，不能扩展的系统也不会是高可用性的。通过减少故障和频率和影响范围，我们可以提高系统的整体可用性。</p>
<p>减少故障的手段有以下几种：</p>
<ol>
<li><p>用泳道隔离故障，各泳道之间不共享资源特别是数据库和服务器，并禁止不同泳道之间同步调用，避免故障阻塞，如果需要调用，推荐采用异步。异步的调用非常类似于观察者的模式，仅仅把事件传递出去，而观察者有没有收到，是否处理了，被观察者并不关心。我们可以沿 y 轴或 z 轴进行拆分，这有利于故障隔离，不同服务间彼此独立，有助于我们快速定位问题，缩小排查范围。</p>
</li>
<li><p>当使用单例模式时，就要慎重小心了。如果多个系统都需要共享这个单例，一旦单例失败，则会引起系统范围的故障。</p>
</li>
<li><p>并联而不是串联系统（除非有多版本子系统可以随时取代），避免累积影响。</p>
</li>
<li><p>增加启用/禁用框架，可以智能或人为干涉开启/关闭服务。这类似于开关的概念，在功能上加开关来做到一款上线/下线，防范风险。</p>
</li>
</ol>
<h3 id="第十章-超然物外"><a href="#第十章-超然物外" class="headerlink" title="第十章 超然物外"></a>第十章 超然物外</h3><p>本章论证了引入状态会给我们系统带来多大的麻烦：耗费内存和处理能力、依赖增加、故障时状态无法恢复。</p>
<p>所以我们不惜一切代价避免状态。如果状态是必要的，建议把数据存储在用户端（如浏览器中的 Cookie 机制、客户端的 Token）因为存储在用户端，所以需要做好加密，防止中间人窃取凭证伪装用户。服务端虽然可以减少存储、检索成本，但保险起见，需要有校验的步骤，不可完全相信用户端传来的凭证。</p>
<p>如果有些设计必须要把状态数据存在服务端，就用分布式缓存来作为单层中间层处理。这里需要考虑下分布式中更新状态数据和读取状态数据的冲突问题，以及数据需不需要持久化。</p>
<h3 id="第十一章-异步通信"><a href="#第十一章-异步通信" class="headerlink" title="第十一章 异步通信"></a>第十一章 异步通信</h3><p>本章讨论了异步通信的准则和处理。可以说在开发中特别是客户端开发中，由于主线程的特性，异步思想是无处不在。</p>
<p>异步一般可以借助回调或者事件总线（本质上就是观察者模式）来完成，如果嵌套层次太深，或者需要解耦，或者遇到跨服务的情况，就要考虑用事件总线了。</p>
<p>本章引发我对事件总线扩展性的一些思考（毕竟单用户的客户端只需要一条总线就足够了）：</p>
<ol>
<li><p>这么多的服务和系统，用同一条总线，高频的读写会引起堵塞，怎么扩展总线？最直接的方式就是按照面向的服务和属性拆分（y 轴），这会牺牲一些灵活性，你不能够跨服务去通知；按照客户边界拆分成泳道（z 轴），泳道之间也可异步通信。<br><img src="https://upload-images.jianshu.io/upload_images/3167794-abc9c4a274ee1f92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>总线是否可以扩展下优先级属性，在同时发生事件时，优先级高的事件优先通知。</p>
</li>
<li><p>不需要再处理的观察者，需要增加自动解绑机制。</p>
</li>
</ol>
<h3 id="第十二章-意犹未尽"><a href="#第十二章-意犹未尽" class="headerlink" title="第十二章 意犹未尽"></a>第十二章 意犹未尽</h3><p>我们怎么应对突发的流量？怎么提高系统高峰时的可用性？</p>
<p>有两方面可以解决：</p>
<ol>
<li>利用云或者应急的容量，来负载突发请求，同时系统要做好这方面的扩展；</li>
<li>建立监控体系，存在异常波动，及时报警。</li>
</ol>
<p>需要说明的是，虽然我们反复强调不要造轮子，优先使用被广泛采用的开源库或第三方解决方案，但是供应商永远都不会像你自己一样，在第一时间处理方案中的 bug 。所以这需要我们做好解耦，评估扩展性和风险点。第三方方案的缺陷我们是否能接受？是否在可控范围？自己的团队是否可以方便地扩展和修改以适应自己的需求？最差的情况下，第三方方案是否容易随时替换？这些都是我们在使用第三方前需要考虑的。</p>
<p>在扩展时，不要依赖供应商的产品、服务或系统功能来扩展，如果依赖于供应商的专有方案，我们将失去主动权和竞争力。就像携程没有开源的React Native优化框架，就是客户端的竞争力之一。</p>
<p>上面第 2 点的监控，架构设计之初就应该纳入考虑，监控系统的状态比如 CPU、内存使用率固然重要，更重要的是从业务指标做监控如注册成功率、下单转换率、搜索频率等，这样才更直观地看到业务的异常情况，具体受到什么的影响。文中提出监控系统一个有意思的展望：使用控制图或者机器学习，来预测是否会发生异常，并支持系统自我修复，这种自动化自愈系统，将是未来的方向。</p>
<p>最后，文章提出了对数据进行梯级存储策略，毕竟处于大数据时代，庞大的数据无疑增加了我们的成本。结合业务，评估数据的价值和访问频率，使用不同的存储介质和策略，比如低价值低频访问率的数据，是删除还是迁移到低速存储中？</p>
<p>我不知道你有没有留意过，跨年的快递单号已经查询不了物流信息了，因为已经签收了的数据，随着时间推移慢慢老化，失去价值，这部分数据完全可以删除掉。</p>
<h3 id="第十三章-谋定而动"><a href="#第十三章-谋定而动" class="headerlink" title="第十三章 谋定而动"></a>第十三章 谋定而动</h3><p>本章用风险收益分析方法，评估了全文提出的50条规则。</p>
<p>这个评估方法，也可以运用在我们平时的解决方案选定中：这个方案能降低多少风险，解决什么问题？风险出现的频率怎么样？降低的风险点，对系统和业务的影响面多少，损失会是多少？如果采用该方案，我们的成本怎么样？成本和风险比起来，我们能得到多少收益？这些都是我们需要思考的，毫无疑问优先采用降低风险多又低成本的方案。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-134be3d9fc888bc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可扩展性与可用性风险分解"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-1985f55c6938ce7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本书的思想和规则非常宝贵，大概总结了 12 条设计过程中需要遵循的架构原则。</p>
<ol>
<li><p>N+1设计。永远不少于两个，通常为三个，当故障发生时，至少保证有一个冗余的实例。</p>
</li>
<li><p>回滚设计。确保系统可以回滚到以前发布过的任何版本。</p>
</li>
<li><p>禁用设计。能够关闭任何发布的功能。</p>
</li>
<li><p>监控设计。在设计阶段就必须考虑监控，而不是在实施完成之后补充。</p>
</li>
<li><p>使用成熟的技术。只用确实好用的技术，谨慎使用最新技术。</p>
</li>
<li><p>异步设计。只有在绝对必要的时候才进行同步调用。</p>
</li>
<li><p>无状态系统。只有当业务确实需要的时候，才使用状态。</p>
</li>
<li><p>设计至少要有两个步骤的前瞻性。在扩张性问题发生前考虑好下一步的行动计划。</p>
</li>
<li><p>非核心则购买。如果不是你最擅长的，也提供不了差异化的竞争优势则直接购买。</p>
</li>
<li><p>小构建，小发布，快试错。全部研发要小构建，不断迭代，让系统不断地成长。</p>
</li>
<li><p>隔离故障。实现故障隔离设计，通过断路保护避免故障传播和交叉影响。</p>
</li>
<li><p>自动化。设计和构建自动化的过程。如果机器可以做，就不要依赖于人。</p>
</li>
</ol>
<blockquote>
<p>参与了读书计划，所以本书感悟按章分解。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;架构的思想是非常宝贵的，设计的基本原理不会因为新技术的层出不穷而过时。怎样以最低成本最大化系统的扩展性？怎样达到风险利益的平衡点？答案尽在本书中。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="T型发展" scheme="http://yoursite.com/tags/T%E5%9E%8B%E5%8F%91%E5%B1%95/"/>
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>推荐---Android-完整知识体系脑图</title>
    <link href="http://yoursite.com/2018/06/05/new/%E6%8E%A8%E8%8D%90---Android-%E5%AE%8C%E6%95%B4%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%84%91%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/06/05/new/推荐---Android-完整知识体系脑图/</id>
    <published>2018-06-05T09:41:00.000Z</published>
    <updated>2018-12-18T12:25:58.331Z</updated>
    
    <content type="html"><![CDATA[<p>抽个空，把所有知识点整理成脑图，方便构建知识体系，有遗漏的，欢迎在评论区补充。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-d5e778569f292cfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><a href="http://naotu.baidu.com/file/ae9b7d7d7120bfd4a775ee707025f83b?token=ec7e0dac38165406" target="_blank" rel="external">脑图详细地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抽个空，把所有知识点整理成脑图，方便构建知识体系，有遗漏的，欢迎在评论区补充。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3167794-d5e778569f292cfd.png?imag
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="知识体系" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>「Android-安全架构」你真的了解权限机制吗？</title>
    <link href="http://yoursite.com/2018/05/26/new/%E3%80%8CAndroid-%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E3%80%8D%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E6%9D%83%E9%99%90%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/05/26/new/「Android-安全架构」你真的了解权限机制吗？/</id>
    <published>2018-05-26T09:49:00.000Z</published>
    <updated>2018-12-18T12:28:38.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android将安全设计贯穿系统架构的各个层面，覆盖系统内核、虚拟机、应用程序框架层以及应用层各个环节，力求在开放的同时，也最大程度地保护用户的数据、应用程序和设备的安全。Android安全模型主要提供以下几种安全机制：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-6d77a9733cf9b413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<p>从技术架构角度来看，Android安全模型基于Linux操作系统内核安全性，有基本的用户和文件访问隔离，在这个基础上辅以内存管理技术和进程间通信机制，来适应移动端处理器性能与内存容量的限制。在应用层面，使用显式定义且经用户授权的权限控制机制，系统化地规范并强制各类应用程序的行为准则与权限许可，可以看到权限机制在安全模型中所处的位置。</p>
<p>那么为什么有权限机制？</p>
<p>我们知道 Android 应用程序是沙箱隔离的，每个应用都有一个只有自己具有读写权限的专用数据目录，应用只能访问自己的文件和一些设备上全局可访问的资源。</p>
<p>那如果我需要访问系统服务呢？这就有了 Android 的权限机制。所以根本原因一是沙箱隔离，二是服务支持的需求。</p>
<p>在本文开始之前，先抛出几个问题思考，什么是权限？权限是怎么进行赋予的？怎么判断一个组件是否拥有特定的权限？权限维护在哪？Android 6.0 运行时权限是什么原理？权限赋予后还能再更改吗？</p>
<p>带着问题和结构图，我们一一解开疑惑。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-ed09d0f1de8ddbf5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="权限的本质"><a href="#权限的本质" class="headerlink" title="权限的本质"></a>权限的本质</h3><p>什么是权限？</p>
<p>在 Android 中，一个权限，本质上是一个字符串，一个可以表示执行特定操作的能力的字符串。比如说：访问 SD 卡的能力，访问通讯录的能力，启动或访问一个第三方应用中的组件的能力。</p>
<p>使用 <code>pm list permissions -f</code> 命令可以详细查看 Android 所有预定义的权限。我们挑一个权限出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ permission:android.permission.DELETE_PACKAGES</div><div class="line">  package:android</div><div class="line">  label:null</div><div class="line">  description:null</div><div class="line">  protectionLevel:signature|privileged</div></pre></td></tr></table></figure></p>
<p>可以看到，一个权限的信息包括：定义的包名、标签、描述和保护级别，保护级别，嗯，这个我们需要详细讲讲。<strong>因为不是应用声明了权限，就一定会全部被自动赋予的，保护级别决定了包管理器是否应该赋予组件所申请的权限。</strong></p>
<h3 id="权限的级别"><a href="#权限的级别" class="headerlink" title="权限的级别"></a>权限的级别</h3><ul>
<li><p>normal 级别<br>权限保护级别的默认值，无须用户确认，只要声明了，就自动默默授权。如：ACCESS_NETWORK_STATE。</p>
</li>
<li><p>dangerous 级别<br>赋予权限前，会弹出对话框，显式请求权限。如：READ_SMS。因为 Android 需要在安装时赋予权限，所以安装的确认对话框，也会显示列出权限清单。</p>
</li>
<li><p>signature 级别<br>signature 级别的权限是最严格的权限，只会赋予与声明权限使用相同证书的应用程序。</p>
<p>以系统内置 signature 级别权限为例，Android 系统应用的签名由平台密钥签发，默认情况下源码树里有 4 个不同的密钥文件：platform、shared、media 和 testkey。所有核心平台的包（如：设置、电话、蓝牙）均使用 platform 密钥签发；搜索和通讯录相关的包使用 shared 签发；图库和媒体相关的包使用 media 密钥签发；其他的应用使用 testkey 签发。定义系统内置权限的 framework-res.apk 文件是使用平台密钥签发的，因此任何试图请求 signature 级别内置权限的应用程序，需要使用与框架资源包相同的密钥进行签名。</p>
</li>
<li><p>signatureOrSystem 级别<br>可以看做是一种折中的级别，可被赋予与声明权限具有相同签名证书密钥的应用程序（同 signature 级别）或者系统镜像的部分应用，也就是说这允许厂商无须共享签名密钥。Android 4.3 之前，安装在 system 分区下的应用会被自动赋予该保护级别的权限，而 Android 4.4 之后，只允许安装在 <code>system/priv-app/</code> 目录下的应用才能被主动赋予。</p>
</li>
</ul>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>那么，系统内置权限，自定义权限，是怎么维护和管理的？</p>
<p>在每个应用安装时，权限就已经赋予了，系统使用包管理服务来管理权限。打开我们系统目录下的 <code>/data/system/packages.xml</code>，可以看到文件包含了所有已定义的权限列表和所有 apk 的包信息，这可以看做是包管理服务维护的一个已安装程序的核心数据库，这个数据库，随着每次应用安装、升级或卸载而进行更新。</p>
<p>主要属性如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-9c666ffdbbd5f24d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>&lt;permissions&gt;</code> 标签内，定义了目前系统中的所有权限，分为系统内置的（package 属性为 android 的）和 apk 自定义的（package 属性为 apk 的包名）。根元素 <code>&lt;package&gt;</code> 含有每个 apk 的核心属性，以一个应用程序的条目为例：</p>
<ul>
<li><h4 id="Android-6-0-以下-packages-xml"><a href="#Android-6-0-以下-packages-xml" class="headerlink" title="Android 6.0 以下 packages.xml"></a>Android 6.0 以下 <code>packages.xml</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;package </div><div class="line">    name=&quot;com.feelschaotic.demo&quot; </div><div class="line">    codePath=&quot;/data/app/com.feelschaotic.demo-1&quot; </div><div class="line">    nativeLibraryPath=&quot;/data/app/com.feelschaotic.demo-1/lib&quot; </div><div class="line">    primaryCpuAbi=&quot;x86&quot; </div><div class="line">    flags=&quot;5783366&quot; </div><div class="line">    ft=&quot;16349bcc4d0&quot; </div><div class="line">    it=&quot;16349bcc752&quot; </div><div class="line">    ut=&quot;16349bcc752&quot; </div><div class="line">    version=&quot;8220&quot; </div><div class="line">    userId=&quot;10097&quot;&gt;</div><div class="line">    &lt;sigs count=&quot;1&quot;&gt;</div><div class="line">        &lt;cert index=&quot;7&quot; /&gt;</div><div class="line">    &lt;/sigs&gt;</div><div class="line">    &lt;perms&gt;</div><div class="line">        &lt;item name=&quot;android.permission.READ_SMS&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.INTERNET&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.CALL_PHONE&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.CAMERA&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</div><div class="line">        &lt;item name=&quot;android.permission.READ_CONTACTS&quot; /&gt;</div><div class="line">    &lt;/perms&gt;</div><div class="line">    &lt;proper-signing-keyset identifier=&quot;1686&quot; /&gt;</div><div class="line">    &lt;signing-keyset identifier=&quot;1686&quot; /&gt;</div><div class="line">&lt;/package&gt;</div></pre></td></tr></table></figure>
</li>
<li><h4 id="Android-6-0-及以上-packages-xml"><a href="#Android-6-0-及以上-packages-xml" class="headerlink" title="Android 6.0 及以上 packages.xml"></a>Android 6.0 及以上 <code>packages.xml</code></h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;package </div><div class="line">   name=&quot;com.feelschaotic.demo&quot; </div><div class="line">   codePath=&quot;/data/app/com.feelschaotic.demo-Gi5ksdF6mUDLakfOugCcwQ==&quot; </div><div class="line">   nativeLibraryPath=&quot;/data/app/com.feelschaotic.demo-Gi5ksdF6mUDLakfOugCcwQ==/lib&quot; </div><div class="line">   primaryCpuAbi=&quot;x86&quot; </div><div class="line">   publicFlags=&quot;945307462&quot; </div><div class="line">   privateFlags=&quot;0&quot; </div><div class="line">   ft=&quot;16348dc3870&quot; </div><div class="line">   it=&quot;16343f1d6aa&quot; </div><div class="line">   ut=&quot;16348dc4c4d&quot; </div><div class="line">   version=&quot;8220&quot; </div><div class="line">   userId=&quot;10102&quot;&gt;</div><div class="line">       &lt;sigs count=&quot;1&quot;&gt;</div><div class="line">           &lt;cert index=&quot;20&quot; key=&quot;...&quot; /&gt;</div><div class="line">       &lt;/sigs&gt;</div><div class="line">       &lt;perms&gt;</div><div class="line">         &lt;!-- 此处普通权限的 granted 全都默认是 true，且不可改变 granted 值--&gt;</div><div class="line">           &lt;item name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</div><div class="line">           &lt;item name=&quot;android.permission.INTERNET&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</div><div class="line">           &lt;item name=&quot;android.permission.CHANGE_WIFI_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</div><div class="line">           &lt;item name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</div><div class="line">       &lt;/perms&gt;</div><div class="line">       &lt;proper-signing-keyset identifier=&quot;48&quot; /&gt;</div><div class="line">   &lt;/package&gt;</div></pre></td></tr></table></figure>
<p>可以发现，其他信息没有太大差异，但是权限列表中，部分在 Android 6.0 被标记为高危的权限都不在 <code>&lt;perms&gt;</code> 里了，如：<code>READ_SMS</code>、<code>READ_EXTERNAL_STORAGE</code>、<code>CALL_PHONE</code> 等。这是怎么一回事呢？</p>
<p>Android 6.0 之前，权限都是在安装时自动赋予的，不卸载应用的情况下，不能更改或撤销（实际上有些厂商打开了appOps，使得 6.0 以下也能更改权限，这种特殊情况我们不讨论）。而 Android 6.0 版本对 permission 的管理做了部分改动，针对 dangerous 级别，不再安装的时候赋予权限，而是在运行时动态申请。</p>
<p>我们大胆地推断下，<code>packages.xml</code> 里保留的是不会再变更的权限，运行时权限一定是另外单独地维护。我们在 <code>data/system</code> 目录下来了个全盘搜索，找到了 <code>/data/system/users/0/runtime-permissions.xml</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;pkg name=&quot;com.feelschaotic.demo&quot;&gt;</div><div class="line">   &lt;!-- 该demo我们故意拒绝了定位权限，可以看到：ACCESS_FINE_LOCATION 和 ACCESS_COARSE_LOCATION 的 granted 为 false --&gt;</div><div class="line">    &lt;item name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; granted=&quot;false&quot; flags=&quot;1&quot; /&gt;</div><div class="line">    &lt;item name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</div><div class="line">    &lt;item name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; granted=&quot;false&quot; flags=&quot;1&quot; /&gt;</div><div class="line">    &lt;item name=&quot;android.permission.READ_PHONE_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</div><div class="line">    &lt;item name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</div><div class="line">    ...</div><div class="line">&lt;/pkg&gt;</div></pre></td></tr></table></figure>
<p>没错了，就是这个文件。里面就记录着运行时权限的授予和拒绝状态。申请时，申请的结果会动态修改 <code>granted</code> 值。</p>
<p>管理权限的仍然是 PMS，只不过 Android 6.0 之后新增了 <code>runtime-permissions.xml</code> 数据库。</p>
<h3 id="权限赋予"><a href="#权限赋予" class="headerlink" title="权限赋予"></a>权限赋予</h3><p>我们知道，Android 应用安装时，会被分配一个唯一的 UID，应用启动时，包管理器会设置新建进程的 UID 和 GID 为应用程序的 UID。如果应用已经被赋予了额外的权限，就把这些权限映射成一组 GID，作为补充 GID 分配给进程。低层就可以依赖于进程的 UID、GID 和补充 GID 来决定是否赋予权限了。</p>
<p>那么，上面流程的重点：</p>
<ol>
<li>权限是如何映射到 OS 层的 UID、GID 上的呢？</li>
<li>映射完是怎么分配给进程的？</li>
<li>低层是怎么判断是否赋予权限的？</li>
</ol>
<p>我们一个个来看，首先第一个，权限是如何映射的？内置权限到 GID 的映射是定义在 <code>/etc/permission/platform.xml</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;permissions&gt;</div><div class="line">    ···</div><div class="line">    &lt;permission name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &gt;</div><div class="line">        &lt;group gid=&quot;sdcard_r&quot; /&gt;</div><div class="line">    &lt;/permission&gt;</div><div class="line"></div><div class="line">    &lt;permission name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &gt;</div><div class="line">        &lt;group gid=&quot;sdcard_r&quot; /&gt;</div><div class="line">        &lt;group gid=&quot;sdcard_rw&quot; /&gt;</div><div class="line">    &lt;/permission&gt;</div><div class="line">    </div><div class="line">    &lt;permission name=&quot;android.permission.INTERNET&quot; &gt;</div><div class="line">        &lt;group gid=&quot;inet&quot; /&gt;</div><div class="line">    &lt;/permission&gt;</div><div class="line">    ···</div><div class="line">&lt;/permissions&gt;</div></pre></td></tr></table></figure>
<p>值得注意的是：<code>READ_EXTERNAL_STORAGE</code> 这种运行时权限，在 Android 6.0 之后已经不会映射到 gid 了。动态赋予，动态申请，也就不需要映射了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    &lt;!-- These are permissions that were mapped to gids but we need</div><div class="line">         to keep them here until an upgrade from L to the current</div><div class="line">         version is to be supported. These permissions are built-in</div><div class="line">         and in L were not stored in packages.xml as a result if they</div><div class="line">         are not defined here while parsing packages.xml we would</div><div class="line">         ignore these permissions being granted to apps and not</div><div class="line">         propagate the granted state. From N we are storing the</div><div class="line">         built-in permissions in packages.xml as the saved storage</div><div class="line">         is negligible (one tag with the permission) compared to</div><div class="line">         the fragility as one can remove a built-in permission which</div><div class="line">         no longer needs to be mapped to gids and break grant propagation. --&gt;</div><div class="line">         </div><div class="line">&lt;permission name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</div><div class="line">&lt;permission name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</div></pre></td></tr></table></figure>
<p>包管理器在启动时读取 <code>platform.xml</code>，并维护「权限-GID」对应的列表。当它给安装中的包授权时，会把权限对应的 GID 加入到该应用进程的补充 GID 中。</p>
<p>我们举个例子，看下进程的属性：<code>adb shell ps</code> 拿到想要查找的进程的 <strong>PID</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">USER    PID  PPID     VSZ    RSS WCHAN            ADDR S NAME</div><div class="line">...</div><div class="line">u0_a88  2149  1624 1929916 112340 SyS_epoll_wait      0 S com.feelschaotic.demo</div></pre></td></tr></table></figure>
<p>接着 <code>adb shell</code> -&gt; <code>cd proc</code> -&gt; <code>cd 2149 (2149 为进程 PID，不固定)</code> -&gt; <code>cat status</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-78a6a4fc1fab64d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们关注如下两行：</p>
<p>Gid:    10050   10050   10050   10050<br>Groups: 1006 1015 1028 3002 3003 50050  </p>
<p>这里我们便看到了系统进程的权限配置信息，这里的数字具体代表意义，可以在Android<br><code>\system\core\include\private\android_filesystem_config.h</code> 里面看到，其部分内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define AID_CAMERA 1006  /* camera devices */  </div><div class="line">#define AID_SDCARD_RW 1015 /* external storage write access */</div><div class="line">#define AID_SDCARD_R 1028 /* external storage read access */</div><div class="line">···</div><div class="line">static const struct android_id_info android_ids[] = &#123;</div><div class="line">&#123; &quot;camera&quot;,    AID_CAMERA, &#125;,</div><div class="line">&#123; &quot;sdcard_r&quot;, AID_SDCARD_R, &#125;,</div><div class="line">&#123; &quot;sdcard_rw&quot;, AID_SDCARD_RW, &#125;,</div><div class="line">	···</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>有没有发现什么？前文所述 <code>sdcard_r</code> 和 <code>android.permission.READ_EXTERNAL_STORAGE</code> 的映射已经定义在 <code>/etc/permission/platform.xml</code> 中了，此处 <code>sdcard_r</code> 映射 <code>AID_SDCARD_R</code> 对应 gid = 1015，这就是权限映射到 gid 的整个关系。</p>
<p>总共分为三层：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-95d28ab0d74a33ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>那么第二个问题，当我们安装应用完成，启动应用，应用的进程是如何启动并被赋予进程属性的呢？</p>
<p>每个应用都会运行在自己的 Dalvik 虚拟机进程中，但是为了提高启动效率，Android 不会为每个应用都新建一个 Dalvik 进程，而是采用 fork 的形式。每个进程都 fork form zygote 进程。</p>
<p>那么 fork 比起 new ，效率提高在哪里？</p>
<p>因为 zygote 进程已经预加载了大部分核心和 Java 应用框架库，fork 的子进程会继承 zygote 的进程空间，也就是说，fork 的子进程，可以共享这些预加载的副本（记住，是副本，不是直接共享。fork 时，会 copy-on-write 预加载的内容），减少了重新加载核心库的时间。</p>
<p>当 zygote 收到启动新进程的请求时，它会 fork 自身出一个子进程，并对该子进程做特殊化处理。其源代码位于 <code>dalvik/vm/native/dalvik_system_Zygote.c</code> 中。<code>forkAndSpecializeCommon()</code> 的主要代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static pid_t forkAndSpecializeCommon(const u4* args, boolisSystemServer)  </div><div class="line">&#123;  </div><div class="line"> ...  </div><div class="line"> pid = fork();  //创建新进程  </div><div class="line"> if (pid == 0)  //判断是否是root，有没有权限修改自己的进程属性</div><div class="line"> &#123;  </div><div class="line">  setgroupsIntarray(gids);  //设置进程的所有组  </div><div class="line">  setrlimitsFromArray(rlimits);  </div><div class="line">  setgid(gid);    //设置进程的组ID  </div><div class="line">  setuid(uid);    //设置进程的用户ID  </div><div class="line">     &#125;  </div><div class="line">  ...  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示：这里设置进程的组 ID 和用户 ID，通过 fork 创建的子进程调用 setgroups Intarray 设置该进程所属的组，这样应用程序就拥有了该组的权限，并且可以通过 <code>setgid()</code> 及 <code>setuid()</code> 确定应用程序的 GID 及 UID 值。刚刚开始 fork 时，子进程是以 root 执行的，所以它可以更改自己的进程属性，当属性都设置完成，子进程就以分配的 GID 和 UID 执行，此时，子进程无法再更改自己的进程属性了，因为用户 ID 已经不是 root 即 ! = 0 了，没有修改自己进程属性的权限了。</p>
<p><code>adb shell ps</code>，看下进程列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME</div><div class="line"></div><div class="line">root             1     0   10456   2352 SyS_epoll_wait      0 S init</div><div class="line">...</div><div class="line">root          1620     1 1614572  20312 poll_schedule_timeout 0 S zygote</div><div class="line">...</div><div class="line">u0_a88        3468  1620 1929916 112340 SyS_epoll_wait      0 S com.feelschaotic.demo</div><div class="line">u0_a90        3574  1620 1696012  24176 SyS_epoll_wait      0 S com.demo.pushdemo</div><div class="line">u0_a90        3607  1620 1708844  26748 SyS_epoll_wait      0 S com.demo.pushdemo:mult</div><div class="line">u0_i0         3741  1879 1557800  11720 SyS_epoll_wait      0 S com.android.chrome:sandboxed</div><div class="line">u0_a15        3774  1620 1690604  22056 SyS_epoll_wait      0 S com.google.android.ext.services</div><div class="line">system        3805  1620 1687840  19688 SyS_epoll_wait      0 S com.android.keychain</div><div class="line">u0_a42        3831  1620 1834408  45660 SyS_epoll_wait      0 S com.android.chrome</div><div class="line">...</div></pre></td></tr></table></figure>
<p>PID 表示应用的进程 ID，PPID 表示父进程 ID，NAME 表示进程名称（一般情况下 NAME 是应用包名）。可以看到 zygote 进程是由 init 进程启动，所有的应用进程的父进程都是 zygote。USER 表示的是进程的专有用户，这个我们下次再详细讲讲 Android 的用户管理机制。</p>
<p>好了，既然如此，每个应用进程都分配好自己的 GID、UID和补充 GID，系统内核和守护进程就可以用这些标识来决定，是否要赋予进程权限。</p>
<h3 id="权限检查（权限执行）"><a href="#权限检查（权限执行）" class="headerlink" title="权限检查（权限执行）"></a>权限检查（权限执行）</h3><h4 id="1-系统内核层权限检查"><a href="#1-系统内核层权限检查" class="headerlink" title="1. 系统内核层权限检查"></a>1. 系统内核层权限检查</h4><p>思考一下：如果我们的应用没有在 <code>AndroidManifest.xml</code> 中申请 <code>android.permission.INTERNET</code> 权限就进行网络请求，是不是会报 <code>Permission denied</code> 错误。这个权限，是谁来检查？其他进程来检查吗？明显不是，网络访问权限是由低层来进行控制的。</p>
<p>Android 的访问控制，和 Linux 是一样的，但 Android 增加了个<strong>特有的网络访问安全控制机制</strong>，也就是说，创建网络套接字的进程，必须属于 <code>inet</code> 组。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-325424a9d9b8813c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如上内核代码，<code>current_has_network(void)</code> 方法检查了进程的所在组。如果不在 <code>inet</code> 组，则直接返回错误。所以为了使我们的应用具有访问网络的能力，我们需要在 <code>AndroidManifest.xml</code> 中申请 <code>INTERNET</code> 权限，经过解析，逐步映射到内核层的组 ID 和用户 ID，最终才能通过内核层的检查。</p>
<p>你可能会有疑问，那非内核层的其他 C/C++ 层，要怎么拿到进程的所在组信息呢？</p>
<p>在 PMS 初始化所有包信息之后,就会调用 mSettings.writeLPr()。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-1fe6ee34048c12aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-d9ba4916e35d43f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这段代码的任务就是将mPackages 中保存的所有包的信息保存到 <code>/data/system/packages.list</code>。所以，packages.list中保存了所有应用申请的权限，C代码只要读这个文件就能判断某个应用是否申请了我们要求的权限。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-1e0b994c21f7ece6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="2-框架层"><a href="#2-框架层" class="headerlink" title="2. 框架层"></a>2. 框架层</h4><p>因为 Android 6.0 之前组件不能在运行时改变权限，所以系统的权限检查执行过程是静态的。这个情况下，组件的角色和权限的等安全属性会被放置在元数据中，即 <code>AndroidManifest.xml</code> 文件中，而不是组件的本身。系统包管理器会负责记录组件的权限，所以静态权限检查可以从包管理器拿到权限，由运行环境或容器来执行权限检查，这样子可以把业务逻辑和安全决策分离开来，但是灵活性不足。</p>
<p>那 Android 组件可不可以不预先声明权限在 <code>AndroidManifest.xml</code> 中呢？答案是：可以的。Android 的动态权限执行，可以让组件自身执行权限检查，而不是运行环境。</p>
<p>所以接下来我们将深入了解框架层的动态和静态权限执行的原理。</p>
<h5 id="动态权限执行"><a href="#动态权限执行" class="headerlink" title="动态权限执行"></a>动态权限执行</h5><p>动态权限执行，最典型的场景，就是 IPC。Android 的核心系统服务统一会注册到服务管理器，任何应用，只要知道服务的注册名称，就可以拿到对应的 Binder引用，就可使用 Binder IPC 机制调用服务。因为 Binder 没有内置的访问控制机制，所以每个系统服务需要自己实现访问控制机制。</p>
<p>系统服务可以直接检查调用者的 UID，通过限定 UID 来控制访问权限，这种方式简单直接，但是对于非固定UID的应用，就比较棘手了。而且大部分服务，并不关心调用者的 UID，只需要检查调用者是否被赋予特定的权限即可。所以这种方式，比较适合只允许以 root（UID：0） 或 system（UID：1000） 运行的进程访问的服务检查。</p>
<p>那换一种方式，服务怎么拿到调用者的权限列表？我们知道，大部分 UID 都是和包一一对应的，除了共享 UID。（共享 UID 后面再详细解释）</p>
<p>使用 <code>Binder.getCallingUid()</code> 和 <code>Binder.getCallingPid()</code> 获取调用者的 UID 和 PID，通过 UID 在包管理器中查询到对应应用的权限。android.content.Context 类中就有 <code>checkPermission(String permission, int pid, int uid)</code> 方法。实质上会调用到 PMS 中的 <code>checkUidPermission(String perName, int uid)</code>，如下：</p>
<ul>
<li><strong>Android 6.0 以下 PMS 中的 <code>checkUidPermission(String perName, int uid)</code></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int checkUidPermission(String permName, int uid) &#123;</div><div class="line">    synchronized (mPackages) &#123;</div><div class="line">        Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));</div><div class="line">        if (obj != null) &#123;</div><div class="line">            GrantedPermissions gp = (GrantedPermissions)obj;</div><div class="line">            if (gp.grantedPermissions.contains(permName)) &#123;</div><div class="line">                return PackageManager.PERMISSION_GRANTED;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            HashSet&lt;String&gt; perms = mSystemPermissions.get(uid);</div><div class="line">            if (perms != null &amp;&amp; perms.contains(permName)) &#123;</div><div class="line">                return PackageManager.PERMISSION_GRANTED;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return PackageManager.PERMISSION_DENIED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android 6.0 以下的 <code>checkUidPermission()</code> 方法比较简单，首先，基于入参 uid 获取应用的 appId，拿到权限列表对象（也就是 <code>packages.xml</code> 里的 <code>&lt;package&gt;</code> 映射），如果 <code>GrantedPermissions</code> 类中的 <code>grantedPermissions</code> 集合包含目标权限，则检查通过。</p>
<p>如果没有该 <code>GrantedPermissions</code> 对象，则检查目标权限是否可以被自动授予，实际上 <code>mSystemPermissions</code> 就是 <code>platform.xml</code> 文件中的 <code>&lt;assing-permission&gt;</code> 标签映射缓存，记录了一些系统级应用的 uid 对应的 permission。例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&lt;assign-permission name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; uid=&quot;cameraserver&quot; /&gt;</div><div class="line">&lt;assign-permission name=&quot;android.permission.ACCESS_SURFACE_FLINGER&quot; uid=&quot;cameraserver&quot; /&gt;</div><div class="line">&lt;assign-permission name=&quot;android.permission.UPDATE_DEVICE_STATS&quot; uid=&quot;cameraserver&quot; /&gt;</div><div class="line">&lt;assign-permission name=&quot;android.permission.ACCESS_SURFACE_FLINGER&quot; uid=&quot;graphics&quot; /&gt;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>Android 6.0 及以上 PMS 中的 <code>checkUidPermission(String perName, int uid)</code></strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public int checkUidPermission(String permName, int uid) &#123;</div><div class="line">       final int callingUid = Binder.getCallingUid();</div><div class="line">       final int callingUserId = UserHandle.getUserId(callingUid);</div><div class="line">       final boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;</div><div class="line">       final boolean isUidInstantApp = getInstantAppPackageName(uid) != null;</div><div class="line">       final int userId = UserHandle.getUserId(uid);</div><div class="line">       if (!sUserManager.exists(userId)) &#123;</div><div class="line">           return PackageManager.PERMISSION_DENIED;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       synchronized (mPackages) &#123;</div><div class="line">           Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));</div><div class="line">           if (obj != null) &#123;</div><div class="line">               ...</div><div class="line">               final SettingBase settingBase = (SettingBase) obj;</div><div class="line">               final PermissionsState permissionsState = settingBase.getPermissionsState();</div><div class="line">               if (permissionsState.hasPermission(permName, userId)) &#123;</div><div class="line">                   if (isUidInstantApp) &#123;</div><div class="line">                       BasePermission bp = mSettings.mPermissions.get(permName);</div><div class="line">                       if (bp != null &amp;&amp; bp.isInstant()) &#123;</div><div class="line">                           return PackageManager.PERMISSION_GRANTED;</div><div class="line">                       &#125;</div><div class="line">                   &#125; else &#123;</div><div class="line">                       return PackageManager.PERMISSION_GRANTED;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               ...</div><div class="line">           &#125; else &#123;</div><div class="line">               ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid);</div><div class="line">               if (perms != null) &#123;</div><div class="line">                   if (perms.contains(permName)) &#123;</div><div class="line">                       return PackageManager.PERMISSION_GRANTED;</div><div class="line">                   &#125;</div><div class="line">                   ...</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return PackageManager.PERMISSION_DENIED;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以注意到，6.0 之后 <code>checkPermission()</code> 方法有所改变。多了从  <code>mSettings.mPermissions</code> 去查询权限列表。</p>
<p>关键就在于这个 mSettings 里面保存的这个 SettingBase 对象，它记录了 PermissionsState 也就是权限的授予情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// PermissionsState.java</div><div class="line">public boolean hasPermission(String name, int userId) &#123;</div><div class="line">    enforceValidUserId(userId);</div><div class="line"></div><div class="line">    if (mPermissions == null) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    PermissionData permissionData = mPermissions.get(name);</div><div class="line">    return permissionData != null &amp;&amp; permissionData.isGranted(userId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以检查权限的流程是本来就有的，6.0 之后差异仅在于：危险级别权限可以动态修改授权情况，也就是修改 <code>PermissionState</code> 的 <code>mGranted</code> 值，所以每次权限执行，都会查询下 <code>mGranted</code> 值。</p>
<h5 id="静态权限执行"><a href="#静态权限执行" class="headerlink" title="静态权限执行"></a>静态权限执行</h5><p>静态权限执行的典型场景，是跨应用组件交互。</p>
<p>我们使用隐式 Intent 来表达意图，搜索匹配的组件，如果有多个，弹出选择框，目标组件被选定后，会由 ActivityManagerService 执行权限检查，检查目标组件是否有相应的权限要求，如果有，则把权限检查的工作交给 PMS，去检查调用者有没有被授权这些权限。</p>
<p>接下来的总体的流程和动态执行流程大致相同：<code>Binder.getCallingUid()</code>和<code>Binder.getCallingPid()</code>获取调用者的 UID 和 PID，然后利用 UID 映射包名，再获得相关权限集合。如果权限集合中含有所需权限即启动，否则抛出 SecurityException 异常。</p>
<p>静态权限执行这里，我们可以详细了解下，每种组件的权限检查时机和具体顺序是怎么样的。</p>
<h5 id="组件权限执行"><a href="#组件权限执行" class="headerlink" title="组件权限执行"></a>组件权限执行</h5><p>思考一下，什么时候会执行对调用者的权限检查？那肯定是在目标组件被调用的时候，去解析目标组件声明的权限，如果有，就执行权限检查。</p>
<ul>
<li>Activity 和 Service</li>
</ul>
<p>Activity 显而易见，会在 <code>startActivity()</code> 和 <code>startActivityForResult()</code> 里解析到声明权限的 Activity 时，就执行权限检查。</p>
<p>而 Service <code>startService()</code>、<code>stopService()</code> 和 <code>bindService()</code>，这 3 个方法被调用时都会进行权限检查。</p>
<ul>
<li>广播</li>
</ul>
<p>我们注意到，发送广播除了常用的 <code>sendBroadcast(Intent intent)</code>，还有个 <code>sendBroadcast(Intent intent, String receiverPermission)</code>，该方法可以要求广播接受者具备特定的权限，但是，调用 <code>sendBroadcast</code> 是不会进行权限检查的，因为广播是异步的，所以权限检查会在 intent 传递到已注册的广播接受者时进行，如果接收者不具备特定的权限，则不会接收到该广播，也不会收到 SecurityException 异常。</p>
<p>反过来，接收者可以要求广播发送者必须具备的权限，所要求的权限在 manifest 文件中设置 <code>&lt;receiver&gt;</code> 标签的 permission 属性，或者动态注册时指定 <code>registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)</code>，权限检查也是在广播传递时执行。</p>
<p>所以，收发广播可以分开指定权限。值得一提的是，一些系统广播被声明为 protected，并且只能由系统进程发送，比如 <code>PACKAGE_INSTALLED</code>。只能由系统进程发送，这个限制会在内核层进行检查，对调用者的 UID 进行匹配，只能是 SYSTEM_UID、PHONE_UID、SHELL_UID、BLUETOOTH_UID 或 root。如果其他 UID 的进程试图发送系统广播，则会收到 SecurityException 异常。</p>
<blockquote>
<p>想了解所有的系统广播，可以打开<code>/system/framework/framework-res.apk</code> 中的 <code>AndroidManifest.xml &lt;protected-broadcast&gt;</code> 标签详细了解。</p>
</blockquote>
<ul>
<li>ContentProvider</li>
</ul>
<p>ContentProvider 可以为读写分别指定不同的权限，即：调用目标 provider、<code>query()</code> 方法 和 <code>insert()</code>、<code>update()</code>、<code>delete()</code> 都会进行权限检查。</p>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>综上所述，Android 的权限的检查会在各个层次上实施。</p>
<p>高层的组件，例如应用和系统服务，通过包管理器查询应用程序被赋予的权限，并决定是否准予访问。</p>
<p>低层的组件，通常不访问包管理器，比如本地守护进程，依赖于进程的 UID、GID 和补充 GID 来决定赋予。</p>
<p>访问系统资源时，如设备文件、UNIX 域套接字和网络套接字，则由内核根据所有者、目标资源的访问权限和访问进程的进程属性或者 <code>packages.list</code> 来进行控制。</p>
<h3 id="共享-UID"><a href="#共享-UID" class="headerlink" title="共享 UID"></a>共享 UID</h3><p>最后简单说下共享 UID，填一下前面挖的坑。虽说 Android 会为每一个应用分配唯一的 UID，但如果应用使用相同的密钥签发，就可以使用相同 UID 运行，也就是运行在同一个进程中。</p>
<p>这个特性被系统应用和核心框架服务广泛使用，比如：Google Play 和 Google 定位服务，请求同一进程内的 Google 登录服务，从而达到静默自动同步用户数据的体验。</p>
<p>值得注意的是：Android 不支持将一个已安装的应用，从非共享 UID 切换到共享状态，因为改变了已安装应用的 UID，会导致应用失去对自己文件的访问权限（在一些早期 Android 版本中），所以如果使用共享 UID 必须从一开始就设计好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Android将安全设计贯穿系统架构的各个层面，覆盖系统内核、虚拟机、应用程序框架层以及应用层各个环节，力求在开放的同时，也最大程度地保护用户的数据、应用程序和设备的安全。Android安全模型主要提供以下几种安全机制：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3167794-6d77a9733cf9b413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>目标方法前置检验模型设计与实现</title>
    <link href="http://yoursite.com/2018/04/04/new/%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E5%89%8D%E7%BD%AE%E6%A3%80%E9%AA%8C%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/04/04/new/目标方法前置检验模型设计与实现/</id>
    <published>2018-04-04T13:43:00.000Z</published>
    <updated>2018-12-18T12:29:58.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://www.jianshu.com/p/ed880f35f97f" target="_blank" rel="external">继上次的指纹验证</a>后，产品又提出了个项目典型需求：用户在未登录状态下，点击关注，跳转登录，登录成功后自动执行关注。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这里有两个需求：</p>
<ol>
<li>自动跳转到登录界面</li>
<li>登录成功后再自动执行关注行为</li>
</ol>
<p>思考下抽象出通用性，首先，我们的目的是执行关注行为，但是关注行为需要用户处于登录状态。也就是说执行某个操作时需要满足一些前提条件，而这些前提条件是需要用户参与才能满足。可能存在多个前提条件的需求，这里可以分离出目标行为和前提条件行为。</p>
<a id="more"></a>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>那就登录页面加个回调喽，登录成功就回调回去，不过，我们可不想在登录界面侵入太多逻辑代码，而且也违背了可维护性和通用性，难道以后扩展时，每个前置条件都要加回调？</p>
<p>再思考，第一想法是利用事件通知机制（EventBus、BroadcastReceiver），把登录成功这个事件 post 出去，异步执行关注行为。但如果前提条件有多个呢，是不是得发送多个事件？是不是得监听多个事件？而且，如果下次需求改了，目标事件不是执行关注事件了，而是执行发帖或者跳转到某个页面，那之前关注行为已经注册了，还是会通知到关注事件，难道要通过 msg 标志位来区分不同的目标行为吗？有没有更优雅简洁的方式呢？</p>
<p>再思考，如果用拦截器呢？</p>
<p>这种行为模式和拦截器非常相似，都是在执行目标前，判断是否符合条件。</p>
<p>但是拦截器似乎并不能直接完成我们的需求，因为我们需要插入一个验证行为后（例如进入登录界面），还要执行相应的操作，保证这个验证行为通过后，才能真正执行我们的目标行为。拦截器执行完后，马上会执行目标方法。中间并不会等待。所以我们根本没有办法去执行我们的登录操作，所以pass了。</p>
<p>那设计模式里的责任链模式，能不能提供点什么思路呢？</p>
<p>在责任链模式里，很多的处理对象由每一个对象对其下家的引用而联接起来形成一条链。请求在这个链上传递，直到链上的<strong>某一个</strong>对象决定处理此请求。<strong>注意，是某一个</strong>！而我们的场景是，需要通过<strong>所有的</strong>前置条件验证，才能执行目标方法。</p>
<h3 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h3><p>思考可以改良一下责任链，每一个前置条件对象（<code>Valid</code>类）不再持有其下家的引用，而是采用一个队列存储所有的前置条件对象，以先进先出的顺序依次验证条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private Queue&lt;Valid&gt; validQueue = new ArrayDeque&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>前置条件对象抽象为接口<code>Valid</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface Valid &#123;</div><div class="line">    /**</div><div class="line">     * 是否满足检验器的要求，如果不满足的话，则执行doValid()方法。如果满足，则执行目标action.call</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    boolean preCheck();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 去执行验证前置行为，例如跳转到登录界面。（但并未完成验证。所以需要在登陆成功时调用preCheck()再次检查）</div><div class="line">     */</div><div class="line">    void doValid();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，我们把前置条件对象的验证条件和操作分离开来。</p>
<p>目标对象<code>Action</code>就很简单了，仅拥有一个目标执行方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Action &#123;</div><div class="line">    void call();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整体的验证流程，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2159256-91dedfb30a1c140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>循环从前置条件对象队列 <code>validQueue</code> 里取出验证对象，调用 check 方法判断是否满足条件，不满足则进入该验证对象的验证流程，验证完毕，再次调用 check 方法判断满足条件，如果满足则取下一个，直至队列为空，就可以直接执行目标方法了。</p>
<p>那么前置条件对象队列 <code>validQueue</code> 和目标对象的持有方，我们封装为 <code>Call</code>，意为一次执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Call &#123;</div><div class="line">    //目标对象 </div><div class="line">    private Action action;</div><div class="line">    //先进先出验证模型</div><div class="line">    private Queue&lt;Valid&gt; validQueue = new ArrayDeque&lt;&gt;();</div><div class="line">    //上一个执行的valid</div><div class="line">    private Valid lastValid;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>包装一个单例的持有Call对象的外观类 <code>SingleCall</code>，提供给业务层调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class SingleCall &#123;</div><div class="line"></div><div class="line">    private Call call = new Call();</div><div class="line"></div><div class="line">    public SingleCall addAction(Action action) &#123;</div><div class="line">        clear();</div><div class="line">        call.setAction(action);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public SingleCall addValid(Valid valid) &#123;</div><div class="line">        //只添加无效的，验证不通过的</div><div class="line">        if (valid.preCheck()) &#123;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        call.addValid(valid);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void doCall() &#123;</div><div class="line">        //如果上一条valid没有通过，是不允许再发起call的</div><div class="line">        if (call.getLastValid() != null &amp;&amp; !call.getLastValid().preCheck()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果全部都验证通过了，执行action</div><div class="line">        if (call.getValidQueue().size() == 0) &#123;</div><div class="line">            if (call.getAction() != null) &#123; //容错处理</div><div class="line">                call.getAction().call();</div><div class="line">                clear();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            //执行验证</div><div class="line">            Valid valid = call.getValidQueue().poll();</div><div class="line">            call.setLastValid(valid);</div><div class="line">            valid.doValid();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    .....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用示例（常用场景，单 Action）：</p>
<p><code>Activity</code> 实现 <code>Action</code> 接口，或 new 一个<code>Action</code> 实现类，实现 call 目标行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SingleCall.getInstance()</div><div class="line">          .addAction(ActionActivity.this)</div><div class="line">          .addValid(new LoginValid())//前置条件，可能有多个</div><div class="line">          .addValid(new OtherValid()</div><div class="line">          .doCall();</div></pre></td></tr></table></figure>
<p>前置行为完成后，调用 <code>SingleCall.getInstance().doCall();</code> 重新启动验证模型。因为验证操作需要用户手动触发完成，我们只是引导用户到了验证体里，由于我们因为等待用户的操作，验证模型就在这里停下来了，如果验证操作成功了，我们需要让整个验证模型再运转起来了，所以验证后，永远少不了手动开启验证模型。</p>
<p>以下是整个模型的类 UML 图，重点梳理 Valid、Call、Action 三者的关系：<br><img src="https://upload-images.jianshu.io/upload_images/3167794-af92e0f102172d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类关系图"></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><img src="http://upload-images.jianshu.io/upload_images/3167794-d890b097a75d4dec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/feelschaotic/DelayAction" target="_blank" rel="external">github 源码地址</a></p>
<ul>
<li>增加了容错处理</li>
<li>补充了嵌套 Call 的情况</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/22a9d4eb07ce" target="_blank" rel="external">在执行目标操作前，插入N个需要用户参与的操作，简化此过程</a></li>
<li><a href="https://www.jianshu.com/p/1d0180ec64fb" target="_blank" rel="external">android 登录成功后再跳转到目标界面的思考</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/ed880f35f97f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;继上次的指纹验证&lt;/a&gt;后，产品又提出了个项目典型需求：用户在未登录状态下，点击关注，跳转登录，登录成功后自动执行关注。&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;这里有两个需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动跳转到登录界面&lt;/li&gt;
&lt;li&gt;登录成功后再自动执行关注行为&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思考下抽象出通用性，首先，我们的目的是执行关注行为，但是关注行为需要用户处于登录状态。也就是说执行某个操作时需要满足一些前提条件，而这些前提条件是需要用户参与才能满足。可能存在多个前提条件的需求，这里可以分离出目标行为和前提条件行为。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何在复杂业务场景中优雅实现Android指纹验证？</title>
    <link href="http://yoursite.com/2018/02/15/new/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%AD%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0Android%E6%8C%87%E7%BA%B9%E9%AA%8C%E8%AF%81%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/02/15/new/如何在复杂业务场景中优雅实现Android指纹验证？/</id>
    <published>2018-02-15T03:27:00.000Z</published>
    <updated>2018-12-18T12:30:03.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前指纹领域无论从产品角度还是技术角度都已经趋于成熟，但是当各位开发者准备深入探究的时候，却发现网上很多文章都是皮毛，很难有较深的启示。本文将着重介绍指纹验证开发整个过程，包括技术选型、产品的设计方案逻辑、代码的架构以及后续测试中遇到的兼容性问题等几个方面。在这里抛砖引玉，希望能给予大家一些启发。</p>
<a id="more"></a>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p><strong>产品</strong>：咱们 Android 端能做指纹验证吗？<br><strong>开发</strong>：不能，一堆兼容问题。<br><strong>产品</strong>：咱们 Android 端能做指纹验证吗？<br><strong>开发</strong>：不能，一堆兼容问题。<br><strong>产品</strong>：咱们 Android 端能做指纹验证吗？<br><strong>开发</strong>：不能，一堆兼容问题。<br><strong>产品</strong>：咱们 Android 端能做指纹验证吗？<br><strong>开发</strong>：我……我试试吧……  </p>
<p>着手调研，开发前肯定先拿市面上竞品的功能来瞧瞧。我们同比了支付宝、微信支付和招商App。</p>
<p><strong>产品</strong>：怎么支付宝和微信就没兼容问题了？  </p>
<p><strong>开发</strong>：那是因为支付宝和腾迅有自己的协议！（一听怎么XXX支持，怎么XXX没问题，升起无名火）这个标准直接和设备厂商合作，而应用方只有微信和支付宝自己。支付宝指纹支付标准是 IFAA ，腾讯的指纹支付标准是 SOTER，也就是说没有其他应用方会使用这个标准。所以很看应用方和设备厂商的协商程度。现在 IFAA 没有开源，只有 SOTER 是开源的了，如果接入，我们能省去兼容性测试的工作量，而且有些 6.0 以下的机型 SOTER 也支持。还有！（星星眼）每个指纹将会有唯一 ID，也就是说，我们能把账号和指纹绑定起来，更加安全。</p>
<p><strong>产品</strong>：不行不行！这 SOTER 压根没支持华为，华为用户是我们的主要用户群，而且以后机型的扩展受第三方支持的限制。  </p>
<p><strong>开发</strong>：之前小米和华为就没有支持 SOTER 标准，现在小米是支持了，华为不见得会支持，因为 SOTER 和厂商合作，出厂的时候就将私钥存储在 TEE 中，华为目前多 TEE 系统开发尚未成熟，只能支持一个 TEE ，显然华为不愿意将唯一的 TEE 交给腾讯掌控。其他手机厂商一般使用高通或第三方的 TEE 系统方案，这些系统目前都支持多 TEE 运行环境，即使将其中一个 TEE 的公共密钥交给腾讯运营，并不影响手机厂商运营自己的 TEE 平台。</p>
<p><strong>产品</strong>：不接入了，我们用 Google API。  </p>
<p><strong>开发</strong>：那好，来制定下条件先：</p>
<ol>
<li>设备硬件不支持直接没得玩</li>
<li>手机要有除了指纹外的安全认证方式（比如密码、图案） ，这是安卓系统的双重锁规则。</li>
<li>用户手机至少录入了一个指纹，没录入指纹说明平时没有用过指纹验证功能，这种用户我们就不管了。</li>
<li>使用 Google API，不管什么情况，只要验证的指纹是系统指纹列表里存在的，就验证通过，Google API 是没有提供指纹唯一ID的，所以想要根据本机上的指纹索引来区别不同手指无法做到，也就无法实现指纹和账号绑定。</li>
<li>仅支持 Android 6.0 以上系统，Google 官方支持指纹识别的标准接口是在 Android6.0 开始的，如果厂商在这之前就已经做了指纹识别，那我们就不管了。（开发者也可以使用厂商提供的第三方指纹识别SDK）</li>
</ol>
<p><strong>产品</strong>：（点头）可以，开干吧！用 Google API 兼容性问题处理和测试量较大，所以我们支持的机型做成可配置，控制风险。第一期先支持几个机型。</p>
<blockquote>
<ul>
<li><a href="https://github.com/googlesamples/android-FingerprintDialog" target="_blank" rel="external">Google官方Sample</a></li>
<li><a href="https://cloud.tencent.com/community/article/691837" target="_blank" rel="external">SOTER 介绍</a><br><a href="https://mp.weixin.qq.com/s/IRI-RCGsVB2WiPwUCGcytA" target="_blank" rel="external">SOTER 支持机型</a><br><a href="https://github.com/Tencent/soter" target="_blank" rel="external">SOTER SDK地址</a>  </li>
<li><a href="http://open.yunos.com/doc/detail?documentId=102937#" target="_blank" rel="external">阿里指纹</a></li>
<li>IFAA暂无开源  </li>
</ul>
<p>2018.12.10 更新<br>SOTER 已支持部分华为机型<a href="https://github.com/Tencent/soter/wiki" target="_blank" rel="external">SOTER 支持机型 wiki</a></p>
</blockquote>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>好了，demo 写完了，看下了产品文档。啥？场景这么复杂？！分支繁多，还需要结合到之前存在的手势验证功能（用户有两种安全方式可选：指纹验证和手势验证）。</p>
<p>业务场景有四个：</p>
<ol>
<li>冷启动app的指纹验证</li>
<li>切换账号登陆后的引导设置</li>
<li>在设置页用户手动开启指纹登陆</li>
<li>设置页手动关闭指纹登陆</li>
</ol>
<p>每一次验证的状态，都会通过 AuthenticationCallback 回调，我们可以理解为是指纹验证的生命周期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class MyAuthCallback extends FingerprintManagerCompat.AuthenticationCallback &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onAuthenticationSucceeded(FingerprintManagerCompat.AuthenticationResult result) &#123;</div><div class="line">            super.onAuthenticationSucceeded(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onAuthenticationError(int errMsgId, CharSequence errString) &#123;</div><div class="line">            //验证过程中遇到不可恢复的错误</div><div class="line">            super.onAuthenticationError(errMsgId, errString);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onAuthenticationFailed() &#123;</div><div class="line">            super.onAuthenticationFailed();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onAuthenticationHelp(int helpMsgId, CharSequence helpString) &#123;</div><div class="line">            //验证过程中遇到可恢复错误</div><div class="line">            super.onAuthenticationHelp(helpMsgId, helpString);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>onAuthenticationSucceeded 和 onAuthenticationError 的回调意味着本次的认证结束，会根据当前所处业务场景给予用户不同的引导。</p>
<p>而 onAuthenticationFailed 和 onAuthenticationHelp 的情况，四个业务场景都是一样的，都是在界面上提示用户，我们可以合并一起处理。</p>
<p>所以我们根本不需要一个业务场景就对应一个 AuthenticationCallback 回调类，我们可以只用一个 AuthenticationCallback 回调类来根据当前所处的业务场景分发行为。但是我又不想在 onAuthenticationSucceeded 和 onAuthenticationError 的回调中有 Switch 逻辑。所以对于四个场景各不相同的 onAuthenticationSucceeded 和 onAuthenticationError 的回调方法，我们用状态模式来分离，这样把与特定状态相关的行为局部化，并且将不同场景下的行为分割开来。（需要给用户什么提示，什么操作，包括验证次数超限的处理，取决于当前所处的场景状态）</p>
<p>另外一点：<strong>需要在运行时刻根据状态来改变行为</strong>，比如说用户从一个正常态，转移到验证过程异常或者验证过程被劫持的状态。</p>
<p>验证过程异常情况，也即是说，受用户 root 或自定制情况，通过测试的同一个机型有可能验证过程异常。</p>
<p>验证过程被劫持，因为 Google API 只返回 true 或 false，我们当然不能无条件相信这个验证结果，所以需要在应用内产生一对非对称的密钥，保证验证过程不会被篡改。如果拿到验证结果解密失败，就进入了被劫持的状态了。</p>
<p>验证过程异常和验证被劫持的状态基本处理一致，都是属于用户无法再继续验证的场景，我们可以把这两个状态合为一。按照开发的思路，有异常，被劫持，那肯定是失败了，是吧？ 但是按照产品的思路，其他 3 个业务场景按失败处理，但如果是关闭指纹的场景下（4. 设置页手动关闭指纹登陆），就算是失败了，也要让他去关闭成功，不然可能会出现用户手机中途 root 或极端情况下，无法关闭指纹，从而引起客诉。</p>
<p>按照分析我们可以发现，被劫持和验证过程异常的情况的处理，依赖于当时所处的场景，所以呢，我们无法把被劫持和验证过程异常当做一个独立的状态了。只能抽出作为一个公共方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-7d0ce6d65f2dc776.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="绿色底为 Activity 层，白色底为 Util 层"></p>
<p>为了不和业务逻辑耦合在一起，工具类包装了一层，主要封装了验证条件的判断，指纹类的初始化等等，最主要的是封装了加密类 CryptoObjectCreatorHelper ，我们考虑到安全因素，如果不加密的话，就意味着App 无条件信任认证的结果，这个过程可能被攻击，数据可以被篡改，这是 App 在这种情况下必须承担的风险。但是这个加密过程和业务是无关的，我们不想让 Activity 层感知到，所以密钥和加密对象的销毁，会统一由工具类来把控。</p>
<p>为了安全，每次验证过程的密钥都不同，验证过程一结束，也就是回调 onAuthenticationSucceeded 和 onAuthenticationError 时，都需要销毁掉密钥，但是我们不想让业务层来操作，所以工具类也有自己的一个 AuthenticationCallback ，在 AuthenticationCallback 里做一些和业务无关的操作，再回调 Activity 的 AuthenticationCallbackListener 。</p>
<p>工具类的 CallBack 是 FingerprintManagerCompat.AuthenticationCallback 实现类，业务层的 AuthenticationCallbackListener 是自定义接口，因为不想把和业务无关的往上传递，比如说，验证成功的 AuthenticationResult ，验证错误的 typeId，这些业务并不关心。Activity 的 AuthenticationCallbackListener 会把请求统一转发给控制器 FingerPrintTypeController，在转发给控制器的前后，我们可以做一些通用的业务操作，比如说停止界面的扫描动画，发一些异步的请求等等，这个就是代理模式的应用了。</p>
<p>那控制器 FingerPrintTypeController 和四个场景的关系又是如何？我们看看类图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-62681137c1d22e4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，四个场景，对应四个状态类，控制器和状态类实现了同一个接口，在内部根据当前场景转发给对应的类， 那怎么根据场景转发给对应类？我们建立一个映射表，把场景和类对应起来。每次匹配的话只要 O(1) 复杂度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">private interface FingerPrintType &#123;</div><div class="line">       void onAuthenticationSucceeded();</div><div class="line"></div><div class="line">       void onAuthenticationError(String content);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">private class LoginAuthType implements FingerPrintType &#123;</div><div class="line">       @Override</div><div class="line">       public void onAuthenticationSucceeded() &#123; &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onAuthenticationError(String content) &#123; &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private class ClearType implements FingerPrintType &#123;</div><div class="line">       @Override</div><div class="line">       public void onAuthenticationSucceeded() &#123; &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onAuthenticationError(String content) &#123; &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private class LoginSettingType implements FingerPrintType &#123;</div><div class="line">      @Override</div><div class="line">       public void onAuthenticationSucceeded() &#123; &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onAuthenticationError(String content) &#123; &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private class SettingType implements FingerPrintType &#123;</div><div class="line">       @Override</div><div class="line">       public void onAuthenticationSucceeded() &#123; &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onAuthenticationError(String content) &#123; &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private class FingerPrintTypeController implements FingerPrintType &#123;</div><div class="line">       private Map&lt;String, FingerPrintType&gt; typeMappingMap = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">       public FingerPrintTypeController() &#123;</div><div class="line">           typeMappingMap.put(GESTURE_FINGER_SETTING, new SettingType());</div><div class="line">           typeMappingMap.put(GESTURE_FINGER_LOGIN_SETTING, new LoginSettingType());</div><div class="line">           typeMappingMap.put(GESTURE_FINGER_CLEAR, new ClearType());</div><div class="line">           typeMappingMap.put(GESTURE_FINGER_LOGIN, new LoginAuthType());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onAuthenticationSucceeded() &#123;</div><div class="line">           typeMappingMap.get(mType).onAuthenticationSucceeded();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onAuthenticationError(String content) &#123;</div><div class="line">           typeMappingMap.get(mType).onAuthenticationError(content);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个时候产品又说了，同样是异常情况，但是被劫持和异常过程异常的提示文案要不一样，ok，那我们将提示语和操作分离开来，提示和业务场景的对应关系也预先缓存在 Map 里，直接 get 获取具体提示，作为参数传入就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//普通异常情况提示</div><div class="line">  exceptionTipsMappingMap = new HashMap&lt;&gt;();</div><div class="line">  exceptionTipsMappingMap.put(GESTURE_FINGER_SETTING, getString(R.string.fingerprint_no_support_fingerprint_gesture));</div><div class="line">  exceptionTipsMappingMap.put(GESTURE_FINGER_LOGIN_SETTING, getString(R.string.fingerprint_no_support_fingerprint_gesture));</div><div class="line">  exceptionTipsMappingMap.put(GESTURE_FINGER_CLEAR, null);</div><div class="line">  exceptionTipsMappingMap.put(GESTURE_FINGER_LOGIN, getString(R.string.fingerprint_no_support_fingerprint_account));</div></pre></td></tr></table></figure>
<h3 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h3><h6 id="1-明明符合条件，isHardwareDetected-返回-false？"><a href="#1-明明符合条件，isHardwareDetected-返回-false？" class="headerlink" title="1. 明明符合条件，isHardwareDetected() 返回 false？"></a>1. 明明符合条件，isHardwareDetected() 返回 false？</h6><p>表现机型：MI 5s、vivo X9</p>
<p>在同一机型上调用 FingerprintManagerCompat 的 isHardwareDetected() 和 hasEnrolledFingerprints() 时候，返回的都是 false,但是调用 FingerprintManager 的 isHardwareDetected()<br> 和 hasEnrolledFingerprints() 时，却是返回 true。</p>
<p><strong>解决</strong>：是否符合指纹条件可以多加一层判断。</p>
<h6 id="2-Letv-X500-Android-6-0-API23-不按正常的套路回调"><a href="#2-Letv-X500-Android-6-0-API23-不按正常的套路回调" class="headerlink" title="2. Letv X500 Android 6.0,API23   不按正常的套路回调"></a>2. Letv X500 Android 6.0,API23   不按正常的套路回调</h6><p>onAuthenticationError 和 onAuthenticationFailed，理论上应该是识别失败的情况，但是该机型点击取消指纹识别也会先回调一次Error，如果遇到这种情况，只能根据具体项目环境中去进行规避适配了。</p>
<h6 id="3-魅族上遇到的坑"><a href="#3-魅族上遇到的坑" class="headerlink" title="3. 魅族上遇到的坑"></a>3. 魅族上遇到的坑</h6><p>onAuthenticationHelp 回调不按套路出牌，正常官网文档解释，这个方法的回调时机是在指纹认证期间发生可恢复性的错误时回调。结果在魅族上，启动指纹识别认证的时候就会回调这个方法，里面传递回来的信息提示是“等待按下手指”，也就是说，它的 onAuthenticationHelp 回调跟官网时机不一样，而且方法的作用也变了，它在正常的情况回调了 onAuthenticationHelp。</p>
<p><strong>解决</strong>：不影响验证流程，无需解决</p>
<h6 id="4-小米-锁屏和切后台生命周期不一致"><a href="#4-小米-锁屏和切后台生命周期不一致" class="headerlink" title="4. 小米 锁屏和切后台生命周期不一致"></a>4. 小米 锁屏和切后台生命周期不一致</h6><p>产品需求：用户锁屏或切到后台时（onStop）自动停止指纹验证，回到界面时（onResume）自动调起验证。</p>
<p>所以我在指纹回调方法中加入了标志位 isInAuth。onStop时保存 isInAuth，onResume时 isInAuth == true 则自动调起验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onAuthenticationSucceeded(FingerprintManagerCompat.AuthenticationResult result) &#123;</div><div class="line">    isInAuth = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onAuthenticationError(int errMsgId, CharSequence errString) &#123;</div><div class="line">    isInAuth = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onAuthenticationFailed() &#123;</div><div class="line">    isInAuth = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onAuthenticationHelp(int helpMsgId, CharSequence helpString) &#123;</div><div class="line">    isInAuth = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而小米6、米mix2 锁屏时的生命周期是 onAuthenticationError -&gt; onStop；切到后台是 onStop -&gt; onAuthenticationError。导致不同流程下拿到 isInAuth 标志位不一致，无法自动调起验证。 </p>
<p><strong>解决</strong>：界面指纹按钮可以手动调起验证，无需兼容处理。</p>
<p> 小米5生命周期同上，但是无论是自动还是手动调起验证，马上就回调了 onAuthenticationError，也就是说 MI5 从后台切回来后，指纹验证流程中断。</p>
<p><strong>解决</strong>：用一个栈来存储调用方法顺序，如果验证方法调起，马上就回调 onAuthenticationError 方法，则判定是属于兼容问题，按验证失败来解决。</p>
<h6 id="5-密钥解密失败"><a href="#5-密钥解密失败" class="headerlink" title="5. 密钥解密失败"></a>5. 密钥解密失败</h6><p>三星SM-A9100 、Nexus 6P密钥解密失败<br><strong>解决</strong>：暂无法解决</p>
<blockquote>
<p>其他兼容解决方案：</p>
<ul>
<li><a href="http://developer.samsung.com/galaxy/pass" target="_blank" rel="external">三星passSdk</a>（不过从2018下半年开始，Pass SDK 将不再提供 DEVICE_FINGERPRINT_UNIQUE_ID 。也就是不再为每个已注册的指纹提供索引了。因此将无法通过 SDK 区分使用哪个指纹来验证用户。）</li>
<li><a href="http://open-wiki.flyme.cn/index.php?title=%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%ABAPI" target="_blank" rel="external">魅族 flyme开发平台</a>提供了指纹验证官方api</li>
</ul>
</blockquote>
<h3 id="非兼容问题"><a href="#非兼容问题" class="headerlink" title="非兼容问题"></a>非兼容问题</h3><h6 id="1-新注册指纹密钥解密失败"><a href="#1-新注册指纹密钥解密失败" class="headerlink" title="1. 新注册指纹密钥解密失败"></a>1. 新注册指纹密钥解密失败</h6><p>系统中注册了一个新的指纹的情况下，即使指纹在系统指纹列表里，验证也不通过。<br><strong>解决</strong>：删除了当前无效的key，然后根据参数再次生成密钥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">       public void onAuthenticationSucceeded(FingerprintManagerCompat.AuthenticationResult result) &#123;</div><div class="line">           ...</div><div class="line">           /**</div><div class="line">            * doFinal方法会检查结果是不是会拦截或者篡改过，</div><div class="line">            * 如果是的话会抛出一个异常，异常的时候都将认证当做是失败来处理</div><div class="line">            */</div><div class="line">           try &#123;</div><div class="line">               result.getCryptoObject().getCipher().doFinal();</div><div class="line">               mCustomCallback.onAuthenticationSucceeded(true);</div><div class="line">           &#125; catch (IllegalBlockSizeException e) &#123;</div><div class="line">               //如果是新录入的指纹，会抛出该异常，需要重新生成密钥对重新验证，这里加个次数限制，避免进入验证异常-&gt;重新验证-&gt;又验证异常的死循环</div><div class="line">               if (happenCount == 0) &#123;</div><div class="line">                   beginAuthenticate();</div><div class="line">                   happenCount++;</div><div class="line">                   return;</div><div class="line">               &#125;</div><div class="line">               mCustomCallback.onAuthenticationSucceeded(false);</div><div class="line">           &#125; catch (Exception e) &#123;</div><div class="line">               mCustomCallback.onAuthenticationSucceeded(false);</div><div class="line">           &#125;</div><div class="line">          ...</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<h6 id="2-设备已有指纹，生成密钥却异常提示没有指纹"><a href="#2-设备已有指纹，生成密钥却异常提示没有指纹" class="headerlink" title="2. 设备已有指纹，生成密钥却异常提示没有指纹"></a>2. 设备已有指纹，生成密钥却异常提示没有指纹</h6><p>非复现，和设备无关，怀疑是谷歌 API 的坑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalStateException: At least one fingerprint must be enrolled to create keys requiring user authentication for every use</div></pre></td></tr></table></figure>
<p><strong>解决</strong>：暂时只想到针对这个特定异常，直接使用无密钥验证，有一定的安全风险，有更好方案欢迎补充。</p>
<blockquote>
<p><a href="https://github.com/feelschaotic/FingerPrintAuth" target="_blank" rel="external">本文完整 Demo 地址</a><br>Demo 仅供参考架构和兼容处理，如果后续接入魅族和三星 SDK，可以考虑用策略模式替换Goolge API。</p>
</blockquote>
<hr>
<h4 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h4><p><strong>Android P 引入了若干可提升应用和运行应用的设备安全性的功能。</strong><br>其中一项：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3167794-ad0389e99d6fd98b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;目前指纹领域无论从产品角度还是技术角度都已经趋于成熟，但是当各位开发者准备深入探究的时候，却发现网上很多文章都是皮毛，很难有较深的启示。本文将着重介绍指纹验证开发整个过程，包括技术选型、产品的设计方案逻辑、代码的架构以及后续测试中遇到的兼容性问题等几个方面。在这里抛砖引玉，希望能给予大家一些启发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「拆轮子」Retrofit-整体架构、细节和思考</title>
    <link href="http://yoursite.com/2018/01/27/new/%E3%80%8C%E6%8B%86%E8%BD%AE%E5%AD%90%E3%80%8DRetrofit-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E7%BB%86%E8%8A%82%E5%92%8C%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/01/27/new/「拆轮子」Retrofit-整体架构、细节和思考/</id>
    <published>2018-01-27T11:44:00.000Z</published>
    <updated>2018-12-18T12:29:01.210Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>阅读源码基本套路：WHW<br>What：能做哪些事？提供了什么功能？<br>How：采用什么方式实现的？由哪些模块组成？<br>Why：为什么有这样的需求？模块这样封装的意图是什么？还有没有更好的方式？</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在业务常用框架中，Retrofit 算是代码量较少，难度较低的开源项目。虽然代码不多，但依然用到了大量的设计模式，具有非常好的扩展性。</p>
<p>解析 Retrofit 源码的优秀文章不少，本文不再赘述，抓住易曲解的概念、整体架构和难理解的细节来做分析。</p>
<a id="more"></a>
<h3 id="明确概念"><a href="#明确概念" class="headerlink" title="明确概念"></a>明确概念</h3><p>一个简单的网络请求调用流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//1. 新建一个retrofit对象</div><div class="line">Retrofit retrofit=new Retrofit.Builder()</div><div class="line">.baseUrl(url)</div><div class="line">.addConverterFactory(GsonConverterFactory.create())</div><div class="line">.build();</div><div class="line">...</div><div class="line"></div><div class="line">//2. 用retrofit加工出对应的接口实例对象</div><div class="line">ApiService mApiService= retrofit.create(ApiService.class);</div><div class="line"></div><div class="line">//3. 调用接口函数，获得网络工作对象</div><div class="line">Call&lt;User&gt; callWorker= mApiService.getUserInfo();</div><div class="line"></div><div class="line">//4. 网络请求入队</div><div class="line">callWorker.enqueue(new Callback&lt;User&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onResponse(Call&lt;BizEntity&gt; call, Response&lt;User&gt; response) &#123;...&#125;</div><div class="line">            @Override</div><div class="line">            public void onFailure(Call&lt;BizEntity&gt; call, Throwable t) &#123;...&#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>我们从上面的应用场景可以看出，Retrofit的作用是按照接口去定制Call网络工作对象,也就是说：<strong>Retrofit并不直接做网络请求，只是生成一个能做网络请求的对象</strong>。</p>
<p>Retrofit在网络请求中的作用大概可以这样理解：<br><img src="https://upload-images.jianshu.io/upload_images/1863579-afe6e4e3ababc37c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603" alt=""></p>
<p>我们看到，从一开始，Retrofit要提供的就是个Call工作对象。<br>换句话说，对于给Retrofit提供的那个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ApiService &#123;</div><div class="line">    @POST(&quot;url&quot;)</div><div class="line">    Call&lt;User&gt; getUserInfo();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个接口并不是传统意义上的网络请求接口，<strong>这个接口不是用来获取数据的接口，而是用来生产对象的接口</strong>，这个接口相当于一个工厂，接口中每个函数的返回值不是网络数据，而是一个能进行网络请求的工作对象，我们要先调用函数获得工作对象，再用这个工作对象去请求网络数据。</p>
<p>所以Retrofit的实用价值意义在于，他能根据你的接口定义，灵活地生成对应的网络工作对象，然后你再择机去调用这个对象访问网络。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>说白了，Retrofit就做了三件事：</p>
<ol>
<li>根据注解解析 ApiService 中每个方法的参数，url，请求类型等信息，组装为 <strong>ServiceMethod</strong> 类。</li>
<li>根据 ServiceMethod 信息 new <strong>请求对象OkHttpCall</strong>（内部持有真正的请求对象 okhttp3.Call 的引用，相当于包了一层）。</li>
<li>用适合的适配器 <strong>callbackExecutor</strong> 转换网络请求对象 Call 为我们声明的接口返回类型（如 Call<r> 到 Observable<r>），用适合的转换器 <strong>Converter</strong> 转换默认的Response为声明的接口返回值（如 Call<responsebody> 到 Call<userinfo>），返回请求对象。</userinfo></responsebody></r></r></li>
</ol>
<p>以上加粗的关键类，我们可以详细看下类结构是怎么样的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-86aab640c360cfff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，Retrofit 自身的结构很简单，代码量也不是很大。红色框部分是http包，代表的是所有的Annotation层。 通过这些注解类，把方法里声明的注解一一映射到构造 OkHttp 请求对象所需要的Request参数。</p>
<p>几个主要类的UML简图：</p>
<h5 id="1-Retrofit-和-ServiceMethod"><a href="#1-Retrofit-和-ServiceMethod" class="headerlink" title="1. Retrofit 和 ServiceMethod"></a>1. Retrofit 和 ServiceMethod</h5><p><img src="http://upload-images.jianshu.io/upload_images/3167794-9f306e447be942e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Retrofit 和 ServiceMethod 使用了 Builder模式(省略了 Director 和Abstract Product 的 Builder模式)来构建自己，Retrofit 的作用很简单，传入需要的参数，构建一个 Retrofit 对象，然后通过动态代理的方式，得到我们自定义的方法接口的实例，参数中除了baseUrl 之外，其他都是可选的，如果没设置会使用默认值。</p>
<p>ServiceMethod 作用就是解析Annotation，同时提供方法生成网络请求需要的Request和解析请求结果Response。</p>
<h5 id="2-CallAdapter-和-CallAdapter-Factory"><a href="#2-CallAdapter-和-CallAdapter-Factory" class="headerlink" title="2. CallAdapter 和 CallAdapter.Factory"></a>2. CallAdapter 和 CallAdapter.Factory</h5><p><img src="http://upload-images.jianshu.io/upload_images/3167794-973012fa7901bbf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>CallAdapt 的作用是把 Call 转变成你想要返回的对象，起作用的是 adapt 方法，CallAdapter.Factory 的作用是获取 CallAdapter 。ExecutorCallAdapterFactory 的 CallAdapter会将回调方法放到主线程中执行，能够接受的返回值类型为Call<t>。很明显，RxJavaCallAdapterFactory的CallAdapter能够接受的返回值是Oservable<t>。如果想让方法直接返回一个对象，可以自定义一个CallAdapter.Factory。</t></t></p>
<h5 id="3-Converter和Converter-Factory"><a href="#3-Converter和Converter-Factory" class="headerlink" title="3. Converter和Converter.Factory"></a>3. Converter和Converter.Factory</h5><p><img src="http://upload-images.jianshu.io/upload_images/3167794-52a61bcbf59341d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Converter 的作用是将网络请求结果 ResponseBody 转换为我们希望的返回值类型。Converter.Factory 的作用是获取 Converter，这里很明显采用了静态工厂模式。</p>
<h5 id="4-OkHttpCall"><a href="#4-OkHttpCall" class="headerlink" title="4. OkHttpCall"></a>4. OkHttpCall</h5><p><img src="http://upload-images.jianshu.io/upload_images/3167794-80aa84bb576d6684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>OkHttpCall 继承自 interface Call，主要的作用是调起执行网络请求以及返回当前请求状态状态，但是真正的网络请求其实在okhttp3.Call接口，接口定义如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-10b597897bb2912e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个接口的实现类是 okhttp3.RealCall，可以发现，Retrofit 的Call 接口和 okhttp3 的 Call 接口定义几乎是完全一样的，这样做的好处显而易见：利于扩展，解耦。</p>
<h5 id="5-RxJavaCallAdapterFactory"><a href="#5-RxJavaCallAdapterFactory" class="headerlink" title="5. RxJavaCallAdapterFactory"></a>5. RxJavaCallAdapterFactory</h5><p><img src="http://upload-images.jianshu.io/upload_images/3167794-876e3934d82002ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>CallAdapterFactory的作用及工作机理前面已经介绍过了，RxJavaCallAdapterFactory的作用也是一样的，只不过RxJavaCallAdapterFactory中内部又定义了三种CallAdapter：ResponseCallAdapter、ResultCallAdapter和SimpleCallAdapter，根据返回值类型决定到底使用哪个，代码如下：<br><img src="http://upload-images.jianshu.io/upload_images/3167794-58c70db7efd5a913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="细节点"><a href="#细节点" class="headerlink" title="细节点"></a>细节点</h3><p>以上流程中，有很多细节可以详细梳理下。</p>
<h5 id="1-如何将-ApiService-接口转换为网络请求？"><a href="#1-如何将-ApiService-接口转换为网络请求？" class="headerlink" title="1. 如何将 ApiService 接口转换为网络请求？"></a>1. 如何将 ApiService 接口转换为网络请求？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ApiService mApiService= retrofit.create(ApiService.class);</div><div class="line">Call&lt;User&gt; callWorker= mApiService.getUserInfo();</div></pre></td></tr></table></figure>
<p>看到以上代码，我们不禁提出疑问，这里的mApiService是什么类型？为什么可以直接调用接口方法？create做了什么？生成接口实现类吗？</p>
<p>我们 debug 到 retrofit.create() 中一看究竟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">    // 检查传入的类是否为接口并且没有继承其他接口</div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    // 预加载开关，默认关，</div><div class="line">    if (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    // 重点是这里！</div><div class="line">    // 首先会返回一个利用代理实现的 ApiService 对象</div><div class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        new InvocationHandler() &#123;</div><div class="line">          private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">          // 我们调用该对象的每一个方法时都会进入到invoke方法里</div><div class="line">          @Override public Object invoke(Object proxy, Method method, Object... args)</div><div class="line">              throws Throwable &#123;</div><div class="line">           </div><div class="line">            if (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              return method.invoke(this, args);</div><div class="line">            &#125;</div><div class="line">            if (platform.isDefaultMethod(method)) &#123;</div><div class="line">              return platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            // 解析当前调用的方法</div><div class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">            // 将刚刚解析完毕包装后的具体方法封装成 OkHttpCall ，你可以在该实现类找到 okhttp 请求所需要的参数</div><div class="line">            OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            // 将以上我们封装好的 call 返回给上层，这个时候我们就可以拿到 call，执行请求。</div><div class="line">            return serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>返回值就是我们自定义的接口实例对象T。由于T的所有方法都是抽象方法，当调用T的方法时，会被 InvocationHandler 拦截，真正的调用会转到 InvocationHandler 的 invoke() 方法中，其中 method 参数就是我们自己的抽象方法。</p>
<p>invoke() 方法中，基于我们的接口方法构造了一个 ServiceMethod，构建过程中对方法中的各种注解做了解析。创建了一个 OkHttpCall 对象，这个对象将会在被adapt之后返回给客户端，类型取决于客户端的方法返回类型和设置的 CallAdapter。这里的代码其实不是很好，OkHttpCall 和 ServiceMethod 有互相引用的感觉，其实本意只是将 OkHttpCall 转换成客户端需要的返回值，那么 CallAdapter 对象是否有必要放在 ServiceMethod，我觉得可以再仔细斟酌一下。</p>
<p>注：此处有个预加载开关 validateEagerly ，开启后将会在调用create时就先去解析ApiService中每个方法，并且add serviceMethodCache缓存里。等到调用方法时，无需再解析，就可以直接在缓存里取解析对象了。</p>
<h5 id="2-谁去进行网络请求？我们的回调是怎么回到主线程的呢？"><a href="#2-谁去进行网络请求？我们的回调是怎么回到主线程的呢？" class="headerlink" title="2. 谁去进行网络请求？我们的回调是怎么回到主线程的呢？"></a>2. 谁去进行网络请求？我们的回调是怎么回到主线程的呢？</h5><p>拿到返回的Call对象，我们可以执行网络请求了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//4. 执行网络请求</div><div class="line">callWorker.enqueue(new Callback&lt;User&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onResponse(Call&lt;BizEntity&gt; call, Response&lt;User&gt; response) &#123;...&#125;</div><div class="line">            @Override</div><div class="line">            public void onFailure(Call&lt;BizEntity&gt; call, Throwable t) &#123;...&#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>调用call.enqueue，内部实际会调用ExecutorCallAdapter的enqueue方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</div><div class="line">  final Executor callbackExecutor;</div><div class="line">  final Call&lt;T&gt; delegate;</div><div class="line"></div><div class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">    this.callbackExecutor = callbackExecutor;</div><div class="line">    this.delegate = delegate;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override </div><div class="line">  public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">    if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);</div><div class="line">    // 重点关注！</div><div class="line">    delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">      @Override </div><div class="line">      public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">        callbackExecutor.execute(new Runnable() &#123;</div><div class="line">          @Override </div><div class="line">          public void run() &#123;</div><div class="line">            if (delegate.isCanceled()) &#123;</div><div class="line">              // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</div><div class="line">              callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">            &#125; else &#123;</div><div class="line">              callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 delegate 对应的就是 okhttp 的 call ，我们注意到 response 的回调由callbackExecutor.execute() 来执行。一步步追踪 callbackExecutor 来源，Retrofit 的 build() 方法里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Executor callbackExecutor = this.callbackExecutor;</div><div class="line">if (callbackExecutor == null) &#123;</div><div class="line">  callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>平台默认的回调调度器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static class Android extends Platform &#123;</div><div class="line">  @Override </div><div class="line">  public Executor defaultCallbackExecutor() &#123;</div><div class="line">    return new MainThreadExecutor();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override </div><div class="line">  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123;</div><div class="line">    return new ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  static class MainThreadExecutor implements Executor &#123;</div><div class="line">    private final Handler handler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    @Override </div><div class="line">    public void execute(Runnable r) &#123;</div><div class="line">      handler.post(r);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现，Android 默认的调度器是主线程的 Handler ，execute()方法也只是 mainHandler.post() 。所以 enqueue() 中 onResponse 方法调用 defaultCallbackExecutor.execute 方法，实际上就是使用主线程 Handler.post(runnable) 从而实现线程切换操作。</p>
<h5 id="3-添加多个转换器和适配器时，内部优先逻辑是什么？"><a href="#3-添加多个转换器和适配器时，内部优先逻辑是什么？" class="headerlink" title="3. 添加多个转换器和适配器时，内部优先逻辑是什么？"></a>3. 添加多个转换器和适配器时，内部优先逻辑是什么？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Retrofit mRetrofit = new Retrofit.Builder()</div><div class="line">                .client(mClient)</div><div class="line">                .baseUrl(mBaseUrl)</div><div class="line">                .addConverterFactory(FastJsonConverterFactory.create())</div><div class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">                .build();</div></pre></td></tr></table></figure>
<p>addConverterFactory 扩展的是对返回的数据类型的自动转换，addCallAdapterFactory 扩展的是对网络工作对象 callWorker 的自动转换。就算我们不添加 CallAdapterFactory 也是能实现适配转换的，原因在于 Retrofit 的 build 函数里，会添加默认的 CallAdapterFactory。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public Retrofit build() &#123;</div><div class="line">      ...</div><div class="line">      okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">      if (callFactory == null) &#123;</div><div class="line">        callFactory = new OkHttpClient();//使用OkHttpClient处理网络请求</div><div class="line">      &#125;</div><div class="line">      ...</div><div class="line">      //根据当前运行平台，设置默认的callAdapterFactory</div><div class="line">      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line">      ...</div><div class="line">      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</div><div class="line">          callbackExecutor, validateEagerly);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>addConverterFactory 和 addCallAdapterFactory 都是把工厂对象添加到各自数组里保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</div><div class="line">      Annotation[] annotations) &#123;</div><div class="line">    // ···</div><div class="line">    int start = adapterFactories.indexOf(skipPast) + 1;</div><div class="line">    for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">      CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this);</div><div class="line">      if (adapter != null) &#123;</div><div class="line">        return adapter;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    // ···</div></pre></td></tr></table></figure></p>
<p>当需要转换或适配时，就循环数组，调用每个工厂对象的方法去尝试转换，转换成功，就表明合适。其实这也是责任链的另一种表现形式。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>总体来说，Retrofit 在类的单一职责方面分隔的很好，OkHttpCall 类只负责网络交互，凡是和函数定义相关的，都交给ServiceMethod 类去处理，而 ServiceMethod 类对使用者不公开，因为 Retrofit 是个 门面模式也就是外观模式，所有需要扩展的都在Retrofit的建造者中实现，用户只需要简单调用门面里的方法，就能满足需求，不需要关心内部的实现。</p>
<p>我们尝试来分析下，在一个网络请求中，哪些是易变的，哪些是不变的，为什么 Retrofit 会这么去设计？</p>
<p>由于 Retrofit 提供网络访问的工作对象，又是服务于具体业务，所以可以分网络访问和具体业务两部分来分析。</p>
<ul>
<li><p><strong>网络访问的不变性</strong><br>对于网络访问来说，不变的是一定有一个实现网络访问的对象，Retrofit 选用了自家的 OkHttpClient，为了把 Retrofit 和OkHttp 解耦合，Retrofit根据依赖倒置原则定义了自己的接口 Call 即 retrofit2.Call，并定义了操作网络请求的具体类 OkHttpCall，和okHttp3.Call仅为引用关系。</p>
</li>
<li><p><strong>网络访问的易变性</strong><br>对于网络访问来说，易变的是网络访问的url、请求方式（get/post等）、Http请求的Header设置与安全设置等，以及返回的数据类型。</p>
<p>针对易变的url和请求方式，Retrofit使用了方法注解的方式，可读性良好，但这需要实现对接口函数中注解的解析，这样就有了ServiceMethod。</p>
<p>针对Http请求的各种设置，其实Retrofit没做什么，因为Retrofit使用的OkHttp有拦截器机制，可以应付这种变化。</p>
<p>针对返回的数据类型，由于目标数据类型与业务有关，是不确定的，Retrofit无法提供一个万能的转换类，所以Retrofit提供了扩展接口，允许开发者自己定义 ConverterFactory 和 Converter，去实现潜在的数据类型转换。</p>
</li>
<li><p><strong>具体业务的不变性</strong><br>对于具体业务来说，不变的是一定要有一个Call网络工作对象，所以Retrofit可以有一个生产对象的机制（像工厂一样）</p>
</li>
<li><p><strong>具体业务的易变性</strong><br>对于具体业务来说，易变的就是这个Call网络工作对象的类型，不仅有CallBacl回调、可能还有Flowable工作流、或者其他潜在的对象类型。</p>
<p>针对这种Call对象的易变性，Retrofit也是无法提供一个万能的实现类，所以也是提供了扩展解耦，允许开发者自己定义CallAdapterFactory和CallAdapter，去实现潜在的Call类型转换。</p>
<p>因为这种Call对象的生产需要有大量的配套代码，为了简化代码，Retrofit使用动态代理来生产这个对象。</p>
</li>
</ul>
<p>最后，因为需要处理的方法和对象太多太复杂，需要使用建造者模式来把建造过程和使用过程分离开。</p>
<p>可以说 Retrofit 设计得非常精妙。最后贴张架构图，跑路！<br><img src="http://upload-images.jianshu.io/upload_images/3167794-365009ee39f8bab3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>参考：<br><a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit 分析-漂亮的解耦套路</a><br><a href="https://www.jianshu.com/p/d3cc3884ba27" target="_blank" rel="external">框架源码 — 可能会有趣一点地简析学习 Retrofit</a><br><a href="https://www.jianshu.com/p/0c055ad46b6c" target="_blank" rel="external">Android：手把手带你 深入读懂 Retrofit 2.0 源码</a><br><a href="https://www.jianshu.com/p/9f617a43d579" target="_blank" rel="external">拆轮子系列 - 如何由浅入深探索 Retrofit 源码？</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;阅读源码基本套路：WHW&lt;br&gt;What：能做哪些事？提供了什么功能？&lt;br&gt;How：采用什么方式实现的？由哪些模块组成？&lt;br&gt;Why：为什么有这样的需求？模块这样封装的意图是什么？还有没有更好的方式？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在业务常用框架中，Retrofit 算是代码量较少，难度较低的开源项目。虽然代码不多，但依然用到了大量的设计模式，具有非常好的扩展性。&lt;/p&gt;
&lt;p&gt;解析 Retrofit 源码的优秀文章不少，本文不再赘述，抓住易曲解的概念、整体架构和难理解的细节来做分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="拆轮子" scheme="http://yoursite.com/tags/%E6%8B%86%E8%BD%AE%E5%AD%90/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「校招季」校招需要准备什么？需要复习什么知识点？</title>
    <link href="http://yoursite.com/2017/10/14/new/%E3%80%8C%E6%A0%A1%E6%8B%9B%E5%AD%A3%E3%80%8D%E6%A0%A1%E6%8B%9B%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E4%BB%80%E4%B9%88%EF%BC%9F%E9%9C%80%E8%A6%81%E5%A4%8D%E4%B9%A0%E4%BB%80%E4%B9%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/10/14/new/「校招季」校招需要准备什么？需要复习什么知识点？/</id>
    <published>2017-10-14T06:57:00.000Z</published>
    <updated>2018-12-18T12:29:33.706Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3167794-d092560f304555a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>校招的套路基本都是宣讲会 — 笔试 — 技术一面 — 技术二面（大公司会到技术三面乃至终面）。</p>
<h4 id="校招信息获取渠道"><a href="#校招信息获取渠道" class="headerlink" title="校招信息获取渠道"></a>校招信息获取渠道</h4><ul>
<li>各大微信公众号（搜索「城市名+校招」）</li>
<li>校招网站（搜索「企业名+校招」）可以找到企业的校招信息。</li>
<li>第三方招聘网站。这里我推荐「海投网」，宣讲会信息十分全。</li>
</ul>
<p>注：不建议选择「海投」的方式，这种耗费大量时间精力的方式， 投入产出比可能比较低。根据自己的兴趣，公司的规模，公司的发展前景等，有选择性地投递简历。一个人的精力是有限的，把精力投入在优选出来的公司上，效果可能更优。</p>
<a id="more"></a>
<h4 id="找准岗位方向"><a href="#找准岗位方向" class="headerlink" title="找准岗位方向"></a>找准岗位方向</h4><p>在找工作之前，明确自己的技术方向，是一件非常重要的事情。大多数人往往会被某些所谓的热门技术，高薪酬等所诱惑，怀疑自己的方向选择，什么岗位都去投一下简历。这在我看来是非常不好的，盲目地投递简历十分浪费时间精力。</p>
<p>如果你本来就参加过实验室项目和比赛，我想你对自己的技术方向定位应该是很清晰的了。</p>
<h4 id="阅读大量笔试题和面试题"><a href="#阅读大量笔试题和面试题" class="headerlink" title="阅读大量笔试题和面试题"></a>阅读大量笔试题和面试题</h4><p>第一关的笔试题考核，是为了筛掉基础差的人。基础差的人，在工作中很难去解决技术问题，要么解决问题速度非常慢。</p>
<p>所以说笔试是首要解决的问题。一般来说笔试题考的范围比较广，占比最大的是「专业技术」和「数据结构」。「专业技术」指的是你的技术方向。「数据结构」指 算法和数据结构。越是大公司，越喜欢考察算法和数据结构基础。我参加的大部分笔试基本上 1/2 数据结构题 + 1/4 算法 + 1/4 java。（没看错，就是招的Android开发。）</p>
<p>当初我刷题是用的「牛客网」，网站体验不错，题目质量也不错。同时上面也有一些校招信息。其它同类型的刷题网站，例如 leetcode ，就看自己喜好了。</p>
<h4 id="热门技术了解"><a href="#热门技术了解" class="headerlink" title="热门技术了解"></a>热门技术了解</h4><p>除了基础外，你还应该对其他领域的知识有多少有所涉猎。你需要多了解一点新技术与科技前沿，你才能和面试官谈笑风生。</p>
<h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><p>从产品角度讲, 一个长期的价值博客是一份很好的简历。</p>
<p>从技术角度讲,持续的写作逼迫你不断学习，你将害怕有一天写无可写。</p>
<p>不过因为应届生熟悉大量笔试题和面试题需要花费相当多的时间，对于后面要找工作又不想没有完成技术文章累积的，可以写笔试面试题文章来完成每周撰写技术文章的任务。当然，文章不能是简单的答案，还需要自己的分析和理解。</p>
<h4 id="面试的准备"><a href="#面试的准备" class="headerlink" title="面试的准备"></a>面试的准备</h4><p><strong>准备 2 份自我介绍</strong>，一份 2 分钟，一份 5 分钟。根据情况选择不同时长的自我介绍。</p>
<p>建议自我介绍包括这些部分：</p>
<ol>
<li>客观情况介绍，姓名，学校，专业，学历，应届还是非应届</li>
<li>应聘职位</li>
<li>和应聘职位有关的学习和实习经历。（成绩、各种荣誉……挑闪光点说，因为你说的，待会儿可能就会变成他面的重点）</li>
<li>特别突出的个人能力（以获得的奖项为依据）。如果没有，略过。</li>
<li>为什么申请这个职位，对公司的了解，对职位的理解并与自身匹配，对自己的定位，对未来工作的期望</li>
</ol>
<h4 id="面试官会从你的简历里挖什么？"><a href="#面试官会从你的简历里挖什么？" class="headerlink" title="面试官会从你的简历里挖什么？"></a>面试官会从你的简历里挖什么？</h4><p>面试官和你的对话一般是从简历里你熟悉的内容展开的，所以你需要好好回顾你的项目。</p>
<p>具体项目面试需要准备哪些方面，面试官会问些什么内容，可以阅读<a href="http://www.jianshu.com/p/39c7abb13bcf" target="_blank" rel="external">怎样一个漂亮的项目介绍 And 面试官到底在考察什么？</a></p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>面试还是要保持良好的心态，只要充分地展示平时自己的所学就可以了。不要把面试当作面试，看作一次技术交流，把心态从我要找到一份工作转变为我要通过面试去发现不足、提升自己，这样就会平和多了。应届面试者还可以和面试官交流你项目中解决方案的优化，对比企业级项目采用的不同的方式，也可以准备好自己的技术疑问，面试官一般会很愿意解答，你将有很大收获。</p>
<hr>
<p>那么接下来，即将着手准备校招，从哪里开始准备呢？首先是基础。</p>
<p>基础这东西，各个公司都很看重，尤其是大公司，他们看中应届生的潜力，舍得花精力去培养，所以基础是重中之重。项目经历少怎么办？那就去打牢基础。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ol>
<li>多线程 </li>
</ol>
<p>这是必问的一块了</p>
<ul>
<li>常用的线程池有几种？</li>
<li>这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？</li>
<li>给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。</li>
<li>多线程同步</li>
<li>实现多线程的两种方法：Thread与Runable。</li>
<li>线程同步的方法：sychronized、lock、reentrantLock等。</li>
<li><p>锁的等级：方法锁、对象锁、类锁。</p>
<p>有前辈已经总结了<a href="http://www.cnblogs.com/xrq730/p/5060921.html" target="_blank" rel="external">40个Java 多线程的面试题</a>，可以看看</p>
</li>
</ul>
<ol>
<li>网络  </li>
<li><p>IO</p>
<p> IO 分为 File IO 和 Socket IO，File IO 基本上是不会问的，问也问不出什么来，平时会用就好了，另外记得 File IO 都是阻塞 IO。</p>
<p> Socket IO 是比较重要的一块，要搞懂的是阻塞 / 非阻塞的区别、同步 / 异步的区别，借此理解阻塞 IO、非阻塞 IO、多路复用 IO、异步 IO 这四种 IO 模型，Socket IO 如何和这四种模型相关联。</p>
<p> 这是基本一些的，深入一些的话，就会问 NIO 的原理、NIO 属于哪种 IO 模型、NIO 的三大组成等等，这有些难，当时我也是研究了很久才搞懂 NIO。提一句，NIO 并不是严格意义上的非阻塞 IO 而应该属于多路复用 IO，面试回答的时候要注意这个细节，讲到 NIO 会阻塞在 Selector 的 select 方法上会增加面试官对你的好感。</p>
</li>
<li><p>注解</p>
</li>
<li>常见关键字的意义</li>
<li>面向对象的基础知识</li>
<li>GC 类型，时机等</li>
<li>字符编码</li>
<li>九种基本数据类型的大小，以及他们的封装类。</li>
<li>Switch 能否用 String 做参数？</li>
<li>equals 与 == 的区别。</li>
<li>Object有哪些公用方法？</li>
<li>Java的四种引用，强弱软虚，用到的场景。</li>
<li>try catch finally，try里有return，finally还执行么？</li>
<li>Override 和 Overload 的含义去区别。</li>
<li>Interface 与 abstract 类的区别。</li>
<li>Static class 与non static class的区别。</li>
<li>java多态的实现原理。</li>
<li>写出生产者消费者模式。</li>
<li>ThreadLocal 的设计理念与作用。</li>
<li>ThreadPool 用法与优势。</li>
<li>wait() 和 sleep() 的区别。</li>
<li>foreach 与正常 for 循环效率对比。</li>
<li>反射的作用与原理</li>
<li>泛型常用特点，List<string>能否转为List<object></object></string></li>
<li>解析 XML 的几种方式的原理与特点：DOM、SAX、PULL</li>
<li>JNI 的使用</li>
</ol>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ol>
<li>内存模型以及分区，需要详细到每个区放什么。</li>
<li>堆里面的分区：Eden，survival from to，老年代，各自的特点。</li>
<li>对象创建方法，对象的内存分配，对象的访问定位。</li>
<li>GC的两种判定方法：引用计数与引用链。</li>
<li>GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</li>
<li>GC收集器有哪些？CMS收集器与G1收集器的特点。</li>
<li>Minor GC与Full GC分别在什么时候发生？</li>
<li>几种常用的内存调试工具：jmap、jstack、jconsole。</li>
<li>类加载的五个过程：加载、验证、准备、解析、初始化。</li>
<li>JVM中 OOM 你遇到过哪些情况，SOF 你遇到过哪些情况。</li>
</ol>
<p>JVM问题没怎么变，内存模型和GC算法这块问得比较多</p>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ol>
<li>线程和进程的关系</li>
<li>线程安全</li>
<li>死锁的产生和解决</li>
<li>进程的几种状态</li>
<li>IPC 几种通信方式</li>
<li>虚拟地址、逻辑地址、线性地址、物理地址的区别</li>
<li>什么是虚拟内存</li>
</ol>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>一些基本的像 union 和 union all 的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门把 SQL 基础和 SQL 优化的内容准备一下。没时间的话可以不复习，一般公司的面试数据库比重不高。</p>
<p>eg：</p>
<ul>
<li>数据库存储过程</li>
</ul>
<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><ol>
<li><p>OSI与TCP/IP各层的结构与功能，都有哪些协议。</p>
</li>
<li><p>TCP与UDP的区别。</p>
</li>
<li><p>TCP报文结构。</p>
</li>
<li><p>TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。</p>
</li>
<li><p>TCP拥塞控制。</p>
</li>
<li><p>TCP滑动窗口与回退N针协议。</p>
</li>
<li><p>Http的报文结构。</p>
</li>
<li><p>Http的状态码含义。</p>
</li>
<li><p>Http request的几种类型。</p>
</li>
<li><p>Http1.1和Http1.0的区别</p>
</li>
<li><p>Http怎么处理长连接。</p>
</li>
<li><p>Cookie与Session的作用于原理。</p>
</li>
<li><p>电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。</p>
</li>
<li><p>Ping的整个过程。ICMP报文是什么。</p>
</li>
<li><p>C/S模式下使用socket通信，几个关键函数。</p>
</li>
<li><p>IP地址分类。</p>
</li>
<li><p>路由器与交换机区别。</p>
</li>
</ol>
<p>网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。</p>
<h4 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h4><h6 id="常用的数据结构概念的实现原理"><a href="#常用的数据结构概念的实现原理" class="headerlink" title="常用的数据结构概念的实现原理"></a>常用的数据结构概念的实现原理</h6><ul>
<li>array</li>
<li>vector</li>
<li>list</li>
<li>set</li>
<li>map</li>
<li>tree</li>
</ul>
<p>非常重要，也是<strong>必问</strong>的内容。基本上就是 List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。</p>
<p>集合要掌握的是 ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、HashSet 的实现原理，能流利作答，当然能掌握 CopyOnWrite 容器和 Queue 是再好不过的了。另外多说一句，ConcurrentHashMap 的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于 ConcurrentHashMap，可以参考以下问题：</p>
<p>（1）ConcurrentHashMap 的锁分段技术</p>
<p>（2）ConcurrentHashMap 的读是否要加锁，为什么</p>
<p>（3）ConcurrentHashMap 的迭代器是强一致性的迭代器还是弱一致性的迭代器</p>
<h6 id="题目示例："><a href="#题目示例：" class="headerlink" title="题目示例："></a>题目示例：</h6><ol>
<li>HashMap实现原理</li>
<li>HashTable和HashMap区别</li>
<li>Hashtalbe与ConcurrentHashMap区别</li>
<li>ArrayList、LinkedList、Vector的区别。</li>
<li>Map、Set、List、Queue、Stack的特点与用法。</li>
<li>HashMap 和 ConcurrentHashMap 的区别</li>
<li><p>链表与数组。</p>
</li>
<li><p>队列和栈，出栈与入栈。</p>
</li>
<li><p>链表的删除、插入、反向。</p>
</li>
<li><p>字符串操作。</p>
</li>
<li><p>Hash表的hash函数，冲突解决方法有哪些。</p>
</li>
<li><p>各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。</p>
</li>
<li><p>快排的partition函数与归并的Merge函数。</p>
</li>
<li><p>对冒泡与快排的改进。</p>
</li>
<li><p>二分查找，与变种二分查找。</p>
</li>
<li><p>二叉树、B+树、AVL树、红黑树、哈夫曼树。</p>
</li>
<li><p>二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。</p>
</li>
<li><p>图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。</p>
</li>
<li><p>KMP算法。</p>
</li>
<li><p>排列组合问题。</p>
</li>
<li><p>动态规划、贪心算法、分治算法。（一般不会问到）</p>
</li>
<li><p>大数据处理：类似10亿条数据找出最大的1000个数………等等</p>
</li>
<li>前序中序 输出层次遍历序列</li>
<li>求树高</li>
<li>是否是平衡二叉树</li>
<li>广度遍历、深度遍历</li>
<li>动态规划和贪心的区别</li>
<li>大整数加、减、乘、除、求模运算实现</li>
<li>很多整数，找其中出现次数最多的那个数</li>
<li>单链表翻转（两个指针如何实现）、查找、删除、插入以及双向链表、有序链表合并</li>
<li>判断一个整数是否是2的整数次幂.(n&amp;(n-1))</li>
<li>常见排序算法的实现以及稳定性（快排跟归并考的很多）</li>
<li>字符串翻转（O(n)）、匹配（KMP算法）</li>
<li>最长递增子序列（nlogn的算法）</li>
<li>链表判断是否有环，环的入口，两个链表是否相交（快慢指针）。</li>
<li>指定一个数组，求2个数的和等于指定的和（某一个数），如果是3,4,5，n个等于个的和（某一个数）呢？（可以看作背包问题）</li>
<li>跳台阶问题</li>
</ol>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ol>
<li>单例（懒汉、饿汉）</li>
<li>工厂</li>
<li>适配器</li>
<li>责任链</li>
<li>观察者</li>
</ol>
<p>面试中关于设计模式的问答主要是三个方向：</p>
<p>（1）你的项目中用到了哪些设计模式，如何使用</p>
<p>（2）知道常用设计模式的优缺点</p>
<p>（3）能画出常用设计模式的 UML 图</p>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><ol>
<li><p>Activity启动模式区别</p>
</li>
<li><p>四大组件生命周期</p>
</li>
<li>如何对产生 ANR 代码定位</li>
<li>检查内存泄露的工具</li>
<li>横竖屏切换时，Activity 的生命周期以及如何设置横屏或者竖屏</li>
<li>Android 主线程与子线程的理解</li>
<li><p>怎么做性能优化</p>
<ul>
<li>UI优化<ul>
<li>减少过度绘制</li>
<li>不必要嵌套布局</li>
<li>利用include标签来复用控件等等</li>
</ul>
</li>
<li>内存优化<ul>
<li>缓存</li>
</ul>
</li>
</ul>
</li>
<li><p>Android的屏幕适配方案</p>
<ul>
<li><p>图片适配<br>不同像素密度的手机加载工程资源文件(res)中不同资源图片</p>
</li>
<li><p>dimens.xml文件适配<br>dimens.xml存在于工程资源(res)文件夹中不同values(如:value-1280x720、value-800x480)文件夹下，可用于指定控件大小，不同像素密度手机加载不同values文件夹下的dimens.xml文件</p>
</li>
<li><p>布局文件适配（工程比较浩大，不常用）<br>不同分辨率的手机，加载不同的布局文件已达到适配效果。创建多个layout(如：layout-1280x720、layout-800x480)文件夹用于存放不同像素密度手机所需布局文件。</p>
</li>
<li><p>代码适配<br>通过android相应api获取当前手机的宽高像素值，按比例分配屏幕中控件的宽高以达到适配效果</p>
</li>
<li><p>权重适配<br>通过android提供的(权重)剩余空间分配，已达到适配效果</p>
</li>
</ul>
</li>
<li><p>ListView优化</p>
</li>
<li><p>Java具备内存回收机制，为什么Android还会出现内存泄露？写出三个内存泄露的场景。</p>
</li>
<li><p>说说你知道的当前几个比较火比较流行的开源框架（比如 Volley ,Universnal-image-loader等），是怎么用的，研究过他们的源码没？</p>
</li>
<li><p>Android 虚拟机与 Java 的 Jvm区别</p>
</li>
<li>MVC 、MVP 和 MVVM 架构</li>
<li>Handler 消息机制</li>
<li>AsyncTask 的原理</li>
<li>OOM 原因、如何避免？</li>
<li>内存泄露的原因<ul>
<li>数据库的 cursor 没有关闭</li>
<li>构造 Adapter 没有使用缓存 contentview</li>
<li>调用 registerReceiver() 后未调用 unregisterReceiver()</li>
<li>未关闭 InputStream / OutputStream</li>
<li>Bitmap使用后未调用recycle()</li>
<li>Context泄漏</li>
</ul>
</li>
<li>三级缓存步骤</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h6 id="C-C-相关"><a href="#C-C-相关" class="headerlink" title="C/C++相关"></a>C/C++相关</h6><ol>
<li>虚析构、模板和宏</li>
<li>虚函数实现机制</li>
<li>vector与list的区别，map是如何实现的，查找效率是多少</li>
<li>extern 关键字有什么用</li>
<li>malloc和new的区别，能否malloc(1.2G)</li>
</ol>
<h6 id="linux以及操作系统相关"><a href="#linux以及操作系统相关" class="headerlink" title="linux以及操作系统相关"></a>linux以及操作系统相关</h6><ol>
<li>内存池实现</li>
<li>进程间通信机制</li>
<li>Linux ps命令，以及看内存当前使用状态的命令</li>
<li>进程的内存空间</li>
</ol>
<blockquote>
<p>关于面试，你可能还想知道：</p>
<ul>
<li><a href="https://www.jianshu.com/p/1bb9aac42762" target="_blank" rel="external">如何选择公司？</a></li>
<li><a href="https://www.jianshu.com/p/39c7abb13bcf" target="_blank" rel="external">怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？</a></li>
<li><a href="https://www.jianshu.com/p/d3a476203841" target="_blank" rel="external">值得订阅的公众号、博客和书籍推荐</a></li>
<li><a href="https://www.jianshu.com/p/c158eb2f7500" target="_blank" rel="external">你还在认为HR面是走流程？</a></li>
<li><a href="https://www.jianshu.com/p/6351c9eb74ad" target="_blank" rel="external">学习千万不要完美主义</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-d092560f304555a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;基本流程&quot;&gt;&lt;a href=&quot;#基本流程&quot; class=&quot;headerlink&quot; title=&quot;基本流程&quot;&gt;&lt;/a&gt;基本流程&lt;/h4&gt;&lt;p&gt;校招的套路基本都是宣讲会 — 笔试 — 技术一面 — 技术二面（大公司会到技术三面乃至终面）。&lt;/p&gt;
&lt;h4 id=&quot;校招信息获取渠道&quot;&gt;&lt;a href=&quot;#校招信息获取渠道&quot; class=&quot;headerlink&quot; title=&quot;校招信息获取渠道&quot;&gt;&lt;/a&gt;校招信息获取渠道&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;各大微信公众号（搜索「城市名+校招」）&lt;/li&gt;
&lt;li&gt;校招网站（搜索「企业名+校招」）可以找到企业的校招信息。&lt;/li&gt;
&lt;li&gt;第三方招聘网站。这里我推荐「海投网」，宣讲会信息十分全。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：不建议选择「海投」的方式，这种耗费大量时间精力的方式， 投入产出比可能比较低。根据自己的兴趣，公司的规模，公司的发展前景等，有选择性地投递简历。一个人的精力是有限的，把精力投入在优选出来的公司上，效果可能更优。&lt;/p&gt;
    
    </summary>
    
    
      <category term="校招" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>「校招季」值得订阅的公众号、博客和书单</title>
    <link href="http://yoursite.com/2017/10/14/new/%E3%80%8C%E6%A0%A1%E6%8B%9B%E5%AD%A3%E3%80%8D%E5%80%BC%E5%BE%97%E8%AE%A2%E9%98%85%E7%9A%84%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B9%A6%E5%8D%95/"/>
    <id>http://yoursite.com/2017/10/14/new/「校招季」值得订阅的公众号、博客和书单/</id>
    <published>2017-10-14T03:41:00.000Z</published>
    <updated>2018-12-18T12:29:49.754Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3167794-88aac97aa944a225.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="写在文前"><a href="#写在文前" class="headerlink" title="写在文前"></a>写在文前</h4><p>初学者看订阅的博文得到的成长远远不及阅读一本书，因为博文或者微信公众号的订阅，大多是干货，什么叫干货？就是去根，直接是果实。这些大部分都是作者经验的总结和提炼的文章，没有办法建立起一个完整的知识体系，所以很难消化。还是要以书籍为主，博文为补充。</p>
<a id="more"></a>
<h4 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h4><ul>
<li><a href="http://www.jianshu.com/u/ec95b5891948" target="_blank" rel="external">D_clock爱吃葱花</a></li>
<li><a href="http://www.jianshu.com/u/df40282480b4" target="_blank" rel="external">小鄧子</a></li>
<li><a href="http://www.jianshu.com/u/511ba5d71aef" target="_blank" rel="external">milter</a></li>
<li><a href="http://www.jianshu.com/u/6e4c6553a7f9" target="_blank" rel="external">stay4it</a></li>
<li><p><a href="http://www.jianshu.com/u/22f55ea83811" target="_blank" rel="external">涅槃1992</a></p>
</li>
<li><p><a href="http://www.jianshu.com/users/9038233c5f2c/latest_articles" target="_blank" rel="external">凯神</a></p>
</li>
</ul>
<h4 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h4><ul>
<li><a href="http://www.jianshu.com/p/dbdaed5ef5e1" target="_blank" rel="external">一个Android程序员憋不住要分享的微信公众号</a></li>
</ul>
<h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><ul>
<li><a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋大神</a></li>
<li><a href="http://stormzhang.com/" target="_blank" rel="external">薄荷帅张</a></li>
<li><a href="http://Trinea.cn" target="_blank" rel="external">Trinea</a></li>
<li><a href="http://blog.daimajia.com" target="_blank" rel="external">代码家的博客</a></li>
<li><a href="http://csdn.net/andorid_tutor" target="_blank" rel="external">魏祝林的csdn博客</a></li>
<li><a href="http://blog.csdn.com.net/luoshengyang/" target="_blank" rel="external">老罗的csdn博客</a></li>
<li><a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">郭神</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚</a></li>
<li><a href="http://blog.csdn.net/eclipsexys/" target="_blank" rel="external">徐宜生</a></li>
<li><p><a href="http://blog.csdn.net/jiangwei0910410003" target="_blank" rel="external">尼古拉斯_赵四</a></p>
</li>
<li><p><a href="http://gank.io/post/" target="_blank" rel="external">匠心文章</a></p>
</li>
</ul>
<h4 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h4><ul>
<li><a href="https://segmentfault.com/t/android" target="_blank" rel="external">segmentfault</a></li>
<li><a href="http://stackoverflow.com/" target="_blank" rel="external">StackOverFlow</a> </li>
<li><a href="http://gold.xitu.io/welcome/android" target="_blank" rel="external">掘金</a></li>
<li><a href="http://www.jcodecraeer.com/plus/list.php?tid=16" target="_blank" rel="external">泡在网上的日子</a></li>
<li><p><a href="http://www.androidblog.cn/" target="_blank" rel="external">Android博客周刊</a>  </p>
</li>
<li><p>Android开发技术周报（订阅后每周一周刊推送，目前订阅通道已经关闭，不定时开放）</p>
</li>
<li><a href="http://hao.jobbole.com/category/android/" target="_blank" rel="external">伯乐资源</a><br>这里面有非常全的Android相关的资源。</li>
<li><p><a href="http://www.android-studio.org/" target="_blank" rel="external">Android Studio</a><br>这个是AndroidStudio的中文社区，主要关注AS，但也有开发相关内容。</p>
</li>
<li><p><a href="https://androidweekly.net/" target="_blank" rel="external">Android Weekly</a> （周报）</p>
</li>
<li>移动开发前线 （周报）</li>
<li>github上的Trending （了解最近比较热门的开源项目）</li>
<li><a href="http://www.androidpatterns.com/" target="_blank" rel="external">Android Patterns</a><br>这个主要是UX相关的。</li>
<li><p><a href="http://www.android-app-patterns.com/" target="_blank" rel="external">Android App Patterns</a><br>这个也是UX设计相关的。</p>
</li>
<li><p>InfoQ</p>
</li>
<li><p><a href="http://developer.android.com/develop/index.html" target="_blank" rel="external">Android Developers</a><br>这个不用多说，开发Android，无论是新手还是老手，官方的文档总是一个必须要常访问的地方。今日的官方文档已经大不一样，现在从Tutorials, Training Docs, References, Articles, Videos, Best Practices and Samples可以说凡是能用来学习的全都有了，里面已是相当的丰富了。</p>
</li>
<li><p><a href="http://blog.jobbole.com/" target="_blank" rel="external">伯乐在线</a><br>这里每天会汇集一些优质的网络博客，各个方面的，当然也包括Android。</p>
</li>
<li><p><a href="http://android-developers.blogspot.com/" target="_blank" rel="external">Android Developer Blogs</a><br>这个貌似是一群Android系统的开发者所定的博客，里面的文章相当有深度和权威，都是一等一的干货。</p>
</li>
<li><p><a href="http://blog.stylingandroid.com/" target="_blank" rel="external">Styling Android</a><br>这个博客主要讲高级的UI定制，比如实现颜色选择器那种高级复杂的UI。</p>
</li>
<li><p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc_XOgcRukSoKKjewFJZrKV0" target="_blank" rel="external">Android Dev Bytes</a><br>这个是YouTube上面的一个频道，是由Android系统的开发者做的一些教程类的视频，讲述如何进行开发，和提升的技巧。视频的内容非常丰富，从新的API，到游戏，再到UX，和Android Design。每个视频都算长，几十分钟。其中有几个哥们是Framework图形库的，讲述的如何做各种非常炫和酷的动画，相当的赞。这可以说是世界上最优秀的工程师，且是Android的维护者做的教程，错不了。</p>
</li>
<li><p><a href="http://www.androiddesignpatterns.com/" target="_blank" rel="external">Android Design Patterns</a><br>这个博客的内容都是关于深度解析Frameworks中某些组件的工作原理的，很有深度。</p>
</li>
</ul>
<h4 id="线下社区"><a href="#线下社区" class="headerlink" title="线下社区"></a>线下社区</h4><p>这个要看具体的城市而定，现在大多数城市都有谷歌开发者社区<a href="http://www.chinagdg.com/forum.php" target="_blank" rel="external">GDG(Google Developer Group)</a>他们都会定期的举办活动，因为是关于Google的，所以肯定有Android相关的。对于像北京，上海，杭州这些移动互联网热门城市，各种社区应该很多的。</p>
<h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><h5 id="数据机构和算法："><a href="#数据机构和算法：" class="headerlink" title="数据机构和算法："></a>数据机构和算法：</h5><ul>
<li>剑指offer</li>
<li>算法导论</li>
<li>编程之美</li>
<li>编程之法：面试和算法心得</li>
<li>轻松学算法 —— 互联网算法面试宝典</li>
<li>程序员代码面试指南：it 名企算法与数据结构题目最优解 </li>
<li><p>算法</p>
</li>
<li><p>大话数据结构</p>
</li>
</ul>
<h5 id="面试："><a href="#面试：" class="headerlink" title="面试："></a>面试：</h5><ul>
<li>程序员面试金典</li>
<li>程序员面试笔试宝典 （第2版） </li>
<li><p>程序员面试宝典（第5版）</p>
</li>
<li><p>程序员面试白皮书</p>
</li>
</ul>
<h5 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h5><ul>
<li>Java编程思想</li>
<li>深入理解Java虚拟机</li>
<li>Effective Java </li>
<li>Head First Java </li>
<li>Java核心卷1、2</li>
<li>Thinking In Java</li>
<li><p>Effective Java</p>
</li>
<li><p>java并发编程</p>
</li>
<li>JVM高级特性与最佳实践  </li>
</ul>
<h5 id="Android："><a href="#Android：" class="headerlink" title="Android："></a>Android：</h5><ul>
<li><p>Android程序设计</p>
</li>
<li><p>Android群英传</p>
</li>
<li><p>Android编程实战</p>
</li>
<li><p>Android开发进阶从小工到专家</p>
</li>
<li><p>Android开发艺术探索<br>从应用层出发，进而深入到Framework层，对JNI和C++涉及较少，更贴近上层的原理，比较适合新手进阶。</p>
</li>
<li><p>Android编程权威指南  </p>
</li>
<li><p>Android 安全架构深究<br>讲解 Android 整个安全体系的构建，偏重于防  </p>
</li>
<li><p>Android内核剖析<br>帮助新手加速理解 Android 系统框架  </p>
</li>
<li><p>Android开发进阶从小工到专家  </p>
</li>
<li><p>深入理解Android（卷2）<br><em>注：卷1偏底层 卷2偏java</em>    </p>
</li>
<li><p>Android软件安全与逆向分析  </p>
</li>
<li><p>Android应用安全防护和逆向分析</p>
</li>
<li><p>Android源码设计模式解析与实战<br>边学源码边应用设计模式，看完对设计模式的理解更深一层，推荐！  </p>
</li>
<li><p>Android系统源代码情景分析<br>非常底层，涉及到 Linux 内核层、硬件抽象层（HAL）、运行时库层(Runtime)、应用程序框架层(Application Framework)以及应用程序层(Application)。  </p>
</li>
<li><p>深入理解Android内核设计思想<br>全书从操作系统的基础知识入手，全面剖析进程/线程、内存管理、Binder机制、GUI显示系统、多媒体管理、输入系统等核心技术在Android中的实现原理。  </p>
</li>
<li><p>Android化架构组件</p>
</li>
<li><p>App研发录</p>
</li>
<li><p>Android安全架构深究</p>
</li>
<li><p>Android系统原理及开发要点详解<br>这本书主要讲Android系统的整体架构，从linux kernel层-&gt;C/C++本地代码层-&gt;Java FrameWork层-&gt;应用层，尤其重点是Android这四层是如何相互调用，相互屏蔽的，非常适合做Android系统开发的人。</p>
</li>
<li><p>Creating Dynamic UI with Android Fragments<br>Fragment的完整讲解  </p>
</li>
<li><p>50 Android Hacks<br>这本书有点类似《Effective Java》和《Effective C++》，它是以话题形式来讨论提升Android开发的技巧，每个话题一个技巧，非常实用的一本书，里面有很多干货，有实例，拿来就可以用</p>
</li>
<li><p>Smashing Android UI<br>这本书重点讨论如何提升UI，包括动画，布局，UI性能，定制Widget等。</p>
</li>
<li><p>Pro Android Apps Performance Optimization<br>这本书是讲如何提升应用的性能。</p>
</li>
<li><p>Decompiling Android<br>这本书比较有意思，是从另外一个角度来讲Android开发，从逆向工程角度，主要讲如何逆向工程一个应用，以及如何从开发层面来防止应用被逆向。里面讲了很多工具，很实用。</p>
</li>
<li><p>Android Design Patterns: Interaction Design Solution for Developers<br>这本书的话题跟开发比较远，主要是从UX角度来讲解Android上面的用户体验的模式，比如现在非常流行的Drawer等等。开发者也要懂一些用户体验方面的东西，而且这些东西跟开发者关系更大一些。因为UXD并不清楚什么可以实现，什么难以实现，什么无法实现，以及实现起来的代价有多大。现在不是流行全栈工程师吗。Anyway，多了解点知识总是没坏处的。</p>
</li>
</ul>
<h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><ul>
<li>大话设计模式</li>
</ul>
<h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h5><ul>
<li>深入理解现代操作系统</li>
<li>程序员的自我修养</li>
</ul>
<h5 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h5><ul>
<li>代码整洁之道</li>
<li>人月神话</li>
<li>重构：改善既有代码的设计</li>
<li>程序员的职业素养</li>
<li>敏捷软件开发</li>
<li>敏捷建模</li>
<li>测试驱动的面向对象软件开发</li>
<li>The Object Primer</li>
<li>驯服烂代码</li>
<li>重构与模式</li>
<li>程序员的职业素养</li>
</ul>
<p>附：<a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read" target="_blank" rel="external">StackOverFlow上经典的书籍推荐回答</a></p>
<blockquote>
<p>以上，持续更新中</p>
</blockquote>
<hr>
<blockquote>
<p>关于面试，你可能还想知道：</p>
<ul>
<li><a href="https://www.jianshu.com/p/1bb9aac42762" target="_blank" rel="external">如何选择公司？</a></li>
<li><a href="https://www.jianshu.com/p/39c7abb13bcf" target="_blank" rel="external">怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？</a></li>
<li><a href="https://www.jianshu.com/p/9040c32b3f4c" target="_blank" rel="external">校招需要准备什么？需要复习什么知识点？</a></li>
<li><a href="https://www.jianshu.com/p/c158eb2f7500" target="_blank" rel="external">你还在认为HR面是走流程？</a></li>
<li><a href="https://www.jianshu.com/p/6351c9eb74ad" target="_blank" rel="external">学习千万不要完美主义</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-88aac97aa944a225.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;写在文前&quot;&gt;&lt;a href=&quot;#写在文前&quot; class=&quot;headerlink&quot; title=&quot;写在文前&quot;&gt;&lt;/a&gt;写在文前&lt;/h4&gt;&lt;p&gt;初学者看订阅的博文得到的成长远远不及阅读一本书，因为博文或者微信公众号的订阅，大多是干货，什么叫干货？就是去根，直接是果实。这些大部分都是作者经验的总结和提炼的文章，没有办法建立起一个完整的知识体系，所以很难消化。还是要以书籍为主，博文为补充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="校招" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>「校招季」你还在认为HR面是走流程？</title>
    <link href="http://yoursite.com/2017/10/01/new/%E3%80%8C%E6%A0%A1%E6%8B%9B%E5%AD%A3%E3%80%8D%E4%BD%A0%E8%BF%98%E5%9C%A8%E8%AE%A4%E4%B8%BAHR%E9%9D%A2%E6%98%AF%E8%B5%B0%E6%B5%81%E7%A8%8B%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/10/01/new/「校招季」你还在认为HR面是走流程？/</id>
    <published>2017-10-01T12:56:00.000Z</published>
    <updated>2018-12-18T12:29:18.874Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3167794-f12cf2aab8268314.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>HR 面当然不是走过场，这一轮是对面试者进行企业文化、价值观的匹配。主要会从稳定性，工作经验，为人处世，性格，职业潜质几个方面展开进行询问，通常会问到意向的工作地点，期望薪资，工作经验，上次辞职的原因、职业规划等。建议先了解行业特性，单位各方面的情况，越多越好，然后关注下个人简历的所有细节。</p>
<a id="more"></a>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>不管是回答什么问题，<strong>建议准备若干个「故事」</strong>！这些故事，是基于你自身的经历，要呈现你在某个方面的特质的故事。某个故事展现你的学习能力，某个故事表现你的 leadership，某个故事说明你的性格特点，等等。面试时问到你哪方面的内容，你都可以顺势展开，<strong>让你的形象迅速具体</strong>，掌握面试的节奏。</p>
<p>打个比方，问：「你通常怎么获取最新的领域知识？」<br>答：「 我一般上 XXX 社区 」 （(说出专业的论坛/社区）<br>「我还自己动手完善了XX框架」 （兴趣驱动，有提升空间）  </p>
<h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>在讲故事的方式中有两个小技巧： </p>
<ol>
<li>戏剧化表达法</li>
<li>细节炫耀法 </li>
</ol>
<h5 id="1-戏剧化表达法"><a href="#1-戏剧化表达法" class="headerlink" title="1. 戏剧化表达法"></a>1. 戏剧化表达法</h5><p>面试虽然是一个严肃的场合，但有趣的是，hr 喜欢听故事，更喜欢有意思并且能顺利抓住重点的面试者。毕竟，每天都听到许许多多「我热爱开源」 ，「我工作勤奋」 ，「我自学能力强」 ，是一件很沉闷的事情。这就需要你有戏剧化表达自己优势的能力。  </p>
<p>正确打开方式：  </p>
<p>我不会说「我热爱开源」，而会说「我为 github 社区的XX开源库提出了多少 issues，贡献了多少 request。我发布了多少个开源项目或是工具库，获得多少 star 」。  </p>
<p>我不会说「我自学能力强」，而会说「在参加 XX 比赛中，我第一次接触到 XX 技术，比赛时间非常紧，我先是看官网文档目录建立一个整体的知识框架，接着官方 demo 下载下来跑一跑，细节知识点怎么摸索，最后我用了多少时间，掌握了该技术并迅速应用到项目中」。</p>
<h5 id="2-细节炫耀法"><a href="#2-细节炫耀法" class="headerlink" title="2. 细节炫耀法"></a>2. 细节炫耀法</h5><p>人脑有一个奇妙的特点，那就是倾向于记住那些细节性的具体的东西，多过于抽象的空泛的东西。最好在故事细节加上数字来辅助说明。</p>
<h4 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h4><p>建议自问自答过一遍</p>
<p>一、项目经验  </p>
<p>　　1． 遇到过什么困难？你是如何处理或应付过去的？</p>
<p>　　2． 你认为该比赛的难点或挑战性在什么地方？</p>
<p>　　3． 你在比赛中有什么收获和体会？</p>
<p>二、工作动机与期望</p>
<p>　　1． 你为何选择来我公司工作？你对我公司了解些什么？你对我公司提供的工作有什么希望和要求？你为什么要应聘这个职位？（追问）你认为有哪些有利条件？还有哪些不利条件？怎么克服不利条件？</p>
<p>　　2． 你在生活中追求什么？近来个人有什么打算？如果你被录用，由于工作需要，领导（主管）把别人不愿做又瞧不起的工作交给你，这时你怎么办？请结合这次应聘，谈谈你在选择工作时都考虑哪些因素？</p>
<p>　　3． 你所要求的工作条件和待遇大致是什么？如果相差很大，你怎么办？</p>
<p>　　4． 你喜欢什么样的领导与同事？</p>
<p>　　5． 对你来说，赚钱和一份令人满意的工作，哪一个更重要？</p>
<p>　　6．你认为在一个理想的工作单位里，个人事业的成败是由什么决定的？</p>
<p>三、事业进取心与自信心</p>
<p>　　1． 你个人有什么抱负和理想？准备怎样实现自己的理想？</p>
<p>　　2． 你对现状满意吗？为什么？</p>
<p>　　3． 你认为现在的工作有什么需要改进的地方？</p>
<p>　　4． 你有向领导提合理化建议的经历吗？</p>
<p>　　5． 你怎样看待你们部门中的应付工作、混日子的现象？</p>
<p>　　6． 你的职业发展计划是什么？如何去实现这个计划？</p>
<p>　　7． 你认为这次面试你能通过吗？</p>
<p>　　8． 你对自己在工作中有什么要求？</p>
<p>　　9． 领导交给你一个很重要但又很艰难的工作，你怎么去处理？</p>
<p>　　10．你渴求什么样的成功？其决定因素有哪些？</p>
<p>四、工作态度</p>
<p>　　1． 你认为单位管得松一些好，还是严一些好？</p>
<p>　　2． 你们单位管得严不严？迟到、早退、怠工现象是否经常发生？你这方面的情况怎么样？</p>
<p>　　3． 在工作中你看到别人违反规定和制度，你怎么办？</p>
<p>　　4． 对这个工作你最喜欢哪个方面？最不喜欢哪个方面？</p>
<p>　　5． 你经常对工作做些改进或向领导提建议吗？</p>
<p>　　6． 在完成某项工作，你认为领导解决问题方式不是最佳，自己还有更好的方法，应该怎么办？</p>
<p>　　7． 你在工作中常与主管沟通，向他汇报工作吗？</p>
<p>　　8． 你对自己现在的工作状况满意吗？为什么？</p>
<p>　　9． 你如何看待超时工作，周末和休息日加班？</p>
<p>　　10．你认为你能对我公司做出什么贡献？</p>
<p>五、分析判断力</p>
<p>　　1． 你认为大学生活和学习对你的工作有什么影响？</p>
<p>　　2． 你认为怎样适应从学校到社会的转变？</p>
<p>　　3． 你认为怎样才能跟上飞速发展的时代而不落后？</p>
<p>　　4． 你认为如何解决中国的下岗待业问题？</p>
<p>　　5． 你认为成功的关键是什么？</p>
<p>　　6． 你认为自己适合做什么样的工作？</p>
<p>六、<strong>高频问题</strong></p>
<ol>
<li>你认为自己最大的优点和缺点是什么？ </li>
<li>为什么选择本公司？ </li>
<li>谈谈五年内职业规划是什么？ </li>
<li>谈谈对行业、技术发展趋势</li>
</ol>
<hr>
<blockquote>
<p>关于面试，你可能还想知道：</p>
<ul>
<li><a href="https://www.jianshu.com/p/1bb9aac42762" target="_blank" rel="external">如何选择公司？</a></li>
<li><a href="https://www.jianshu.com/p/39c7abb13bcf" target="_blank" rel="external">怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？</a></li>
<li><a href="https://www.jianshu.com/p/9040c32b3f4c" target="_blank" rel="external">校招需要准备什么？需要复习什么知识点？</a></li>
<li><a href="https://www.jianshu.com/p/d3a476203841" target="_blank" rel="external">值得订阅的公众号、博客和书籍推荐</a></li>
<li><a href="https://www.jianshu.com/p/6351c9eb74ad" target="_blank" rel="external">学习千万不要完美主义</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-f12cf2aab8268314.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;HR 面当然不是走过场，这一轮是对面试者进行企业文化、价值观的匹配。主要会从稳定性，工作经验，为人处世，性格，职业潜质几个方面展开进行询问，通常会问到意向的工作地点，期望薪资，工作经验，上次辞职的原因、职业规划等。建议先了解行业特性，单位各方面的情况，越多越好，然后关注下个人简历的所有细节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="校招" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>「校招季」如何选择公司？</title>
    <link href="http://yoursite.com/2017/09/30/new/%E3%80%8C%E6%A0%A1%E6%8B%9B%E5%AD%A3%E3%80%8D%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%85%AC%E5%8F%B8%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/09/30/new/「校招季」如何选择公司？/</id>
    <published>2017-09-30T09:55:00.000Z</published>
    <updated>2018-12-18T12:29:24.971Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3167794-6cdd5189378cc6f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>本文主要适用于非一二线互联网公司 Offer 的选择。希望以下一些简单的方法，可以辅助你去判断一家公司是否靠谱。</p>
<a id="more"></a>
<h4 id="是否举办过大规模的宣讲会或校招"><a href="#是否举办过大规模的宣讲会或校招" class="headerlink" title="是否举办过大规模的宣讲会或校招"></a>是否举办过大规模的宣讲会或校招</h4><p>校招最好的途径是参加宣讲会，<strong>能举办宣讲会的企业实力不会太差</strong>，而且对校招这一块会比较重视。</p>
<h4 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h4><p>Android 开发遇到各种千奇百怪的屏幕尺寸、系统版本的适配也就算了，国内环境还比较复杂，各种定制 ROM，加上普遍公司偏关注 iOS 平台。所以如果这家公司 Android 端的App做的还可以，那么起码说明这家公司不会不那么不靠谱。 </p>
<h4 id="面试官提问的水平和深度"><a href="#面试官提问的水平和深度" class="headerlink" title="面试官提问的水平和深度"></a>面试官提问的水平和深度</h4><p>很简单的道理，打个比方，两家公司两个面试官。  </p>
<p>一个简单问你 volatile 关键字的作用，一个深度问到 volatile 关键字的底层实现原理。  </p>
<p>同时给你 offer，你选哪家？</p>
<p>面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对公司的好感。不要觉得底层问题太吹毛求疵了，越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以深度优先、广度次之为标准的。 </p>
<h4 id="行业"><a href="#行业" class="headerlink" title="行业"></a>行业</h4><p><strong>这点很重要</strong>，了解公司所处行业，走下坡路的行业、夕阳产业，尽量不考虑。多考虑朝阳产业，符合时代发展趋势的行业。比如教育、医疗、健康、互联网、物联网、安防、安全、企业服务、金融、保险、电商、游戏、文化、娱乐、体育、旅游、高端制造等，都是不错的行业（个人意见，还有很多其他行业也不错，要自己分析判断）。</p>
<p>因为夕阳产业，意味着企业的利润空间小。比如传统媒体行业盈利基本全靠广告费，而现在广告实收额下滑超过一半，日渐式微已是不争的事实，《华盛顿邮报》被收购、《读者文摘》申请破产……这些无法与互联网融合、成功转型的传统媒体行业都面临着失去「最后一个铜板」的威胁。但是，即使如此，羊城晚报校招门前，还是排起了长长的大学生求职队伍。（摊手）</p>
<h4 id="公司业务信息"><a href="#公司业务信息" class="headerlink" title="公司业务信息"></a>公司业务信息</h4><p>了解这些信息：</p>
<ul>
<li>主要产品（服务）是什么</li>
<li>产品（服务）是否解决市场痛点</li>
<li>产品所在细分市场有多大</li>
<li>竞品有哪些，有没有做得很好的竞品</li>
</ul>
<p><a href="http://black.bhusk.com/index/1/30/1#main" target="_blank" rel="external">IT黑名单</a> 可以作为参考。</p>
<h4 id="公司研发团队"><a href="#公司研发团队" class="headerlink" title="公司研发团队"></a>公司研发团队</h4><p>作为开发者，加入软件公司前，需要判断这家公司的技术部门是否是核心部门。在核心价值链上的部门和职位，才会有比较好的发展前景。</p>
<p>如果你到一家房地产公司做网站开发，铁定是边缘化的，因为它是市场驱动型的公司，开发者在里面受重视的程度不如售楼人员。</p>
<p>技术和产品驱动的公司，对开发者来讲会更好一些。</p>
<p>怎么判断技术对一家公司是否重要呢？一个简单的方法就是：拿掉这家公司的软件研发团队（采购所需软件或外包出去），看他的主要业务是否还可以正常运转。</p>
<h4 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h4><p>可以看看大家对公司的评价，途径有：</p>
<ul>
<li>搜索</li>
<li>点评类网站，如看准网等</li>
<li>脉脉，这里可以匿名问</li>
<li>知乎，这里也可以匿名问，有人会回答的</li>
<li>LinkedIn，可以加目标公司的人来问</li>
<li>在行，约目标公司的人来聊<br>搜集到的评价仅供参考，因为你接触到的样本，他和公司的关系对评价影响很大，评价是个很主观的行为。</li>
</ul>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>其实大多数中小企业并没有太多可被应聘者在网上查到资料。还是要去面试中多多观察和问相关问题来的实际。</p>
<p>其实很多时候，offer 差不多的情况下，我会<strong>优先选择前台妹子漂亮的公司</strong>。（斜眼笑）诶，别走啊，这可不是瞎说的，这是有科学依据的，真的！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-7c81a7d350974caa.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<blockquote>
<p>关于面试，你可能还想知道：</p>
<ul>
<li><a href="https://www.jianshu.com/p/39c7abb13bcf" target="_blank" rel="external">怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？</a></li>
<li><a href="https://www.jianshu.com/p/9040c32b3f4c" target="_blank" rel="external">校招需要准备什么？需要复习什么知识点？</a></li>
<li><a href="https://www.jianshu.com/p/d3a476203841" target="_blank" rel="external">值得订阅的公众号、博客和书籍推荐</a></li>
<li><a href="https://www.jianshu.com/p/c158eb2f7500" target="_blank" rel="external">你还在认为HR面是走流程？</a></li>
<li><a href="https://www.jianshu.com/p/6351c9eb74ad" target="_blank" rel="external">学习千万不要完美主义</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-6cdd5189378cc6f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要适用于非一二线互联网公司 Offer 的选择。希望以下一些简单的方法，可以辅助你去判断一家公司是否靠谱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="校招" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>「校招季」学习千万不要完美主义</title>
    <link href="http://yoursite.com/2017/09/23/new/%E3%80%8C%E6%A0%A1%E6%8B%9B%E5%AD%A3%E3%80%8D%E5%AD%A6%E4%B9%A0%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89/"/>
    <id>http://yoursite.com/2017/09/23/new/「校招季」学习千万不要完美主义/</id>
    <published>2017-09-23T13:06:00.000Z</published>
    <updated>2018-12-18T12:29:44.171Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3167794-0007e6aaa96a3c16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>路人问：一本数据结构与算法的书，以数组举例，本来数组的概念挺简单的，但是书上写得像一种更广义的数学概念一样，有没有必要去理解？  </p>
<a id="more"></a>
<p>智者回答：该不该学，用不用学，这种问题，就是属于让别人没法回答的问题。严格意义讲，所有知识都是有意义的，肯定或者否定的回答都是片面的。但具体对于你现在的阶段需不需要学，是因你而异的。我的建议是，你已经有这个困惑了，其实就是不想学了，那就跳过去，等你以后发现这个知识有用，再回头仔细看，捡起来。学习就好比旅行，任性一点儿没关系，向你喜欢的风景出发。有时候回头看，发现自己错过了什么风景，再回头去追寻并不晚。不用害怕错过，重要的是一直在旅程上。</p>
<p>以上这个小对话，正对应着我们在学习中的心态问题。</p>
<!--more-->
<p>比如在学习数据结构这门课时，很多同学都表示自己对 C 已经遗忘了。甚至有的同学说要回头去重新学 C 。我个人认为大可不必。</p>
<p>在这里，和大家分享一个我的学习心得。最重要的一条，就是<strong>学习千万不要完美主义</strong>。</p>
<p>首先，要冲着自己的目标去。数据结构课程就应该把主要精力放在算法思路的学习上。课程中代码实现细节上，可能会存在一些不懂的编程语言的专有概念。其实理解一个大概，知道是干什么的就好。</p>
<p>第二点就是，学习不要奔着 100 分去。我们不应该过度着眼于我们还不够完美。学习不是要么 0 分，要么 100 分 的。80 分是收获；60 分是收获；20 分也是收获。有收获最重要。但是因为着眼于自己的不完美，最终放弃了，那就是彻底的 0 分 了。</p>
<p>如果你去听顶级学府，比如斯坦福的课程，就会发现，老师是不可能把所有细节都讲清楚的。大家一定都学过 C 语言，C 语言读取数据 <code>scanf(&quot;%d&quot;,&amp;a)</code>，这个 <code>&amp;a</code>为什么要有个<code>&amp;</code>？可能有的老师会讲什么地址符一类的。但是我认为，顶级的老师会告诉你：先接受它，记下来，scanf 中，变量前面就是先加个 <code>&amp;</code>。因为如果非要介绍什么地址符，相信 99% 的同学在初学的时候根本无法理解，反而头大，搞晕了，挫败感强，觉得这东西好难。但其实这个难度是初学 C 语言没必要接触的难度。等我们真正深入以后，再回头看，就自然而然理解了。千万不要试图一上来就搞懂一切。</p>
<p>就好像大一刚刚入门 C 语言的时候，很多同学在学习过程中就一直在诉苦，说很难，为什么这里是这样写，为什么那里是那样的。力求从一开始就搞明白一切。这样只会越学越体会不到用处。想要更快入门，就多了解怎么用，而不是为什么这么用。会使用工具才能更好地理解工具。</p>
<p>我们没有那么多时间去把东西一开始就完美地弄明白，我觉得这也不现实。但能在一开始优雅地用起来，不是更让人有成就感吗？</p>
<p>所谓的「抓大放小」。如果一时没搞懂，问自己一句，这部分内容是不是当前一定要搞懂的知识。如果是，当然要死磕；但如果不是，记录下来，尝试继续前进，以后回头再看。</p>
<p>对于学习的知识，不要妄图一次性的完全掌握，所谓<strong>温故而知新</strong>。多给自己一些回头看的机会，相信很多东西都会柳暗花明的。</p>
<hr>
<blockquote>
<p>关于面试，你可能还想知道：</p>
<ul>
<li><a href="https://www.jianshu.com/p/1bb9aac42762" target="_blank" rel="external">如何选择公司？</a></li>
<li><a href="https://www.jianshu.com/p/39c7abb13bcf" target="_blank" rel="external">怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？</a></li>
<li><a href="https://www.jianshu.com/p/9040c32b3f4c" target="_blank" rel="external">校招需要准备什么？需要复习什么知识点？</a></li>
<li><a href="https://www.jianshu.com/p/d3a476203841" target="_blank" rel="external">值得订阅的公众号、博客和书籍推荐</a></li>
<li><a href="https://www.jianshu.com/p/c158eb2f7500" target="_blank" rel="external">你还在认为HR面是走流程？</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-0007e6aaa96a3c16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;路人问：一本数据结构与算法的书，以数组举例，本来数组的概念挺简单的，但是书上写得像一种更广义的数学概念一样，有没有必要去理解？  &lt;/p&gt;
    
    </summary>
    
    
      <category term="校招" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>「校招季」怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？</title>
    <link href="http://yoursite.com/2017/09/17/%E3%80%8C%E6%A0%A1%E6%8B%9B%E5%AD%A3%E3%80%8D%E6%80%8E%E6%A0%B7%E5%81%9A%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%20And%20%E9%9D%A2%E8%AF%95%E5%AE%98%E5%88%B0%E5%BA%95%E5%9C%A8%E8%80%83%E5%AF%9F%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/09/17/「校招季」怎样做一个漂亮的项目介绍 And 面试官到底在考察什么？/</id>
    <published>2017-09-17T12:25:00.000Z</published>
    <updated>2017-09-19T15:17:40.555Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3167794-8809ace0ffc907bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="为什么要重视项目介绍？"><a href="#为什么要重视项目介绍？" class="headerlink" title="为什么要重视项目介绍？"></a>为什么要重视项目介绍？</h4><p>你可以尝试着讲一遍你的项目经历。我第一次讲的时候就挺乱的，卡壳、专业词汇匮乏、逻辑混乱、用词不当、没有介绍到项目重点……<br><a id="more"></a></p>
<p>项目经验面试在面试中占很大比重，面试官通过一些专业性的技术问题来了解你的技术水平，问题从哪来？要么来源于结构化面试题库（每个面试者的问题都一样，多出现在校招一面），要么，就是从你的简历中项目经验来。所以对项目整体而深入复习的重要性不言而喻。</p>
<p>介绍项目时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？这些都是值得你好好思考的。</p>
<h4 id="项目介绍思路"><a href="#项目介绍思路" class="headerlink" title="项目介绍思路"></a>项目介绍思路</h4><p>这部分技巧对简历上的项目介绍也是通用的。</p>
<ol>
<li><p>首先用一句话介绍这个项目做了什么，打个比方，我使用XX 框架实现了一个 XX</p>
</li>
<li><p>主要功能  </p>
<p> 挑亮点和创新点讲，细碎的功能点一句带过。 </p>
</li>
<li><p>然后讲基本的实现：主要运用到的技术点有XXX。  </p>
<p> （这里面试官从你介绍的技术点切入考察，所以要好好回顾复习项目中运用到的技术点细节。）</p>
</li>
<li><p>架构</p>
<p>（面试官还会问一问为什么你选了这样的架构／方法来实现。）</p>
</li>
<li><p>我在项目中的角色</p>
<p> 主要介绍项目中的职责和作用，是多面手 or 组长 or 技术 。这点主要凸显你的工作量和贡献率。</p>
</li>
</ol>
<blockquote>
<p>注：可以在简历上附上项目github地址，上传重点功能的演示 gif ，让面试官可以很直观地评估你的项目规模和难度。</p>
</blockquote>
<h4 id="面试官会考察些什么？"><a href="#面试官会考察些什么？" class="headerlink" title="面试官会考察些什么？"></a>面试官会考察些什么？</h4><p>知己知彼，摸清面试官心理，你才能有针对性去准备。</p>
<h5 id="1-能力、技术"><a href="#1-能力、技术" class="headerlink" title="1. 能力、技术"></a>1. 能力、技术</h5><ul>
<li><p>考察深度：深入了解哪个技术？</p>
<p>整个项目中用到了哪些开源框架？他们的实现思路是什么？你看过他们的源码吗？你不仅仅是要会用开源库和第三方SDK，还需要知道实现原理和技术细节。不然一个都是第三方堆砌起来的App，问这个说不了解，用的第三方框架，问哪个说不了解，用的SDK，你还要面试官问什么？[摊手]</p>
</li>
<li><p>考察广度</p>
<p>在进行技术选型的时候，你有过什么考虑，做过多少调查。详细地了解不同的工具/框架 思想的对比。最后是什么原因，你选定了这个技术。记住一句话：技术没有优劣，只有合不合适。功能点的实现方式有很多，往往选择的是最适合的。</p>
<p>同时面试官可能会考察你是否关注产品数据，是否关注合理的工作流程，是否关注前后台交互时的相关知识和流程，是否关注测试自动化、持续集成等其他方面。</p>
</li>
</ul>
<h5 id="2-潜力"><a href="#2-潜力" class="headerlink" title="2. 潜力"></a>2. 潜力</h5><ul>
<li><p>做项目中怎么解决问题？</p>
<p>主要展示自己解决问题的思路。  </p>
</li>
<li><p>举一反三的能力</p>
<p>面试官会提出和项目技术类似的点，考察你是否能将新知识点联系到已学的技术，然后尝试解决它。</p>
</li>
<li><p>优化项目哪些部分</p>
<p>面试官意在考察你的思考力和动手能力，开源库多多少少都会有坑，你是否在应用中排查出坑并且能埋坑。</p>
</li>
<li><p>如何快速学习项目需要的技术点</p>
<p>首先，找资料顺序是：官网文档-&gt;权威书籍-&gt;google-&gt;StackOverflow-&gt;博客。其次，新技术的学习非常考验基础。打个比方，没学过RxJava，但是如果你知道设计模式的观察者模式，理解起来就很快。</p>
</li>
</ul>
<h5 id="3-细节"><a href="#3-细节" class="headerlink" title="3. 细节"></a>3. 细节</h5><ul>
<li><p>sdk的细节了解在哪里</p>
<p>自己造轮子确实费时间，但是你又是否知道SDK做了哪些优化？</p>
</li>
<li><p>自定义控件优化</p>
</li>
<li><p>作品对比</p>
<p>自己的项目有没有和市面上的竞品比较过，客观地评价下从别人的作品中学到了什么，基于此你有没有改进自己的作品？</p>
</li>
<li><p>算法</p>
<p>主要是一些坑和解决思路、解决的灵感来源等，在项目中肯定会涉及到数据结构，比如缓存最近100条点击记录，超出100条则移除最早缓存的记录，自己实现。可能你会想到用队列或堆实现，那可以去看看缓存算法Lru算法的原理，用的什么容器，为什么这么设计？</p>
</li>
</ul>
<h5 id="4-主动性"><a href="#4-主动性" class="headerlink" title="4. 主动性"></a>4. 主动性</h5><ul>
<li>是否做过知识总结、知识沉淀？（这就是平时注重博客积累的好处了）</li>
<li>是否实践过知识分享？</li>
<li>是否主动给项目提出过意见或建议？</li>
</ul>
<h5 id="5-沟通能力"><a href="#5-沟通能力" class="headerlink" title="5. 沟通能力"></a>5. 沟通能力</h5><p>在面试的过程中，<strong>悄声无息进行的还有另一项考察 —— 沟通能力</strong>。想想自己面谈时是否能让面试官感觉舒服，是否能清晰表达自己的要点，是否能清晰表达自己未来的个人发展规划。可以尝试模拟面试录下音，看是否有过多的语气词表达出的不自信。</p>
<h5 id="6-例子"><a href="#6-例子" class="headerlink" title="6. 例子"></a>6. 例子</h5><p>说了这么多，搞个直观的例子谈谈。</p>
<p><strong>问：</strong></p>
<p>项目中推送是怎么实现的？</p>
<p><strong>答：</strong></p>
<p>刚开始做推送的时候，对目前主流的推送方案大致了解了一下。发现推送实现不止一种。  </p>
<p><strong>（展示技术选型和方案，简单谈下就ok）</strong>  </p>
<p>（1）GCM服务  </p>
<p>优点：Google提供的服务、原生、简单，无需实现和部署服务端。  </p>
<p>缺点：该服务在国内不够稳定、需要用户绑定Google帐号。  </p>
<p>（2）XMPP：  </p>
<p>优点：开放性，标准性，可扩展，跨平台，且已有开源项目。  </p>
<p>缺点：数据冗余（基于XML），不支持二进制数据，协议虽然完整扩展性虽然好，它耗费网络流量很大，跑起来比MQTT慢很多；有高达70%的流量是耗费在XMPP本身的标签和编解码上面。  </p>
<p>（3）MQTT  </p>
<p>优点：协议简洁、小巧、可扩展性强、省流量、省电。  </p>
<p>缺点：不够成熟、实现较复杂、服务端组件rsmb不开源，部署硬件成本较高。  </p>
<p>（4）HTTP轮循<br>优点：实现简单、可控性强，部署硬件成本低。<br>缺点：实时性差。  </p>
<p><strong>（体现技术细节）</strong>  </p>
<p>所以后续选型，我选择了 XMPP + MINA + AndroidPN 来实现推送。  </p>
<p><strong>（体现项目优化改进之处，体现自己的思考和能力，对开源项目进行改造）</strong></p>
<p>但是 AndroidPN 开源项目也存在一些不足之处：  </p>
<ol>
<li><p>如果将消息从服务器上推送出去，就不再管理了。</p>
<p> 我的做法是：客户端收到推送后给服务端一个反馈，如果服务端在一定时间内没有收到反馈，则重发。</p>
</li>
<li><p>androidpn服务器收到消息后如何知道要发给哪个用户？</p>
<p> 所以我加了个tag维度来做用户分组</p>
</li>
<li><p>一旦服务器重启了，客户端似乎不会自动重连，需要用户自己中断后台Service再重启应用。</p>
<p> 完善的方法是加上心跳机制和断线重连</p>
</li>
<li><p>AndroidPN服务器不保存消息。就是说它一有消息就会发出去，即使客户端根本不在线，它也不会重发。  </p>
<p>解决方案是让服务端保持对客户端状态的监控</p>
</li>
</ol>
<p><strong>再问：</strong></p>
<p>怎么不用现有的极光推送？</p>
<p><strong>答：</strong></p>
<p>极光推送初始的版本文档不全，接入麻烦，<strong>同时我对推送的原理很感兴趣，所以想自己实践下。</strong></p>
<h4 id="问题示例"><a href="#问题示例" class="headerlink" title="问题示例"></a>问题示例</h4><p>最后，是面试官针对项目面试可能提出的问题汇总。</p>
<ul>
<li><p>你参与的项目是独立完成的还是团队协作完成的，在团队里是什么角色？是负责人还是参与者？</p>
</li>
<li><p>项目执行过程中的难题你是怎么处理的？</p>
</li>
<li><p>问一些专业性的技术问题来了解你的水平。</p>
</li>
<li><p>如果是没有明确结果的项目，你从项目里学到了什么，有什么经验教训？</p>
<p>  看你的项目经验，还有思维逻辑性，对项目整体的认识，包括技术的选型和架构的设计等等。</p>
</li>
<li><p>项目技术点具体的使用场景，比如多线程的控制、性能优化、数据库设计、加密混淆等等。</p>
</li>
<li><p>挑一个你最熟悉的项目讲讲吧。</p>
</li>
<li><p>讲解你是怎么从0到1对项目进行开发和改造的。</p>
<p>题目确立 -&gt; 产品需求开发 -&gt;  概要设计 -&gt; 详细设计 -&gt; 测试用例 -&gt; 编码 -&gt; 测试 -&gt; 优化 -&gt; 宣传视频海报的制作。</p>
</li>
</ul>
<h4 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h4><p>当然，存在有的面试官倾向于问一些开放性的问题。主要看重你是如何解决问题的，看你的思维方式是怎么发散的。</p>
<p>比如面试官问我，你为什么觉得你做的产品就比别人好？你为什么要对你们的产品进行性能优化，主要瓶颈在哪里？你是通过什么方式进行优化？你优化的点是怎么考虑的？你在使用第三方服务是处于什么目的，你对它的评价是什么，它们给你带来的好处是什么？让你去思考如何更好的为开发者提供服务，你觉得还有什么东西是开发者需要的？你对开发工具类产品感兴趣吗？</p>
<p>可以从这些问题看出，面试官并不仅仅看重你的技术能力，还有你对产品的认识。面试官想找的人不仅仅要在技术上有亮点，还有其他方面能吸引到他们。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>最重要的一点：<strong>不知道的技术点不要不懂装懂</strong>。很多时候我们都会遇到一个情况，就是面试官的问题我不会，这时候大多数情况下不要马上说我不会，也不要糊弄回答，要懂得牵引，转移话题往类似的你擅长的技术点方向去，不然当你抱着侥幸心理随便回答出问题后，面试官会一直沿着往下深挖，挖到挖不出来为止，这就很尴尬了。</p>
<blockquote>
<p>受限于个人水平，如有错误之处，敬请谅解。<br>筹划面试系列很久，已经草稿6、7篇了，一直拖延症没有整理。这次参加掘金的征文比赛，就相当于催更了，本文是系列一，之后会陆陆续续补全面试其他系列。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-8809ace0ffc907bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么要重视项目介绍？&quot;&gt;&lt;a href=&quot;#为什么要重视项目介绍？&quot; class=&quot;headerlink&quot; title=&quot;为什么要重视项目介绍？&quot;&gt;&lt;/a&gt;为什么要重视项目介绍？&lt;/h4&gt;&lt;p&gt;你可以尝试着讲一遍你的项目经历。我第一次讲的时候就挺乱的，卡壳、专业词汇匮乏、逻辑混乱、用词不当、没有介绍到项目重点……&lt;br&gt;
    
    </summary>
    
    
      <category term="校招" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="项目介绍" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
      <category term="系列文" scheme="http://yoursite.com/tags/%E7%B3%BB%E5%88%97%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-网易易盾验证码异常-libEGL--validate_display-99-error-3008-(EGL_BAD_DISPLAY)</title>
    <link href="http://yoursite.com/2017/07/24/Android-%E2%80%94%E2%80%94-%E7%BD%91%E6%98%93%E6%98%93%E7%9B%BE%E9%AA%8C%E8%AF%81%E7%A0%81%E5%BC%82%E5%B8%B8-libEGL--validate_display-99-error-3008-(EGL_BAD_D/"/>
    <id>http://yoursite.com/2017/07/24/Android-——-网易易盾验证码异常-libEGL--validate_display-99-error-3008-(EGL_BAD_D/</id>
    <published>2017-07-24T08:00:00.000Z</published>
    <updated>2017-08-20T04:27:26.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前提：WebView在 Android 5.1 测试机上正常显示，在 Android 7.0 上无法显示，一直 loading 。（注：url 为 htts 协议）</p>
</blockquote>
<p>考虑到验证码的 Webview 和 Listener 都是自己重写，可能漏掉了什么，果然在细细翻看官方源码的时候，发现了 WebViewClient 多复写了 onReceivedSslError 监听，初步判断是遇到证书问题。</p>
<p>解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mWebView.setWebViewClient(new WebViewClient() &#123;</div><div class="line">           @Override</div><div class="line">           public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;</div><div class="line">               handler.proceed(); // Ignore SSL certificate errors</div><div class="line">           // fix for: SSL Error. Failed to validate the certificate chain </div><div class="line">           //不要调用super.xxxx</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>原因：</p>
<p>在 Android 中，WebView 可以用来加载 http 和 https 网页到本地应用的控件。在默认情况下，通过 <code>loadUrl(String url)</code> 方法，可以顺利  <code>loadUrl(&quot;http://www.baidu.com&quot;)</code>之类的页面。但是，当 load 通过 ssl 加密的 https 页面，且这个网站的安全证书在 Android 无法得到认证时，WebView就会变成一个空白页，而并不会像自带的浏览器一样弹出提示。因此，我们必须针对这种情况进行处理。</p>
<p>拓展：</p>
<p>不过如果在 <code>onReceivedSslError</code> 方法中实现调用了 <code>handler.proceed()</code>来忽略该证书错误，则会受到中间人攻击的威胁，可能导致隐私泄露。可以采用默认的处理方法<code>handler.cancel()</code>，停止加载问题页面。<br>（鉴于项目需求，所以仍然采用<code>handler.proceed();</code>）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前提：WebView在 Android 5.1 测试机上正常显示，在 Android 7.0 上无法显示，一直 loading 。（注：url 为 htts 协议）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑到验证码的 Webview 和 Listener 都是自己重写，可能漏掉了什么，果然在细细翻看官方源码的时候，发现了 WebViewClient 多复写了 onReceivedSslError 监听，初步判断是遇到证书问题。&lt;/p&gt;
&lt;p&gt;解决：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mWebView.setWebViewClient(new WebViewClient() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           @Override&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;               handler.proceed(); // Ignore SSL certificate errors&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           // fix for: SSL Error. Failed to validate the certificate chain &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           //不要调用super.xxxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android-——-打包INSTALL_PARSE_FAILED_NO_CERTIFICATES异常</title>
    <link href="http://yoursite.com/2017/07/20/Android-%E2%80%94%E2%80%94-%E6%89%93%E5%8C%85INSTALL_PARSE_FAILED_NO_CERTIFICATES%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/07/20/Android-——-打包INSTALL_PARSE_FAILED_NO_CERTIFICATES异常/</id>
    <published>2017-07-20T03:43:00.000Z</published>
    <updated>2017-08-20T04:28:14.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前提：明明已经签名，在安装时却提示 <code>INSTALL_PARSE_FAILED_NO_CERTIFICATES</code> 异常</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-6b4e49bade94fed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装失败情形"></p>
<p>排查：</p>
<p>安装的测试机系统为 5.0，只采用了 v2 签名</p>
<a id="more"></a>
<p>解决：</p>
<p>改为安装在 7.0 手机或者选择 v1 + v2 签名。</p>
<p>原因：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-ae621be14c406309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在 Android 7.0 以上版本的设备上，APK 可以根据Full Apk Signature（v2 方案） 或者 JAR-signed（ v1方案）进行验证； 而对于7.0以下版本的设备其会忽略 v2 版本的签名，<strong>只验证 v1 签名</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3167794-74f969787e7d154a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证的流程.png"></p>
<p>结论：</p>
<ul>
<li>一定可行的方案： 只使用 v1 方案</li>
<li>不一定可行的方案：同时使用 v1 和 v2 方案</li>
<li>对 7.0 以下<strong>一定不行</strong>的方案：只使用 v2 方案</li>
</ul>
<p>如果要支持 Android 7.0 以下版本，那么尽量同时选择两种签名方式，但是一旦遇到签名问题，可以只使用 v1 签名方案</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前提：明明已经签名，在安装时却提示 &lt;code&gt;INSTALL_PARSE_FAILED_NO_CERTIFICATES&lt;/code&gt; 异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3167794-6b4e49bade94fed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装失败情形&quot;&gt;&lt;/p&gt;
&lt;p&gt;排查：&lt;/p&gt;
&lt;p&gt;安装的测试机系统为 5.0，只采用了 v2 签名&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 和Java的型变</title>
    <link href="http://yoursite.com/2017/07/13/Kotlin-%E5%92%8CJava%E7%9A%84%E5%9E%8B%E5%8F%98/"/>
    <id>http://yoursite.com/2017/07/13/Kotlin-和Java的型变/</id>
    <published>2017-07-13T07:25:00.000Z</published>
    <updated>2017-09-03T09:00:10.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java-的型变"><a href="#1-Java-的型变" class="headerlink" title="1. Java 的型变"></a>1. Java 的型变</h3><p>如果 Parent 是 Child 的父类，那么 <code>List&lt;Parent&gt;</code> 和<code>List&lt;Child&gt;</code> 的关系是什么呢？对于 Java 来说，没有关系。<br><a id="more"></a><br>也就是说下面的代码是无法编译的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Number&gt; numbers = new ArrayList&lt;Integer&gt;(); //ERROR!</div></pre></td></tr></table></figure>
<p>不过 numbers 中可以添加 Number 类型的对象，所以我添加个 Integer 可以不呢？可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers.add(1);</div></pre></td></tr></table></figure></p>
<p>那么我要想添加一堆 Integer 呢？用 addAll 是吧？注意看下 addAll 的签名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean addAll(Collection&lt;? extends E&gt; c);</div></pre></td></tr></table></figure></p>
<p>这个泛型参数又是什么鬼？如果我把这个签名写成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean addAll(Collection&lt;E&gt; c);</div></pre></td></tr></table></figure></p>
<p>我想要在 numbers 当中<code>addAll</code> 一个 <code>ArrayList&lt;Integer&gt;</code>，那就不可能了，因为我们说过，<code>ArrayList&lt;Number&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code>是两个不同的类型，毛关系都没有。</p>
<p><code>? extends E</code> 其实就是使用点协变，允许传入的参数可以是泛型参数类型为<code>Number</code> 子类的任意类型。</p>
<p>当然，也有 <code>? super E</code>的用法，这表示元素类型为<code>E</code> 及其父类，这个通常也叫作逆变。</p>
<h3 id="2-Kotlin-的型变"><a href="#2-Kotlin-的型变" class="headerlink" title="2. Kotlin 的型变"></a>2. Kotlin 的型变</h3><blockquote>
<p>型变包括协变、逆变、不变三种</p>
</blockquote>
<p>下面我们看看 Kotlin 是怎么支持这个特性的。Kotlin 支持声明点型变，我们直接看 Collection 接口的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>out E</code> 就是型变的定义，表明 Collection 的元素类型是协变的，即 <code>Collection&lt;Number&gt;</code> 也是 <code>Collection&lt;Int&gt;</code> 的父类。</p>
<p>而对于 <code>MutableList</code> 来说，它的元素类型就是不变的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface MutableCollection&lt;E&gt; : Collection&lt;E&gt;, MutableIterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">   public fun addAll(elements: Collection&lt;E&gt;): Boolean </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>换言之，<code>MutableCollection&lt;Number&gt;</code> 与<code>MutableCollection&lt;Int&gt;</code> 没有什么关系。</p>
<p>那么请注意看 addAll 的声明，参数是 <code>Collection&lt;E&gt;</code>，而 Collection 是协变的，所以传入的参数可以是任意 E 或者其子类的集合。</p>
<p>逆变的写法也简单一些： <code>Collection&lt;in E&gt;</code>。</p>
<p>那么 Kotlin 是否支持使用点型变呢？当然支持。</p>
<p>我们刚才说 <code>MutableCollection</code> 是不变的，那么如果下面的参数改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public fun addAll(elements: MutableCollection&lt;E&gt;): Boolean</div></pre></td></tr></table></figure>
<p>结果就是，当 E 为 Number 时，addAll 无法接类受似<code>ArrayList&lt;Int&gt;</code>的参数。而为了接受这样的参数，我们可以修改一下签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public fun addAll(elements: MutableCollection&lt;out E&gt;): Boolean</div></pre></td></tr></table></figure>
<p>这其实就与 Java 的型变完全一致了。</p>
<h3 id="3-UnsafeVariance"><a href="#3-UnsafeVariance" class="headerlink" title="3. @UnsafeVariance"></a>3. @UnsafeVariance</h3><p>型变是一个让人费解的话题，很多人接触这东西的时候一开始都会比较晕，我们来看看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyCollection&lt;out T&gt;&#123; </div><div class="line">    fun add(t: T)&#123; // ERROR! </div><div class="line">       ... </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为什么会报错呢？因为 T 是协变的，所以外部传入的参数类型如果是 T 的话，会出问题，不信你看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myList: MyCollection&lt;Number&gt; = MyCollection&lt;Int&gt;() </div><div class="line">myList.add(3.0)</div></pre></td></tr></table></figure></p>
<p>上面的代码毫无疑问可以编译，但运行时就会比较尴尬，因为 <code>MyCollection&lt;Int&gt;</code> 希望接受的是 <code>Int</code>，没想到来了一个 <code>Double</code>。。</p>
<p>对于协变的类型，通常我们是不允许将泛型类型作为传入参数的类型的，或者说，对于协变类型，我们通常是不允许其涉及泛型参数的部分被改变的。这也很容易解释为什么 MutableCollection 是不变的，而 Collection 是协变的，因为在 Kotlin 当中，前者是可被修改的，后者是不可被修改的。</p>
<p>逆变的情形正好相反，即不可以将泛型参数作为方法的返回值。</p>
<p>但实际上有些情况下，我们不得已需要在协变的情况下使用泛型参数类型作为方法参数的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123; </div><div class="line">   ... </div><div class="line">    public operator fun contains(element: @UnsafeVariance E): Boolean </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如这种情形，为了让编译器放过一马，我们就可以用 @UnsafeVariance 来告诉编译器：“我知道我在干啥，保证不会出错，你不用担心”。</p>
<p>最后再给大家提一个点，现在你们知道为什么 in 表示逆变，out 表示协变了吗？</p>
<blockquote>
<p>节选自：<a href="https://mp.weixin.qq.com/s/WUoanF3_OAP0dRoxBQu_bQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/WUoanF3_OAP0dRoxBQu_bQ</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Java-的型变&quot;&gt;&lt;a href=&quot;#1-Java-的型变&quot; class=&quot;headerlink&quot; title=&quot;1. Java 的型变&quot;&gt;&lt;/a&gt;1. Java 的型变&lt;/h3&gt;&lt;p&gt;如果 Parent 是 Child 的父类，那么 &lt;code&gt;List&amp;lt;Parent&amp;gt;&lt;/code&gt; 和&lt;code&gt;List&amp;lt;Child&amp;gt;&lt;/code&gt; 的关系是什么呢？对于 Java 来说，没有关系。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
</feed>
